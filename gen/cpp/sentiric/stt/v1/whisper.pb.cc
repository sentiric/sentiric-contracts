// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sentiric/stt/v1/whisper.proto

#include "sentiric/stt/v1/whisper.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sentiric {
namespace stt {
namespace v1 {
PROTOBUF_CONSTEXPR WhisperTranscribeRequest::WhisperTranscribeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct WhisperTranscribeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperTranscribeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperTranscribeRequestDefaultTypeInternal() {}
  union {
    WhisperTranscribeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperTranscribeRequestDefaultTypeInternal _WhisperTranscribeRequest_default_instance_;
PROTOBUF_CONSTEXPR WhisperTranscribeResponse::WhisperTranscribeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transcription_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.language_probability_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WhisperTranscribeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperTranscribeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperTranscribeResponseDefaultTypeInternal() {}
  union {
    WhisperTranscribeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperTranscribeResponseDefaultTypeInternal _WhisperTranscribeResponse_default_instance_;
PROTOBUF_CONSTEXPR WhisperTranscribeStreamRequest::WhisperTranscribeStreamRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.audio_chunk_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WhisperTranscribeStreamRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperTranscribeStreamRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperTranscribeStreamRequestDefaultTypeInternal() {}
  union {
    WhisperTranscribeStreamRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperTranscribeStreamRequestDefaultTypeInternal _WhisperTranscribeStreamRequest_default_instance_;
PROTOBUF_CONSTEXPR WhisperTranscribeStreamResponse::WhisperTranscribeStreamResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transcription_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_final_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WhisperTranscribeStreamResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperTranscribeStreamResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperTranscribeStreamResponseDefaultTypeInternal() {}
  union {
    WhisperTranscribeStreamResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperTranscribeStreamResponseDefaultTypeInternal _WhisperTranscribeStreamResponse_default_instance_;
}  // namespace v1
}  // namespace stt
}  // namespace sentiric
static ::_pb::Metadata file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[4];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_sentiric_2fstt_2fv1_2fwhisper_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_sentiric_2fstt_2fv1_2fwhisper_2eproto = nullptr;

const uint32_t TableStruct_sentiric_2fstt_2fv1_2fwhisper_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeRequest, _impl_.audio_data_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeRequest, _impl_.language_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.transcription_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.language_probability_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.duration_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamRequest, _impl_.audio_chunk_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.transcription_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.is_final_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::sentiric::stt::v1::WhisperTranscribeRequest)},
  { 10, -1, -1, sizeof(::sentiric::stt::v1::WhisperTranscribeResponse)},
  { 20, -1, -1, sizeof(::sentiric::stt::v1::WhisperTranscribeStreamRequest)},
  { 27, -1, -1, sizeof(::sentiric::stt::v1::WhisperTranscribeStreamResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::sentiric::stt::v1::_WhisperTranscribeRequest_default_instance_._instance,
  &::sentiric::stt::v1::_WhisperTranscribeResponse_default_instance_._instance,
  &::sentiric::stt::v1::_WhisperTranscribeStreamRequest_default_instance_._instance,
  &::sentiric::stt::v1::_WhisperTranscribeStreamResponse_default_instance_._instance,
};

const char descriptor_table_protodef_sentiric_2fstt_2fv1_2fwhisper_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035sentiric/stt/v1/whisper.proto\022\017sentiri"
  "c.stt.v1\"R\n\030WhisperTranscribeRequest\022\022\n\n"
  "audio_data\030\001 \001(\014\022\025\n\010language\030\002 \001(\tH\000\210\001\001B"
  "\013\n\t_language\"t\n\031WhisperTranscribeRespons"
  "e\022\025\n\rtranscription\030\001 \001(\t\022\020\n\010language\030\002 \001"
  "(\t\022\034\n\024language_probability\030\003 \001(\002\022\020\n\010dura"
  "tion\030\004 \001(\001\"5\n\036WhisperTranscribeStreamReq"
  "uest\022\023\n\013audio_chunk\030\001 \001(\014\"J\n\037WhisperTran"
  "scribeStreamResponse\022\025\n\rtranscription\030\001 "
  "\001(\t\022\020\n\010is_final\030\002 \001(\0102\202\002\n\021SttWhisperServ"
  "ice\022j\n\021WhisperTranscribe\022).sentiric.stt."
  "v1.WhisperTranscribeRequest\032*.sentiric.s"
  "tt.v1.WhisperTranscribeResponse\022\200\001\n\027Whis"
  "perTranscribeStream\022/.sentiric.stt.v1.Wh"
  "isperTranscribeStreamRequest\0320.sentiric."
  "stt.v1.WhisperTranscribeStreamResponse(\001"
  "0\001BEZCgithub.com/sentiric/sentiric-contr"
  "acts/gen/go/sentiric/stt/v1;sttv1b\006proto"
  "3"
  ;
static ::_pbi::once_flag descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto = {
    false, false, 721, descriptor_table_protodef_sentiric_2fstt_2fv1_2fwhisper_2eproto,
    "sentiric/stt/v1/whisper.proto",
    &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once, nullptr, 0, 4,
    schemas, file_default_instances, TableStruct_sentiric_2fstt_2fv1_2fwhisper_2eproto::offsets,
    file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto, file_level_enum_descriptors_sentiric_2fstt_2fv1_2fwhisper_2eproto,
    file_level_service_descriptors_sentiric_2fstt_2fv1_2fwhisper_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter() {
  return &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_sentiric_2fstt_2fv1_2fwhisper_2eproto(&descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto);
namespace sentiric {
namespace stt {
namespace v1 {

// ===================================================================

class WhisperTranscribeRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<WhisperTranscribeRequest>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

WhisperTranscribeRequest::WhisperTranscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sentiric.stt.v1.WhisperTranscribeRequest)
}
WhisperTranscribeRequest::WhisperTranscribeRequest(const WhisperTranscribeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhisperTranscribeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_data_){}
    , decltype(_impl_.language_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.audio_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_audio_data().empty()) {
    _this->_impl_.audio_data_.Set(from._internal_audio_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sentiric.stt.v1.WhisperTranscribeRequest)
}

inline void WhisperTranscribeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_data_){}
    , decltype(_impl_.language_){}
  };
  _impl_.audio_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WhisperTranscribeRequest::~WhisperTranscribeRequest() {
  // @@protoc_insertion_point(destructor:sentiric.stt.v1.WhisperTranscribeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhisperTranscribeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.audio_data_.Destroy();
  _impl_.language_.Destroy();
}

void WhisperTranscribeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhisperTranscribeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sentiric.stt.v1.WhisperTranscribeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.audio_data_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.language_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhisperTranscribeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes audio_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_audio_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeRequest.language"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhisperTranscribeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sentiric.stt.v1.WhisperTranscribeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes audio_data = 1;
  if (!this->_internal_audio_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_audio_data(), target);
  }

  // optional string language = 2;
  if (_internal_has_language()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeRequest.language");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_language(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sentiric.stt.v1.WhisperTranscribeRequest)
  return target;
}

size_t WhisperTranscribeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sentiric.stt.v1.WhisperTranscribeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes audio_data = 1;
  if (!this->_internal_audio_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_audio_data());
  }

  // optional string language = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhisperTranscribeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhisperTranscribeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhisperTranscribeRequest::GetClassData() const { return &_class_data_; }


void WhisperTranscribeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhisperTranscribeRequest*>(&to_msg);
  auto& from = static_cast<const WhisperTranscribeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sentiric.stt.v1.WhisperTranscribeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_audio_data().empty()) {
    _this->_internal_set_audio_data(from._internal_audio_data());
  }
  if (from._internal_has_language()) {
    _this->_internal_set_language(from._internal_language());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhisperTranscribeRequest::CopyFrom(const WhisperTranscribeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sentiric.stt.v1.WhisperTranscribeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhisperTranscribeRequest::IsInitialized() const {
  return true;
}

void WhisperTranscribeRequest::InternalSwap(WhisperTranscribeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audio_data_, lhs_arena,
      &other->_impl_.audio_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WhisperTranscribeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter, &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once,
      file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[0]);
}

// ===================================================================

class WhisperTranscribeResponse::_Internal {
 public:
};

WhisperTranscribeResponse::WhisperTranscribeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sentiric.stt.v1.WhisperTranscribeResponse)
}
WhisperTranscribeResponse::WhisperTranscribeResponse(const WhisperTranscribeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhisperTranscribeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transcription_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.language_probability_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transcription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transcription().empty()) {
    _this->_impl_.transcription_.Set(from._internal_transcription(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language().empty()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.duration_, &from._impl_.duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.language_probability_) -
    reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.language_probability_));
  // @@protoc_insertion_point(copy_constructor:sentiric.stt.v1.WhisperTranscribeResponse)
}

inline void WhisperTranscribeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transcription_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.duration_){0}
    , decltype(_impl_.language_probability_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transcription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WhisperTranscribeResponse::~WhisperTranscribeResponse() {
  // @@protoc_insertion_point(destructor:sentiric.stt.v1.WhisperTranscribeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhisperTranscribeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transcription_.Destroy();
  _impl_.language_.Destroy();
}

void WhisperTranscribeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhisperTranscribeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sentiric.stt.v1.WhisperTranscribeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transcription_.ClearToEmpty();
  _impl_.language_.ClearToEmpty();
  ::memset(&_impl_.duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.language_probability_) -
      reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.language_probability_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhisperTranscribeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transcription = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transcription();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeResponse.transcription"));
        } else
          goto handle_unusual;
        continue;
      // string language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeResponse.language"));
        } else
          goto handle_unusual;
        continue;
      // float language_probability = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.language_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // double duration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhisperTranscribeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sentiric.stt.v1.WhisperTranscribeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transcription = 1;
  if (!this->_internal_transcription().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transcription().data(), static_cast<int>(this->_internal_transcription().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeResponse.transcription");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_transcription(), target);
  }

  // string language = 2;
  if (!this->_internal_language().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeResponse.language");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_language(), target);
  }

  // float language_probability = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_language_probability = this->_internal_language_probability();
  uint32_t raw_language_probability;
  memcpy(&raw_language_probability, &tmp_language_probability, sizeof(tmp_language_probability));
  if (raw_language_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_language_probability(), target);
  }

  // double duration = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_duration = this->_internal_duration();
  uint64_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sentiric.stt.v1.WhisperTranscribeResponse)
  return target;
}

size_t WhisperTranscribeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sentiric.stt.v1.WhisperTranscribeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string transcription = 1;
  if (!this->_internal_transcription().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transcription());
  }

  // string language = 2;
  if (!this->_internal_language().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  // double duration = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_duration = this->_internal_duration();
  uint64_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    total_size += 1 + 8;
  }

  // float language_probability = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_language_probability = this->_internal_language_probability();
  uint32_t raw_language_probability;
  memcpy(&raw_language_probability, &tmp_language_probability, sizeof(tmp_language_probability));
  if (raw_language_probability != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhisperTranscribeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhisperTranscribeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhisperTranscribeResponse::GetClassData() const { return &_class_data_; }


void WhisperTranscribeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhisperTranscribeResponse*>(&to_msg);
  auto& from = static_cast<const WhisperTranscribeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sentiric.stt.v1.WhisperTranscribeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_transcription().empty()) {
    _this->_internal_set_transcription(from._internal_transcription());
  }
  if (!from._internal_language().empty()) {
    _this->_internal_set_language(from._internal_language());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_duration = from._internal_duration();
  uint64_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    _this->_internal_set_duration(from._internal_duration());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_language_probability = from._internal_language_probability();
  uint32_t raw_language_probability;
  memcpy(&raw_language_probability, &tmp_language_probability, sizeof(tmp_language_probability));
  if (raw_language_probability != 0) {
    _this->_internal_set_language_probability(from._internal_language_probability());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhisperTranscribeResponse::CopyFrom(const WhisperTranscribeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sentiric.stt.v1.WhisperTranscribeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhisperTranscribeResponse::IsInitialized() const {
  return true;
}

void WhisperTranscribeResponse::InternalSwap(WhisperTranscribeResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transcription_, lhs_arena,
      &other->_impl_.transcription_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WhisperTranscribeResponse, _impl_.language_probability_)
      + sizeof(WhisperTranscribeResponse::_impl_.language_probability_)
      - PROTOBUF_FIELD_OFFSET(WhisperTranscribeResponse, _impl_.duration_)>(
          reinterpret_cast<char*>(&_impl_.duration_),
          reinterpret_cast<char*>(&other->_impl_.duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WhisperTranscribeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter, &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once,
      file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[1]);
}

// ===================================================================

class WhisperTranscribeStreamRequest::_Internal {
 public:
};

WhisperTranscribeStreamRequest::WhisperTranscribeStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sentiric.stt.v1.WhisperTranscribeStreamRequest)
}
WhisperTranscribeStreamRequest::WhisperTranscribeStreamRequest(const WhisperTranscribeStreamRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhisperTranscribeStreamRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.audio_chunk_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.audio_chunk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_chunk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_audio_chunk().empty()) {
    _this->_impl_.audio_chunk_.Set(from._internal_audio_chunk(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sentiric.stt.v1.WhisperTranscribeStreamRequest)
}

inline void WhisperTranscribeStreamRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.audio_chunk_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.audio_chunk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_chunk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WhisperTranscribeStreamRequest::~WhisperTranscribeStreamRequest() {
  // @@protoc_insertion_point(destructor:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhisperTranscribeStreamRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.audio_chunk_.Destroy();
}

void WhisperTranscribeStreamRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhisperTranscribeStreamRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.audio_chunk_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhisperTranscribeStreamRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes audio_chunk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_audio_chunk();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhisperTranscribeStreamRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes audio_chunk = 1;
  if (!this->_internal_audio_chunk().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_audio_chunk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  return target;
}

size_t WhisperTranscribeStreamRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes audio_chunk = 1;
  if (!this->_internal_audio_chunk().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_audio_chunk());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhisperTranscribeStreamRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhisperTranscribeStreamRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhisperTranscribeStreamRequest::GetClassData() const { return &_class_data_; }


void WhisperTranscribeStreamRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhisperTranscribeStreamRequest*>(&to_msg);
  auto& from = static_cast<const WhisperTranscribeStreamRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_audio_chunk().empty()) {
    _this->_internal_set_audio_chunk(from._internal_audio_chunk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhisperTranscribeStreamRequest::CopyFrom(const WhisperTranscribeStreamRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhisperTranscribeStreamRequest::IsInitialized() const {
  return true;
}

void WhisperTranscribeStreamRequest::InternalSwap(WhisperTranscribeStreamRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audio_chunk_, lhs_arena,
      &other->_impl_.audio_chunk_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WhisperTranscribeStreamRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter, &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once,
      file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[2]);
}

// ===================================================================

class WhisperTranscribeStreamResponse::_Internal {
 public:
};

WhisperTranscribeStreamResponse::WhisperTranscribeStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sentiric.stt.v1.WhisperTranscribeStreamResponse)
}
WhisperTranscribeStreamResponse::WhisperTranscribeStreamResponse(const WhisperTranscribeStreamResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhisperTranscribeStreamResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transcription_){}
    , decltype(_impl_.is_final_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transcription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transcription().empty()) {
    _this->_impl_.transcription_.Set(from._internal_transcription(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.is_final_ = from._impl_.is_final_;
  // @@protoc_insertion_point(copy_constructor:sentiric.stt.v1.WhisperTranscribeStreamResponse)
}

inline void WhisperTranscribeStreamResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transcription_){}
    , decltype(_impl_.is_final_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transcription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WhisperTranscribeStreamResponse::~WhisperTranscribeStreamResponse() {
  // @@protoc_insertion_point(destructor:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhisperTranscribeStreamResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transcription_.Destroy();
}

void WhisperTranscribeStreamResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhisperTranscribeStreamResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transcription_.ClearToEmpty();
  _impl_.is_final_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhisperTranscribeStreamResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transcription = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transcription();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeStreamResponse.transcription"));
        } else
          goto handle_unusual;
        continue;
      // bool is_final = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.is_final_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhisperTranscribeStreamResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transcription = 1;
  if (!this->_internal_transcription().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transcription().data(), static_cast<int>(this->_internal_transcription().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeStreamResponse.transcription");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_transcription(), target);
  }

  // bool is_final = 2;
  if (this->_internal_is_final() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_final(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  return target;
}

size_t WhisperTranscribeStreamResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string transcription = 1;
  if (!this->_internal_transcription().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transcription());
  }

  // bool is_final = 2;
  if (this->_internal_is_final() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhisperTranscribeStreamResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhisperTranscribeStreamResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhisperTranscribeStreamResponse::GetClassData() const { return &_class_data_; }


void WhisperTranscribeStreamResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhisperTranscribeStreamResponse*>(&to_msg);
  auto& from = static_cast<const WhisperTranscribeStreamResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_transcription().empty()) {
    _this->_internal_set_transcription(from._internal_transcription());
  }
  if (from._internal_is_final() != 0) {
    _this->_internal_set_is_final(from._internal_is_final());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhisperTranscribeStreamResponse::CopyFrom(const WhisperTranscribeStreamResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhisperTranscribeStreamResponse::IsInitialized() const {
  return true;
}

void WhisperTranscribeStreamResponse::InternalSwap(WhisperTranscribeStreamResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transcription_, lhs_arena,
      &other->_impl_.transcription_, rhs_arena
  );
  swap(_impl_.is_final_, other->_impl_.is_final_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WhisperTranscribeStreamResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter, &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once,
      file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[3]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace stt
}  // namespace sentiric
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sentiric::stt::v1::WhisperTranscribeRequest*
Arena::CreateMaybeMessage< ::sentiric::stt::v1::WhisperTranscribeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sentiric::stt::v1::WhisperTranscribeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sentiric::stt::v1::WhisperTranscribeResponse*
Arena::CreateMaybeMessage< ::sentiric::stt::v1::WhisperTranscribeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sentiric::stt::v1::WhisperTranscribeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sentiric::stt::v1::WhisperTranscribeStreamRequest*
Arena::CreateMaybeMessage< ::sentiric::stt::v1::WhisperTranscribeStreamRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sentiric::stt::v1::WhisperTranscribeStreamRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sentiric::stt::v1::WhisperTranscribeStreamResponse*
Arena::CreateMaybeMessage< ::sentiric::stt::v1::WhisperTranscribeStreamResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sentiric::stt::v1::WhisperTranscribeStreamResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
