// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sentiric/stt/v1/whisper.proto

#include "sentiric/stt/v1/whisper.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sentiric {
namespace stt {
namespace v1 {
PROTOBUF_CONSTEXPR WhisperTranscribeRequest::WhisperTranscribeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct WhisperTranscribeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperTranscribeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperTranscribeRequestDefaultTypeInternal() {}
  union {
    WhisperTranscribeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperTranscribeRequestDefaultTypeInternal _WhisperTranscribeRequest_default_instance_;
PROTOBUF_CONSTEXPR WhisperTranscribeResponse::WhisperTranscribeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.speaker_vec_)*/{}
  , /*decltype(_impl_.transcription_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gender_proxy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.emotion_proxy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.language_probability_)*/0
  , /*decltype(_impl_.arousal_)*/0
  , /*decltype(_impl_.valence_)*/0
  , /*decltype(_impl_.pitch_mean_)*/0
  , /*decltype(_impl_.pitch_std_)*/0
  , /*decltype(_impl_.energy_mean_)*/0
  , /*decltype(_impl_.energy_std_)*/0
  , /*decltype(_impl_.spectral_centroid_)*/0
  , /*decltype(_impl_.zero_crossing_rate_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WhisperTranscribeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperTranscribeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperTranscribeResponseDefaultTypeInternal() {}
  union {
    WhisperTranscribeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperTranscribeResponseDefaultTypeInternal _WhisperTranscribeResponse_default_instance_;
PROTOBUF_CONSTEXPR WhisperTranscribeStreamRequest::WhisperTranscribeStreamRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.audio_chunk_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WhisperTranscribeStreamRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperTranscribeStreamRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperTranscribeStreamRequestDefaultTypeInternal() {}
  union {
    WhisperTranscribeStreamRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperTranscribeStreamRequestDefaultTypeInternal _WhisperTranscribeStreamRequest_default_instance_;
PROTOBUF_CONSTEXPR WhisperTranscribeStreamResponse::WhisperTranscribeStreamResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.speaker_vec_)*/{}
  , /*decltype(_impl_.transcription_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gender_proxy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.emotion_proxy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_final_)*/false
  , /*decltype(_impl_.arousal_)*/0
  , /*decltype(_impl_.valence_)*/0
  , /*decltype(_impl_.pitch_mean_)*/0
  , /*decltype(_impl_.pitch_std_)*/0
  , /*decltype(_impl_.energy_mean_)*/0
  , /*decltype(_impl_.energy_std_)*/0
  , /*decltype(_impl_.spectral_centroid_)*/0
  , /*decltype(_impl_.zero_crossing_rate_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WhisperTranscribeStreamResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperTranscribeStreamResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperTranscribeStreamResponseDefaultTypeInternal() {}
  union {
    WhisperTranscribeStreamResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperTranscribeStreamResponseDefaultTypeInternal _WhisperTranscribeStreamResponse_default_instance_;
}  // namespace v1
}  // namespace stt
}  // namespace sentiric
static ::_pb::Metadata file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[4];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_sentiric_2fstt_2fv1_2fwhisper_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_sentiric_2fstt_2fv1_2fwhisper_2eproto = nullptr;

const uint32_t TableStruct_sentiric_2fstt_2fv1_2fwhisper_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeRequest, _impl_.audio_data_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeRequest, _impl_.language_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.transcription_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.language_probability_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.gender_proxy_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.emotion_proxy_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.arousal_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.valence_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.pitch_mean_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.pitch_std_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.energy_mean_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.energy_std_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.spectral_centroid_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.zero_crossing_rate_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeResponse, _impl_.speaker_vec_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamRequest, _impl_.audio_chunk_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.transcription_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.is_final_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.gender_proxy_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.emotion_proxy_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.arousal_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.valence_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.pitch_mean_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.pitch_std_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.energy_mean_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.energy_std_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.spectral_centroid_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.zero_crossing_rate_),
  PROTOBUF_FIELD_OFFSET(::sentiric::stt::v1::WhisperTranscribeStreamResponse, _impl_.speaker_vec_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::sentiric::stt::v1::WhisperTranscribeRequest)},
  { 10, -1, -1, sizeof(::sentiric::stt::v1::WhisperTranscribeResponse)},
  { 31, -1, -1, sizeof(::sentiric::stt::v1::WhisperTranscribeStreamRequest)},
  { 38, -1, -1, sizeof(::sentiric::stt::v1::WhisperTranscribeStreamResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::sentiric::stt::v1::_WhisperTranscribeRequest_default_instance_._instance,
  &::sentiric::stt::v1::_WhisperTranscribeResponse_default_instance_._instance,
  &::sentiric::stt::v1::_WhisperTranscribeStreamRequest_default_instance_._instance,
  &::sentiric::stt::v1::_WhisperTranscribeStreamResponse_default_instance_._instance,
};

const char descriptor_table_protodef_sentiric_2fstt_2fv1_2fwhisper_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035sentiric/stt/v1/whisper.proto\022\017sentiri"
  "c.stt.v1\"R\n\030WhisperTranscribeRequest\022\022\n\n"
  "audio_data\030\001 \001(\014\022\025\n\010language\030\002 \001(\tH\000\210\001\001B"
  "\013\n\t_language\"\337\002\n\031WhisperTranscribeRespon"
  "se\022\025\n\rtranscription\030\001 \001(\t\022\020\n\010language\030\002 "
  "\001(\t\022\034\n\024language_probability\030\003 \001(\002\022\020\n\010dur"
  "ation\030\004 \001(\001\022\024\n\014gender_proxy\030\005 \001(\t\022\025\n\remo"
  "tion_proxy\030\006 \001(\t\022\017\n\007arousal\030\007 \001(\002\022\017\n\007val"
  "ence\030\010 \001(\002\022\022\n\npitch_mean\030\t \001(\002\022\021\n\tpitch_"
  "std\030\n \001(\002\022\023\n\013energy_mean\030\013 \001(\002\022\022\n\nenergy"
  "_std\030\014 \001(\002\022\031\n\021spectral_centroid\030\r \001(\002\022\032\n"
  "\022zero_crossing_rate\030\016 \001(\002\022\023\n\013speaker_vec"
  "\030\017 \003(\002\"5\n\036WhisperTranscribeStreamRequest"
  "\022\023\n\013audio_chunk\030\001 \001(\014\"\265\002\n\037WhisperTranscr"
  "ibeStreamResponse\022\025\n\rtranscription\030\001 \001(\t"
  "\022\020\n\010is_final\030\002 \001(\010\022\024\n\014gender_proxy\030\003 \001(\t"
  "\022\025\n\remotion_proxy\030\004 \001(\t\022\017\n\007arousal\030\005 \001(\002"
  "\022\017\n\007valence\030\006 \001(\002\022\022\n\npitch_mean\030\007 \001(\002\022\021\n"
  "\tpitch_std\030\010 \001(\002\022\023\n\013energy_mean\030\t \001(\002\022\022\n"
  "\nenergy_std\030\n \001(\002\022\031\n\021spectral_centroid\030\013"
  " \001(\002\022\032\n\022zero_crossing_rate\030\014 \001(\002\022\023\n\013spea"
  "ker_vec\030\r \003(\0022\202\002\n\021SttWhisperService\022j\n\021W"
  "hisperTranscribe\022).sentiric.stt.v1.Whisp"
  "erTranscribeRequest\032*.sentiric.stt.v1.Wh"
  "isperTranscribeResponse\022\200\001\n\027WhisperTrans"
  "cribeStream\022/.sentiric.stt.v1.WhisperTra"
  "nscribeStreamRequest\0320.sentiric.stt.v1.W"
  "hisperTranscribeStreamResponse(\0010\001BEZCgi"
  "thub.com/sentiric/sentiric-contracts/gen"
  "/go/sentiric/stt/v1;sttv1b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto = {
    false, false, 1193, descriptor_table_protodef_sentiric_2fstt_2fv1_2fwhisper_2eproto,
    "sentiric/stt/v1/whisper.proto",
    &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once, nullptr, 0, 4,
    schemas, file_default_instances, TableStruct_sentiric_2fstt_2fv1_2fwhisper_2eproto::offsets,
    file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto, file_level_enum_descriptors_sentiric_2fstt_2fv1_2fwhisper_2eproto,
    file_level_service_descriptors_sentiric_2fstt_2fv1_2fwhisper_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter() {
  return &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_sentiric_2fstt_2fv1_2fwhisper_2eproto(&descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto);
namespace sentiric {
namespace stt {
namespace v1 {

// ===================================================================

class WhisperTranscribeRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<WhisperTranscribeRequest>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

WhisperTranscribeRequest::WhisperTranscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sentiric.stt.v1.WhisperTranscribeRequest)
}
WhisperTranscribeRequest::WhisperTranscribeRequest(const WhisperTranscribeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhisperTranscribeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_data_){}
    , decltype(_impl_.language_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.audio_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_audio_data().empty()) {
    _this->_impl_.audio_data_.Set(from._internal_audio_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sentiric.stt.v1.WhisperTranscribeRequest)
}

inline void WhisperTranscribeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_data_){}
    , decltype(_impl_.language_){}
  };
  _impl_.audio_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WhisperTranscribeRequest::~WhisperTranscribeRequest() {
  // @@protoc_insertion_point(destructor:sentiric.stt.v1.WhisperTranscribeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhisperTranscribeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.audio_data_.Destroy();
  _impl_.language_.Destroy();
}

void WhisperTranscribeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhisperTranscribeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sentiric.stt.v1.WhisperTranscribeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.audio_data_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.language_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhisperTranscribeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes audio_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_audio_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeRequest.language"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhisperTranscribeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sentiric.stt.v1.WhisperTranscribeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes audio_data = 1;
  if (!this->_internal_audio_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_audio_data(), target);
  }

  // optional string language = 2;
  if (_internal_has_language()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeRequest.language");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_language(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sentiric.stt.v1.WhisperTranscribeRequest)
  return target;
}

size_t WhisperTranscribeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sentiric.stt.v1.WhisperTranscribeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes audio_data = 1;
  if (!this->_internal_audio_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_audio_data());
  }

  // optional string language = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhisperTranscribeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhisperTranscribeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhisperTranscribeRequest::GetClassData() const { return &_class_data_; }


void WhisperTranscribeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhisperTranscribeRequest*>(&to_msg);
  auto& from = static_cast<const WhisperTranscribeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sentiric.stt.v1.WhisperTranscribeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_audio_data().empty()) {
    _this->_internal_set_audio_data(from._internal_audio_data());
  }
  if (from._internal_has_language()) {
    _this->_internal_set_language(from._internal_language());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhisperTranscribeRequest::CopyFrom(const WhisperTranscribeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sentiric.stt.v1.WhisperTranscribeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhisperTranscribeRequest::IsInitialized() const {
  return true;
}

void WhisperTranscribeRequest::InternalSwap(WhisperTranscribeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audio_data_, lhs_arena,
      &other->_impl_.audio_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WhisperTranscribeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter, &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once,
      file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[0]);
}

// ===================================================================

class WhisperTranscribeResponse::_Internal {
 public:
};

WhisperTranscribeResponse::WhisperTranscribeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sentiric.stt.v1.WhisperTranscribeResponse)
}
WhisperTranscribeResponse::WhisperTranscribeResponse(const WhisperTranscribeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhisperTranscribeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.speaker_vec_){from._impl_.speaker_vec_}
    , decltype(_impl_.transcription_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.gender_proxy_){}
    , decltype(_impl_.emotion_proxy_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.language_probability_){}
    , decltype(_impl_.arousal_){}
    , decltype(_impl_.valence_){}
    , decltype(_impl_.pitch_mean_){}
    , decltype(_impl_.pitch_std_){}
    , decltype(_impl_.energy_mean_){}
    , decltype(_impl_.energy_std_){}
    , decltype(_impl_.spectral_centroid_){}
    , decltype(_impl_.zero_crossing_rate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transcription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transcription().empty()) {
    _this->_impl_.transcription_.Set(from._internal_transcription(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language().empty()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gender_proxy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gender_proxy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_gender_proxy().empty()) {
    _this->_impl_.gender_proxy_.Set(from._internal_gender_proxy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.emotion_proxy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.emotion_proxy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_emotion_proxy().empty()) {
    _this->_impl_.emotion_proxy_.Set(from._internal_emotion_proxy(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.duration_, &from._impl_.duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.zero_crossing_rate_) -
    reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.zero_crossing_rate_));
  // @@protoc_insertion_point(copy_constructor:sentiric.stt.v1.WhisperTranscribeResponse)
}

inline void WhisperTranscribeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.speaker_vec_){arena}
    , decltype(_impl_.transcription_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.gender_proxy_){}
    , decltype(_impl_.emotion_proxy_){}
    , decltype(_impl_.duration_){0}
    , decltype(_impl_.language_probability_){0}
    , decltype(_impl_.arousal_){0}
    , decltype(_impl_.valence_){0}
    , decltype(_impl_.pitch_mean_){0}
    , decltype(_impl_.pitch_std_){0}
    , decltype(_impl_.energy_mean_){0}
    , decltype(_impl_.energy_std_){0}
    , decltype(_impl_.spectral_centroid_){0}
    , decltype(_impl_.zero_crossing_rate_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transcription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gender_proxy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gender_proxy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.emotion_proxy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.emotion_proxy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WhisperTranscribeResponse::~WhisperTranscribeResponse() {
  // @@protoc_insertion_point(destructor:sentiric.stt.v1.WhisperTranscribeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhisperTranscribeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.speaker_vec_.~RepeatedField();
  _impl_.transcription_.Destroy();
  _impl_.language_.Destroy();
  _impl_.gender_proxy_.Destroy();
  _impl_.emotion_proxy_.Destroy();
}

void WhisperTranscribeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhisperTranscribeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sentiric.stt.v1.WhisperTranscribeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.speaker_vec_.Clear();
  _impl_.transcription_.ClearToEmpty();
  _impl_.language_.ClearToEmpty();
  _impl_.gender_proxy_.ClearToEmpty();
  _impl_.emotion_proxy_.ClearToEmpty();
  ::memset(&_impl_.duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.zero_crossing_rate_) -
      reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.zero_crossing_rate_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhisperTranscribeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transcription = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transcription();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeResponse.transcription"));
        } else
          goto handle_unusual;
        continue;
      // string language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeResponse.language"));
        } else
          goto handle_unusual;
        continue;
      // float language_probability = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.language_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // double duration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string gender_proxy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_gender_proxy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeResponse.gender_proxy"));
        } else
          goto handle_unusual;
        continue;
      // string emotion_proxy = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_emotion_proxy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeResponse.emotion_proxy"));
        } else
          goto handle_unusual;
        continue;
      // float arousal = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.arousal_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float valence = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.valence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch_mean = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.pitch_mean_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch_std = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.pitch_std_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float energy_mean = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _impl_.energy_mean_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float energy_std = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _impl_.energy_std_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float spectral_centroid = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _impl_.spectral_centroid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float zero_crossing_rate = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _impl_.zero_crossing_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float speaker_vec = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_speaker_vec(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 125) {
          _internal_add_speaker_vec(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhisperTranscribeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sentiric.stt.v1.WhisperTranscribeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transcription = 1;
  if (!this->_internal_transcription().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transcription().data(), static_cast<int>(this->_internal_transcription().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeResponse.transcription");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_transcription(), target);
  }

  // string language = 2;
  if (!this->_internal_language().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeResponse.language");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_language(), target);
  }

  // float language_probability = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_language_probability = this->_internal_language_probability();
  uint32_t raw_language_probability;
  memcpy(&raw_language_probability, &tmp_language_probability, sizeof(tmp_language_probability));
  if (raw_language_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_language_probability(), target);
  }

  // double duration = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_duration = this->_internal_duration();
  uint64_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_duration(), target);
  }

  // string gender_proxy = 5;
  if (!this->_internal_gender_proxy().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_gender_proxy().data(), static_cast<int>(this->_internal_gender_proxy().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeResponse.gender_proxy");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_gender_proxy(), target);
  }

  // string emotion_proxy = 6;
  if (!this->_internal_emotion_proxy().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_emotion_proxy().data(), static_cast<int>(this->_internal_emotion_proxy().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeResponse.emotion_proxy");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_emotion_proxy(), target);
  }

  // float arousal = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_arousal = this->_internal_arousal();
  uint32_t raw_arousal;
  memcpy(&raw_arousal, &tmp_arousal, sizeof(tmp_arousal));
  if (raw_arousal != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_arousal(), target);
  }

  // float valence = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valence = this->_internal_valence();
  uint32_t raw_valence;
  memcpy(&raw_valence, &tmp_valence, sizeof(tmp_valence));
  if (raw_valence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_valence(), target);
  }

  // float pitch_mean = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_mean = this->_internal_pitch_mean();
  uint32_t raw_pitch_mean;
  memcpy(&raw_pitch_mean, &tmp_pitch_mean, sizeof(tmp_pitch_mean));
  if (raw_pitch_mean != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_pitch_mean(), target);
  }

  // float pitch_std = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_std = this->_internal_pitch_std();
  uint32_t raw_pitch_std;
  memcpy(&raw_pitch_std, &tmp_pitch_std, sizeof(tmp_pitch_std));
  if (raw_pitch_std != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_pitch_std(), target);
  }

  // float energy_mean = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_mean = this->_internal_energy_mean();
  uint32_t raw_energy_mean;
  memcpy(&raw_energy_mean, &tmp_energy_mean, sizeof(tmp_energy_mean));
  if (raw_energy_mean != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_energy_mean(), target);
  }

  // float energy_std = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_std = this->_internal_energy_std();
  uint32_t raw_energy_std;
  memcpy(&raw_energy_std, &tmp_energy_std, sizeof(tmp_energy_std));
  if (raw_energy_std != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_energy_std(), target);
  }

  // float spectral_centroid = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spectral_centroid = this->_internal_spectral_centroid();
  uint32_t raw_spectral_centroid;
  memcpy(&raw_spectral_centroid, &tmp_spectral_centroid, sizeof(tmp_spectral_centroid));
  if (raw_spectral_centroid != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_spectral_centroid(), target);
  }

  // float zero_crossing_rate = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_zero_crossing_rate = this->_internal_zero_crossing_rate();
  uint32_t raw_zero_crossing_rate;
  memcpy(&raw_zero_crossing_rate, &tmp_zero_crossing_rate, sizeof(tmp_zero_crossing_rate));
  if (raw_zero_crossing_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_zero_crossing_rate(), target);
  }

  // repeated float speaker_vec = 15;
  if (this->_internal_speaker_vec_size() > 0) {
    target = stream->WriteFixedPacked(15, _internal_speaker_vec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sentiric.stt.v1.WhisperTranscribeResponse)
  return target;
}

size_t WhisperTranscribeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sentiric.stt.v1.WhisperTranscribeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float speaker_vec = 15;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_speaker_vec_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string transcription = 1;
  if (!this->_internal_transcription().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transcription());
  }

  // string language = 2;
  if (!this->_internal_language().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  // string gender_proxy = 5;
  if (!this->_internal_gender_proxy().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gender_proxy());
  }

  // string emotion_proxy = 6;
  if (!this->_internal_emotion_proxy().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_emotion_proxy());
  }

  // double duration = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_duration = this->_internal_duration();
  uint64_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    total_size += 1 + 8;
  }

  // float language_probability = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_language_probability = this->_internal_language_probability();
  uint32_t raw_language_probability;
  memcpy(&raw_language_probability, &tmp_language_probability, sizeof(tmp_language_probability));
  if (raw_language_probability != 0) {
    total_size += 1 + 4;
  }

  // float arousal = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_arousal = this->_internal_arousal();
  uint32_t raw_arousal;
  memcpy(&raw_arousal, &tmp_arousal, sizeof(tmp_arousal));
  if (raw_arousal != 0) {
    total_size += 1 + 4;
  }

  // float valence = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valence = this->_internal_valence();
  uint32_t raw_valence;
  memcpy(&raw_valence, &tmp_valence, sizeof(tmp_valence));
  if (raw_valence != 0) {
    total_size += 1 + 4;
  }

  // float pitch_mean = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_mean = this->_internal_pitch_mean();
  uint32_t raw_pitch_mean;
  memcpy(&raw_pitch_mean, &tmp_pitch_mean, sizeof(tmp_pitch_mean));
  if (raw_pitch_mean != 0) {
    total_size += 1 + 4;
  }

  // float pitch_std = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_std = this->_internal_pitch_std();
  uint32_t raw_pitch_std;
  memcpy(&raw_pitch_std, &tmp_pitch_std, sizeof(tmp_pitch_std));
  if (raw_pitch_std != 0) {
    total_size += 1 + 4;
  }

  // float energy_mean = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_mean = this->_internal_energy_mean();
  uint32_t raw_energy_mean;
  memcpy(&raw_energy_mean, &tmp_energy_mean, sizeof(tmp_energy_mean));
  if (raw_energy_mean != 0) {
    total_size += 1 + 4;
  }

  // float energy_std = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_std = this->_internal_energy_std();
  uint32_t raw_energy_std;
  memcpy(&raw_energy_std, &tmp_energy_std, sizeof(tmp_energy_std));
  if (raw_energy_std != 0) {
    total_size += 1 + 4;
  }

  // float spectral_centroid = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spectral_centroid = this->_internal_spectral_centroid();
  uint32_t raw_spectral_centroid;
  memcpy(&raw_spectral_centroid, &tmp_spectral_centroid, sizeof(tmp_spectral_centroid));
  if (raw_spectral_centroid != 0) {
    total_size += 1 + 4;
  }

  // float zero_crossing_rate = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_zero_crossing_rate = this->_internal_zero_crossing_rate();
  uint32_t raw_zero_crossing_rate;
  memcpy(&raw_zero_crossing_rate, &tmp_zero_crossing_rate, sizeof(tmp_zero_crossing_rate));
  if (raw_zero_crossing_rate != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhisperTranscribeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhisperTranscribeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhisperTranscribeResponse::GetClassData() const { return &_class_data_; }


void WhisperTranscribeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhisperTranscribeResponse*>(&to_msg);
  auto& from = static_cast<const WhisperTranscribeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sentiric.stt.v1.WhisperTranscribeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.speaker_vec_.MergeFrom(from._impl_.speaker_vec_);
  if (!from._internal_transcription().empty()) {
    _this->_internal_set_transcription(from._internal_transcription());
  }
  if (!from._internal_language().empty()) {
    _this->_internal_set_language(from._internal_language());
  }
  if (!from._internal_gender_proxy().empty()) {
    _this->_internal_set_gender_proxy(from._internal_gender_proxy());
  }
  if (!from._internal_emotion_proxy().empty()) {
    _this->_internal_set_emotion_proxy(from._internal_emotion_proxy());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_duration = from._internal_duration();
  uint64_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    _this->_internal_set_duration(from._internal_duration());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_language_probability = from._internal_language_probability();
  uint32_t raw_language_probability;
  memcpy(&raw_language_probability, &tmp_language_probability, sizeof(tmp_language_probability));
  if (raw_language_probability != 0) {
    _this->_internal_set_language_probability(from._internal_language_probability());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_arousal = from._internal_arousal();
  uint32_t raw_arousal;
  memcpy(&raw_arousal, &tmp_arousal, sizeof(tmp_arousal));
  if (raw_arousal != 0) {
    _this->_internal_set_arousal(from._internal_arousal());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valence = from._internal_valence();
  uint32_t raw_valence;
  memcpy(&raw_valence, &tmp_valence, sizeof(tmp_valence));
  if (raw_valence != 0) {
    _this->_internal_set_valence(from._internal_valence());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_mean = from._internal_pitch_mean();
  uint32_t raw_pitch_mean;
  memcpy(&raw_pitch_mean, &tmp_pitch_mean, sizeof(tmp_pitch_mean));
  if (raw_pitch_mean != 0) {
    _this->_internal_set_pitch_mean(from._internal_pitch_mean());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_std = from._internal_pitch_std();
  uint32_t raw_pitch_std;
  memcpy(&raw_pitch_std, &tmp_pitch_std, sizeof(tmp_pitch_std));
  if (raw_pitch_std != 0) {
    _this->_internal_set_pitch_std(from._internal_pitch_std());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_mean = from._internal_energy_mean();
  uint32_t raw_energy_mean;
  memcpy(&raw_energy_mean, &tmp_energy_mean, sizeof(tmp_energy_mean));
  if (raw_energy_mean != 0) {
    _this->_internal_set_energy_mean(from._internal_energy_mean());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_std = from._internal_energy_std();
  uint32_t raw_energy_std;
  memcpy(&raw_energy_std, &tmp_energy_std, sizeof(tmp_energy_std));
  if (raw_energy_std != 0) {
    _this->_internal_set_energy_std(from._internal_energy_std());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spectral_centroid = from._internal_spectral_centroid();
  uint32_t raw_spectral_centroid;
  memcpy(&raw_spectral_centroid, &tmp_spectral_centroid, sizeof(tmp_spectral_centroid));
  if (raw_spectral_centroid != 0) {
    _this->_internal_set_spectral_centroid(from._internal_spectral_centroid());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_zero_crossing_rate = from._internal_zero_crossing_rate();
  uint32_t raw_zero_crossing_rate;
  memcpy(&raw_zero_crossing_rate, &tmp_zero_crossing_rate, sizeof(tmp_zero_crossing_rate));
  if (raw_zero_crossing_rate != 0) {
    _this->_internal_set_zero_crossing_rate(from._internal_zero_crossing_rate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhisperTranscribeResponse::CopyFrom(const WhisperTranscribeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sentiric.stt.v1.WhisperTranscribeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhisperTranscribeResponse::IsInitialized() const {
  return true;
}

void WhisperTranscribeResponse::InternalSwap(WhisperTranscribeResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.speaker_vec_.InternalSwap(&other->_impl_.speaker_vec_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transcription_, lhs_arena,
      &other->_impl_.transcription_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gender_proxy_, lhs_arena,
      &other->_impl_.gender_proxy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.emotion_proxy_, lhs_arena,
      &other->_impl_.emotion_proxy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WhisperTranscribeResponse, _impl_.zero_crossing_rate_)
      + sizeof(WhisperTranscribeResponse::_impl_.zero_crossing_rate_)
      - PROTOBUF_FIELD_OFFSET(WhisperTranscribeResponse, _impl_.duration_)>(
          reinterpret_cast<char*>(&_impl_.duration_),
          reinterpret_cast<char*>(&other->_impl_.duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WhisperTranscribeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter, &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once,
      file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[1]);
}

// ===================================================================

class WhisperTranscribeStreamRequest::_Internal {
 public:
};

WhisperTranscribeStreamRequest::WhisperTranscribeStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sentiric.stt.v1.WhisperTranscribeStreamRequest)
}
WhisperTranscribeStreamRequest::WhisperTranscribeStreamRequest(const WhisperTranscribeStreamRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhisperTranscribeStreamRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.audio_chunk_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.audio_chunk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_chunk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_audio_chunk().empty()) {
    _this->_impl_.audio_chunk_.Set(from._internal_audio_chunk(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sentiric.stt.v1.WhisperTranscribeStreamRequest)
}

inline void WhisperTranscribeStreamRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.audio_chunk_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.audio_chunk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_chunk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WhisperTranscribeStreamRequest::~WhisperTranscribeStreamRequest() {
  // @@protoc_insertion_point(destructor:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhisperTranscribeStreamRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.audio_chunk_.Destroy();
}

void WhisperTranscribeStreamRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhisperTranscribeStreamRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.audio_chunk_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhisperTranscribeStreamRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes audio_chunk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_audio_chunk();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhisperTranscribeStreamRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes audio_chunk = 1;
  if (!this->_internal_audio_chunk().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_audio_chunk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  return target;
}

size_t WhisperTranscribeStreamRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes audio_chunk = 1;
  if (!this->_internal_audio_chunk().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_audio_chunk());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhisperTranscribeStreamRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhisperTranscribeStreamRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhisperTranscribeStreamRequest::GetClassData() const { return &_class_data_; }


void WhisperTranscribeStreamRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhisperTranscribeStreamRequest*>(&to_msg);
  auto& from = static_cast<const WhisperTranscribeStreamRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_audio_chunk().empty()) {
    _this->_internal_set_audio_chunk(from._internal_audio_chunk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhisperTranscribeStreamRequest::CopyFrom(const WhisperTranscribeStreamRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sentiric.stt.v1.WhisperTranscribeStreamRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhisperTranscribeStreamRequest::IsInitialized() const {
  return true;
}

void WhisperTranscribeStreamRequest::InternalSwap(WhisperTranscribeStreamRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audio_chunk_, lhs_arena,
      &other->_impl_.audio_chunk_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WhisperTranscribeStreamRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter, &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once,
      file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[2]);
}

// ===================================================================

class WhisperTranscribeStreamResponse::_Internal {
 public:
};

WhisperTranscribeStreamResponse::WhisperTranscribeStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sentiric.stt.v1.WhisperTranscribeStreamResponse)
}
WhisperTranscribeStreamResponse::WhisperTranscribeStreamResponse(const WhisperTranscribeStreamResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WhisperTranscribeStreamResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.speaker_vec_){from._impl_.speaker_vec_}
    , decltype(_impl_.transcription_){}
    , decltype(_impl_.gender_proxy_){}
    , decltype(_impl_.emotion_proxy_){}
    , decltype(_impl_.is_final_){}
    , decltype(_impl_.arousal_){}
    , decltype(_impl_.valence_){}
    , decltype(_impl_.pitch_mean_){}
    , decltype(_impl_.pitch_std_){}
    , decltype(_impl_.energy_mean_){}
    , decltype(_impl_.energy_std_){}
    , decltype(_impl_.spectral_centroid_){}
    , decltype(_impl_.zero_crossing_rate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transcription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transcription().empty()) {
    _this->_impl_.transcription_.Set(from._internal_transcription(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gender_proxy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gender_proxy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_gender_proxy().empty()) {
    _this->_impl_.gender_proxy_.Set(from._internal_gender_proxy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.emotion_proxy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.emotion_proxy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_emotion_proxy().empty()) {
    _this->_impl_.emotion_proxy_.Set(from._internal_emotion_proxy(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_final_, &from._impl_.is_final_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.zero_crossing_rate_) -
    reinterpret_cast<char*>(&_impl_.is_final_)) + sizeof(_impl_.zero_crossing_rate_));
  // @@protoc_insertion_point(copy_constructor:sentiric.stt.v1.WhisperTranscribeStreamResponse)
}

inline void WhisperTranscribeStreamResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.speaker_vec_){arena}
    , decltype(_impl_.transcription_){}
    , decltype(_impl_.gender_proxy_){}
    , decltype(_impl_.emotion_proxy_){}
    , decltype(_impl_.is_final_){false}
    , decltype(_impl_.arousal_){0}
    , decltype(_impl_.valence_){0}
    , decltype(_impl_.pitch_mean_){0}
    , decltype(_impl_.pitch_std_){0}
    , decltype(_impl_.energy_mean_){0}
    , decltype(_impl_.energy_std_){0}
    , decltype(_impl_.spectral_centroid_){0}
    , decltype(_impl_.zero_crossing_rate_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transcription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gender_proxy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gender_proxy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.emotion_proxy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.emotion_proxy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WhisperTranscribeStreamResponse::~WhisperTranscribeStreamResponse() {
  // @@protoc_insertion_point(destructor:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WhisperTranscribeStreamResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.speaker_vec_.~RepeatedField();
  _impl_.transcription_.Destroy();
  _impl_.gender_proxy_.Destroy();
  _impl_.emotion_proxy_.Destroy();
}

void WhisperTranscribeStreamResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WhisperTranscribeStreamResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.speaker_vec_.Clear();
  _impl_.transcription_.ClearToEmpty();
  _impl_.gender_proxy_.ClearToEmpty();
  _impl_.emotion_proxy_.ClearToEmpty();
  ::memset(&_impl_.is_final_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.zero_crossing_rate_) -
      reinterpret_cast<char*>(&_impl_.is_final_)) + sizeof(_impl_.zero_crossing_rate_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WhisperTranscribeStreamResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transcription = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transcription();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeStreamResponse.transcription"));
        } else
          goto handle_unusual;
        continue;
      // bool is_final = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.is_final_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string gender_proxy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_gender_proxy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeStreamResponse.gender_proxy"));
        } else
          goto handle_unusual;
        continue;
      // string emotion_proxy = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_emotion_proxy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "sentiric.stt.v1.WhisperTranscribeStreamResponse.emotion_proxy"));
        } else
          goto handle_unusual;
        continue;
      // float arousal = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.arousal_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float valence = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.valence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch_mean = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.pitch_mean_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch_std = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.pitch_std_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float energy_mean = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.energy_mean_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float energy_std = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.energy_std_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float spectral_centroid = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _impl_.spectral_centroid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float zero_crossing_rate = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _impl_.zero_crossing_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float speaker_vec = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_speaker_vec(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 109) {
          _internal_add_speaker_vec(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WhisperTranscribeStreamResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transcription = 1;
  if (!this->_internal_transcription().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transcription().data(), static_cast<int>(this->_internal_transcription().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeStreamResponse.transcription");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_transcription(), target);
  }

  // bool is_final = 2;
  if (this->_internal_is_final() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_final(), target);
  }

  // string gender_proxy = 3;
  if (!this->_internal_gender_proxy().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_gender_proxy().data(), static_cast<int>(this->_internal_gender_proxy().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeStreamResponse.gender_proxy");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_gender_proxy(), target);
  }

  // string emotion_proxy = 4;
  if (!this->_internal_emotion_proxy().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_emotion_proxy().data(), static_cast<int>(this->_internal_emotion_proxy().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sentiric.stt.v1.WhisperTranscribeStreamResponse.emotion_proxy");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_emotion_proxy(), target);
  }

  // float arousal = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_arousal = this->_internal_arousal();
  uint32_t raw_arousal;
  memcpy(&raw_arousal, &tmp_arousal, sizeof(tmp_arousal));
  if (raw_arousal != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_arousal(), target);
  }

  // float valence = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valence = this->_internal_valence();
  uint32_t raw_valence;
  memcpy(&raw_valence, &tmp_valence, sizeof(tmp_valence));
  if (raw_valence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_valence(), target);
  }

  // float pitch_mean = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_mean = this->_internal_pitch_mean();
  uint32_t raw_pitch_mean;
  memcpy(&raw_pitch_mean, &tmp_pitch_mean, sizeof(tmp_pitch_mean));
  if (raw_pitch_mean != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_pitch_mean(), target);
  }

  // float pitch_std = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_std = this->_internal_pitch_std();
  uint32_t raw_pitch_std;
  memcpy(&raw_pitch_std, &tmp_pitch_std, sizeof(tmp_pitch_std));
  if (raw_pitch_std != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_pitch_std(), target);
  }

  // float energy_mean = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_mean = this->_internal_energy_mean();
  uint32_t raw_energy_mean;
  memcpy(&raw_energy_mean, &tmp_energy_mean, sizeof(tmp_energy_mean));
  if (raw_energy_mean != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_energy_mean(), target);
  }

  // float energy_std = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_std = this->_internal_energy_std();
  uint32_t raw_energy_std;
  memcpy(&raw_energy_std, &tmp_energy_std, sizeof(tmp_energy_std));
  if (raw_energy_std != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_energy_std(), target);
  }

  // float spectral_centroid = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spectral_centroid = this->_internal_spectral_centroid();
  uint32_t raw_spectral_centroid;
  memcpy(&raw_spectral_centroid, &tmp_spectral_centroid, sizeof(tmp_spectral_centroid));
  if (raw_spectral_centroid != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_spectral_centroid(), target);
  }

  // float zero_crossing_rate = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_zero_crossing_rate = this->_internal_zero_crossing_rate();
  uint32_t raw_zero_crossing_rate;
  memcpy(&raw_zero_crossing_rate, &tmp_zero_crossing_rate, sizeof(tmp_zero_crossing_rate));
  if (raw_zero_crossing_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_zero_crossing_rate(), target);
  }

  // repeated float speaker_vec = 13;
  if (this->_internal_speaker_vec_size() > 0) {
    target = stream->WriteFixedPacked(13, _internal_speaker_vec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  return target;
}

size_t WhisperTranscribeStreamResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float speaker_vec = 13;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_speaker_vec_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string transcription = 1;
  if (!this->_internal_transcription().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transcription());
  }

  // string gender_proxy = 3;
  if (!this->_internal_gender_proxy().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gender_proxy());
  }

  // string emotion_proxy = 4;
  if (!this->_internal_emotion_proxy().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_emotion_proxy());
  }

  // bool is_final = 2;
  if (this->_internal_is_final() != 0) {
    total_size += 1 + 1;
  }

  // float arousal = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_arousal = this->_internal_arousal();
  uint32_t raw_arousal;
  memcpy(&raw_arousal, &tmp_arousal, sizeof(tmp_arousal));
  if (raw_arousal != 0) {
    total_size += 1 + 4;
  }

  // float valence = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valence = this->_internal_valence();
  uint32_t raw_valence;
  memcpy(&raw_valence, &tmp_valence, sizeof(tmp_valence));
  if (raw_valence != 0) {
    total_size += 1 + 4;
  }

  // float pitch_mean = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_mean = this->_internal_pitch_mean();
  uint32_t raw_pitch_mean;
  memcpy(&raw_pitch_mean, &tmp_pitch_mean, sizeof(tmp_pitch_mean));
  if (raw_pitch_mean != 0) {
    total_size += 1 + 4;
  }

  // float pitch_std = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_std = this->_internal_pitch_std();
  uint32_t raw_pitch_std;
  memcpy(&raw_pitch_std, &tmp_pitch_std, sizeof(tmp_pitch_std));
  if (raw_pitch_std != 0) {
    total_size += 1 + 4;
  }

  // float energy_mean = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_mean = this->_internal_energy_mean();
  uint32_t raw_energy_mean;
  memcpy(&raw_energy_mean, &tmp_energy_mean, sizeof(tmp_energy_mean));
  if (raw_energy_mean != 0) {
    total_size += 1 + 4;
  }

  // float energy_std = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_std = this->_internal_energy_std();
  uint32_t raw_energy_std;
  memcpy(&raw_energy_std, &tmp_energy_std, sizeof(tmp_energy_std));
  if (raw_energy_std != 0) {
    total_size += 1 + 4;
  }

  // float spectral_centroid = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spectral_centroid = this->_internal_spectral_centroid();
  uint32_t raw_spectral_centroid;
  memcpy(&raw_spectral_centroid, &tmp_spectral_centroid, sizeof(tmp_spectral_centroid));
  if (raw_spectral_centroid != 0) {
    total_size += 1 + 4;
  }

  // float zero_crossing_rate = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_zero_crossing_rate = this->_internal_zero_crossing_rate();
  uint32_t raw_zero_crossing_rate;
  memcpy(&raw_zero_crossing_rate, &tmp_zero_crossing_rate, sizeof(tmp_zero_crossing_rate));
  if (raw_zero_crossing_rate != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WhisperTranscribeStreamResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WhisperTranscribeStreamResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WhisperTranscribeStreamResponse::GetClassData() const { return &_class_data_; }


void WhisperTranscribeStreamResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WhisperTranscribeStreamResponse*>(&to_msg);
  auto& from = static_cast<const WhisperTranscribeStreamResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.speaker_vec_.MergeFrom(from._impl_.speaker_vec_);
  if (!from._internal_transcription().empty()) {
    _this->_internal_set_transcription(from._internal_transcription());
  }
  if (!from._internal_gender_proxy().empty()) {
    _this->_internal_set_gender_proxy(from._internal_gender_proxy());
  }
  if (!from._internal_emotion_proxy().empty()) {
    _this->_internal_set_emotion_proxy(from._internal_emotion_proxy());
  }
  if (from._internal_is_final() != 0) {
    _this->_internal_set_is_final(from._internal_is_final());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_arousal = from._internal_arousal();
  uint32_t raw_arousal;
  memcpy(&raw_arousal, &tmp_arousal, sizeof(tmp_arousal));
  if (raw_arousal != 0) {
    _this->_internal_set_arousal(from._internal_arousal());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_valence = from._internal_valence();
  uint32_t raw_valence;
  memcpy(&raw_valence, &tmp_valence, sizeof(tmp_valence));
  if (raw_valence != 0) {
    _this->_internal_set_valence(from._internal_valence());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_mean = from._internal_pitch_mean();
  uint32_t raw_pitch_mean;
  memcpy(&raw_pitch_mean, &tmp_pitch_mean, sizeof(tmp_pitch_mean));
  if (raw_pitch_mean != 0) {
    _this->_internal_set_pitch_mean(from._internal_pitch_mean());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch_std = from._internal_pitch_std();
  uint32_t raw_pitch_std;
  memcpy(&raw_pitch_std, &tmp_pitch_std, sizeof(tmp_pitch_std));
  if (raw_pitch_std != 0) {
    _this->_internal_set_pitch_std(from._internal_pitch_std());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_mean = from._internal_energy_mean();
  uint32_t raw_energy_mean;
  memcpy(&raw_energy_mean, &tmp_energy_mean, sizeof(tmp_energy_mean));
  if (raw_energy_mean != 0) {
    _this->_internal_set_energy_mean(from._internal_energy_mean());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_energy_std = from._internal_energy_std();
  uint32_t raw_energy_std;
  memcpy(&raw_energy_std, &tmp_energy_std, sizeof(tmp_energy_std));
  if (raw_energy_std != 0) {
    _this->_internal_set_energy_std(from._internal_energy_std());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_spectral_centroid = from._internal_spectral_centroid();
  uint32_t raw_spectral_centroid;
  memcpy(&raw_spectral_centroid, &tmp_spectral_centroid, sizeof(tmp_spectral_centroid));
  if (raw_spectral_centroid != 0) {
    _this->_internal_set_spectral_centroid(from._internal_spectral_centroid());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_zero_crossing_rate = from._internal_zero_crossing_rate();
  uint32_t raw_zero_crossing_rate;
  memcpy(&raw_zero_crossing_rate, &tmp_zero_crossing_rate, sizeof(tmp_zero_crossing_rate));
  if (raw_zero_crossing_rate != 0) {
    _this->_internal_set_zero_crossing_rate(from._internal_zero_crossing_rate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WhisperTranscribeStreamResponse::CopyFrom(const WhisperTranscribeStreamResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sentiric.stt.v1.WhisperTranscribeStreamResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WhisperTranscribeStreamResponse::IsInitialized() const {
  return true;
}

void WhisperTranscribeStreamResponse::InternalSwap(WhisperTranscribeStreamResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.speaker_vec_.InternalSwap(&other->_impl_.speaker_vec_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transcription_, lhs_arena,
      &other->_impl_.transcription_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gender_proxy_, lhs_arena,
      &other->_impl_.gender_proxy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.emotion_proxy_, lhs_arena,
      &other->_impl_.emotion_proxy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WhisperTranscribeStreamResponse, _impl_.zero_crossing_rate_)
      + sizeof(WhisperTranscribeStreamResponse::_impl_.zero_crossing_rate_)
      - PROTOBUF_FIELD_OFFSET(WhisperTranscribeStreamResponse, _impl_.is_final_)>(
          reinterpret_cast<char*>(&_impl_.is_final_),
          reinterpret_cast<char*>(&other->_impl_.is_final_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WhisperTranscribeStreamResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_getter, &descriptor_table_sentiric_2fstt_2fv1_2fwhisper_2eproto_once,
      file_level_metadata_sentiric_2fstt_2fv1_2fwhisper_2eproto[3]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace stt
}  // namespace sentiric
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sentiric::stt::v1::WhisperTranscribeRequest*
Arena::CreateMaybeMessage< ::sentiric::stt::v1::WhisperTranscribeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sentiric::stt::v1::WhisperTranscribeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sentiric::stt::v1::WhisperTranscribeResponse*
Arena::CreateMaybeMessage< ::sentiric::stt::v1::WhisperTranscribeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sentiric::stt::v1::WhisperTranscribeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sentiric::stt::v1::WhisperTranscribeStreamRequest*
Arena::CreateMaybeMessage< ::sentiric::stt::v1::WhisperTranscribeStreamRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sentiric::stt::v1::WhisperTranscribeStreamRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sentiric::stt::v1::WhisperTranscribeStreamResponse*
Arena::CreateMaybeMessage< ::sentiric::stt::v1::WhisperTranscribeStreamResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sentiric::stt::v1::WhisperTranscribeStreamResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
