// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sentiric/tts/v1/gateway.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sentiric_2ftts_2fv1_2fgateway_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sentiric_2ftts_2fv1_2fgateway_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sentiric_2ftts_2fv1_2fgateway_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sentiric_2ftts_2fv1_2fgateway_2eproto;
namespace sentiric {
namespace tts {
namespace v1 {
class AudioConfig;
struct AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class ListVoicesRequest;
struct ListVoicesRequestDefaultTypeInternal;
extern ListVoicesRequestDefaultTypeInternal _ListVoicesRequest_default_instance_;
class ListVoicesResponse;
struct ListVoicesResponseDefaultTypeInternal;
extern ListVoicesResponseDefaultTypeInternal _ListVoicesResponse_default_instance_;
class ProsodyConfig;
struct ProsodyConfigDefaultTypeInternal;
extern ProsodyConfigDefaultTypeInternal _ProsodyConfig_default_instance_;
class SynthesizeRequest;
struct SynthesizeRequestDefaultTypeInternal;
extern SynthesizeRequestDefaultTypeInternal _SynthesizeRequest_default_instance_;
class SynthesizeResponse;
struct SynthesizeResponseDefaultTypeInternal;
extern SynthesizeResponseDefaultTypeInternal _SynthesizeResponse_default_instance_;
class SynthesizeStreamRequest;
struct SynthesizeStreamRequestDefaultTypeInternal;
extern SynthesizeStreamRequestDefaultTypeInternal _SynthesizeStreamRequest_default_instance_;
class SynthesizeStreamResponse;
struct SynthesizeStreamResponseDefaultTypeInternal;
extern SynthesizeStreamResponseDefaultTypeInternal _SynthesizeStreamResponse_default_instance_;
class TuningParams;
struct TuningParamsDefaultTypeInternal;
extern TuningParamsDefaultTypeInternal _TuningParams_default_instance_;
class VoiceInfo;
struct VoiceInfoDefaultTypeInternal;
extern VoiceInfoDefaultTypeInternal _VoiceInfo_default_instance_;
}  // namespace v1
}  // namespace tts
}  // namespace sentiric
PROTOBUF_NAMESPACE_OPEN
template<> ::sentiric::tts::v1::AudioConfig* Arena::CreateMaybeMessage<::sentiric::tts::v1::AudioConfig>(Arena*);
template<> ::sentiric::tts::v1::ListVoicesRequest* Arena::CreateMaybeMessage<::sentiric::tts::v1::ListVoicesRequest>(Arena*);
template<> ::sentiric::tts::v1::ListVoicesResponse* Arena::CreateMaybeMessage<::sentiric::tts::v1::ListVoicesResponse>(Arena*);
template<> ::sentiric::tts::v1::ProsodyConfig* Arena::CreateMaybeMessage<::sentiric::tts::v1::ProsodyConfig>(Arena*);
template<> ::sentiric::tts::v1::SynthesizeRequest* Arena::CreateMaybeMessage<::sentiric::tts::v1::SynthesizeRequest>(Arena*);
template<> ::sentiric::tts::v1::SynthesizeResponse* Arena::CreateMaybeMessage<::sentiric::tts::v1::SynthesizeResponse>(Arena*);
template<> ::sentiric::tts::v1::SynthesizeStreamRequest* Arena::CreateMaybeMessage<::sentiric::tts::v1::SynthesizeStreamRequest>(Arena*);
template<> ::sentiric::tts::v1::SynthesizeStreamResponse* Arena::CreateMaybeMessage<::sentiric::tts::v1::SynthesizeStreamResponse>(Arena*);
template<> ::sentiric::tts::v1::TuningParams* Arena::CreateMaybeMessage<::sentiric::tts::v1::TuningParams>(Arena*);
template<> ::sentiric::tts::v1::VoiceInfo* Arena::CreateMaybeMessage<::sentiric::tts::v1::VoiceInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sentiric {
namespace tts {
namespace v1 {

enum TextType : int {
  TEXT_TYPE_UNSPECIFIED = 0,
  TEXT_TYPE_TEXT = 1,
  TEXT_TYPE_SSML = 2,
  TextType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TextType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TextType_IsValid(int value);
constexpr TextType TextType_MIN = TEXT_TYPE_UNSPECIFIED;
constexpr TextType TextType_MAX = TEXT_TYPE_SSML;
constexpr int TextType_ARRAYSIZE = TextType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextType_descriptor();
template<typename T>
inline const std::string& TextType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextType_descriptor(), enum_t_value);
}
inline bool TextType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextType>(
    TextType_descriptor(), name, value);
}
enum AudioFormat : int {
  AUDIO_FORMAT_UNSPECIFIED = 0,
  AUDIO_FORMAT_PCM_S16LE = 1,
  AUDIO_FORMAT_WAV = 2,
  AUDIO_FORMAT_MP3 = 3,
  AUDIO_FORMAT_OGG_OPUS = 4,
  AUDIO_FORMAT_MULAW = 5,
  AudioFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioFormat_IsValid(int value);
constexpr AudioFormat AudioFormat_MIN = AUDIO_FORMAT_UNSPECIFIED;
constexpr AudioFormat AudioFormat_MAX = AUDIO_FORMAT_MULAW;
constexpr int AudioFormat_ARRAYSIZE = AudioFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioFormat_descriptor();
template<typename T>
inline const std::string& AudioFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioFormat_descriptor(), enum_t_value);
}
inline bool AudioFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioFormat>(
    AudioFormat_descriptor(), name, value);
}
// ===================================================================

class SynthesizeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.SynthesizeRequest) */ {
 public:
  inline SynthesizeRequest() : SynthesizeRequest(nullptr) {}
  ~SynthesizeRequest() override;
  explicit PROTOBUF_CONSTEXPR SynthesizeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesizeRequest(const SynthesizeRequest& from);
  SynthesizeRequest(SynthesizeRequest&& from) noexcept
    : SynthesizeRequest() {
    *this = ::std::move(from);
  }

  inline SynthesizeRequest& operator=(const SynthesizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeRequest& operator=(SynthesizeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeRequest* internal_default_instance() {
    return reinterpret_cast<const SynthesizeRequest*>(
               &_SynthesizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SynthesizeRequest& a, SynthesizeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesizeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesizeRequest& from) {
    SynthesizeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.SynthesizeRequest";
  }
  protected:
  explicit SynthesizeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kVoiceIdFieldNumber = 3,
    kPreferredProviderFieldNumber = 5,
    kCloningAudioDataFieldNumber = 7,
    kAudioConfigFieldNumber = 4,
    kTuningFieldNumber = 6,
    kTextTypeFieldNumber = 2,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string voice_id = 3;
  void clear_voice_id();
  const std::string& voice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voice_id();
  PROTOBUF_NODISCARD std::string* release_voice_id();
  void set_allocated_voice_id(std::string* voice_id);
  private:
  const std::string& _internal_voice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice_id(const std::string& value);
  std::string* _internal_mutable_voice_id();
  public:

  // string preferred_provider = 5;
  void clear_preferred_provider();
  const std::string& preferred_provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preferred_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preferred_provider();
  PROTOBUF_NODISCARD std::string* release_preferred_provider();
  void set_allocated_preferred_provider(std::string* preferred_provider);
  private:
  const std::string& _internal_preferred_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preferred_provider(const std::string& value);
  std::string* _internal_mutable_preferred_provider();
  public:

  // optional bytes cloning_audio_data = 7;
  bool has_cloning_audio_data() const;
  private:
  bool _internal_has_cloning_audio_data() const;
  public:
  void clear_cloning_audio_data();
  const std::string& cloning_audio_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloning_audio_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloning_audio_data();
  PROTOBUF_NODISCARD std::string* release_cloning_audio_data();
  void set_allocated_cloning_audio_data(std::string* cloning_audio_data);
  private:
  const std::string& _internal_cloning_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloning_audio_data(const std::string& value);
  std::string* _internal_mutable_cloning_audio_data();
  public:

  // .sentiric.tts.v1.AudioConfig audio_config = 4;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::sentiric::tts::v1::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::sentiric::tts::v1::AudioConfig* release_audio_config();
  ::sentiric::tts::v1::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::sentiric::tts::v1::AudioConfig* audio_config);
  private:
  const ::sentiric::tts::v1::AudioConfig& _internal_audio_config() const;
  ::sentiric::tts::v1::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::sentiric::tts::v1::AudioConfig* audio_config);
  ::sentiric::tts::v1::AudioConfig* unsafe_arena_release_audio_config();

  // optional .sentiric.tts.v1.TuningParams tuning = 6;
  bool has_tuning() const;
  private:
  bool _internal_has_tuning() const;
  public:
  void clear_tuning();
  const ::sentiric::tts::v1::TuningParams& tuning() const;
  PROTOBUF_NODISCARD ::sentiric::tts::v1::TuningParams* release_tuning();
  ::sentiric::tts::v1::TuningParams* mutable_tuning();
  void set_allocated_tuning(::sentiric::tts::v1::TuningParams* tuning);
  private:
  const ::sentiric::tts::v1::TuningParams& _internal_tuning() const;
  ::sentiric::tts::v1::TuningParams* _internal_mutable_tuning();
  public:
  void unsafe_arena_set_allocated_tuning(
      ::sentiric::tts::v1::TuningParams* tuning);
  ::sentiric::tts::v1::TuningParams* unsafe_arena_release_tuning();

  // .sentiric.tts.v1.TextType text_type = 2;
  void clear_text_type();
  ::sentiric::tts::v1::TextType text_type() const;
  void set_text_type(::sentiric::tts::v1::TextType value);
  private:
  ::sentiric::tts::v1::TextType _internal_text_type() const;
  void _internal_set_text_type(::sentiric::tts::v1::TextType value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.SynthesizeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voice_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preferred_provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloning_audio_data_;
    ::sentiric::tts::v1::AudioConfig* audio_config_;
    ::sentiric::tts::v1::TuningParams* tuning_;
    int text_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class SynthesizeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.SynthesizeResponse) */ {
 public:
  inline SynthesizeResponse() : SynthesizeResponse(nullptr) {}
  ~SynthesizeResponse() override;
  explicit PROTOBUF_CONSTEXPR SynthesizeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesizeResponse(const SynthesizeResponse& from);
  SynthesizeResponse(SynthesizeResponse&& from) noexcept
    : SynthesizeResponse() {
    *this = ::std::move(from);
  }

  inline SynthesizeResponse& operator=(const SynthesizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeResponse& operator=(SynthesizeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeResponse* internal_default_instance() {
    return reinterpret_cast<const SynthesizeResponse*>(
               &_SynthesizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SynthesizeResponse& a, SynthesizeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesizeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesizeResponse& from) {
    SynthesizeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.SynthesizeResponse";
  }
  protected:
  explicit SynthesizeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioContentFieldNumber = 1,
    kContentTypeFieldNumber = 2,
    kProviderUsedFieldNumber = 3,
  };
  // bytes audio_content = 1;
  void clear_audio_content();
  const std::string& audio_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_content();
  PROTOBUF_NODISCARD std::string* release_audio_content();
  void set_allocated_audio_content(std::string* audio_content);
  private:
  const std::string& _internal_audio_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_content(const std::string& value);
  std::string* _internal_mutable_audio_content();
  public:

  // string content_type = 2;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // string provider_used = 3;
  void clear_provider_used();
  const std::string& provider_used() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider_used(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider_used();
  PROTOBUF_NODISCARD std::string* release_provider_used();
  void set_allocated_provider_used(std::string* provider_used);
  private:
  const std::string& _internal_provider_used() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider_used(const std::string& value);
  std::string* _internal_mutable_provider_used();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.SynthesizeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_used_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class SynthesizeStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.SynthesizeStreamRequest) */ {
 public:
  inline SynthesizeStreamRequest() : SynthesizeStreamRequest(nullptr) {}
  ~SynthesizeStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR SynthesizeStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesizeStreamRequest(const SynthesizeStreamRequest& from);
  SynthesizeStreamRequest(SynthesizeStreamRequest&& from) noexcept
    : SynthesizeStreamRequest() {
    *this = ::std::move(from);
  }

  inline SynthesizeStreamRequest& operator=(const SynthesizeStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeStreamRequest& operator=(SynthesizeStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeStreamRequest* internal_default_instance() {
    return reinterpret_cast<const SynthesizeStreamRequest*>(
               &_SynthesizeStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SynthesizeStreamRequest& a, SynthesizeStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesizeStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesizeStreamRequest& from) {
    SynthesizeStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.SynthesizeStreamRequest";
  }
  protected:
  explicit SynthesizeStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kVoiceIdFieldNumber = 3,
    kPreferredProviderFieldNumber = 5,
    kCloningAudioDataFieldNumber = 7,
    kAudioConfigFieldNumber = 4,
    kTuningFieldNumber = 6,
    kTextTypeFieldNumber = 2,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string voice_id = 3;
  void clear_voice_id();
  const std::string& voice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voice_id();
  PROTOBUF_NODISCARD std::string* release_voice_id();
  void set_allocated_voice_id(std::string* voice_id);
  private:
  const std::string& _internal_voice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice_id(const std::string& value);
  std::string* _internal_mutable_voice_id();
  public:

  // string preferred_provider = 5;
  void clear_preferred_provider();
  const std::string& preferred_provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preferred_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preferred_provider();
  PROTOBUF_NODISCARD std::string* release_preferred_provider();
  void set_allocated_preferred_provider(std::string* preferred_provider);
  private:
  const std::string& _internal_preferred_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preferred_provider(const std::string& value);
  std::string* _internal_mutable_preferred_provider();
  public:

  // optional bytes cloning_audio_data = 7;
  bool has_cloning_audio_data() const;
  private:
  bool _internal_has_cloning_audio_data() const;
  public:
  void clear_cloning_audio_data();
  const std::string& cloning_audio_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloning_audio_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloning_audio_data();
  PROTOBUF_NODISCARD std::string* release_cloning_audio_data();
  void set_allocated_cloning_audio_data(std::string* cloning_audio_data);
  private:
  const std::string& _internal_cloning_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloning_audio_data(const std::string& value);
  std::string* _internal_mutable_cloning_audio_data();
  public:

  // .sentiric.tts.v1.AudioConfig audio_config = 4;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::sentiric::tts::v1::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::sentiric::tts::v1::AudioConfig* release_audio_config();
  ::sentiric::tts::v1::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::sentiric::tts::v1::AudioConfig* audio_config);
  private:
  const ::sentiric::tts::v1::AudioConfig& _internal_audio_config() const;
  ::sentiric::tts::v1::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::sentiric::tts::v1::AudioConfig* audio_config);
  ::sentiric::tts::v1::AudioConfig* unsafe_arena_release_audio_config();

  // optional .sentiric.tts.v1.TuningParams tuning = 6;
  bool has_tuning() const;
  private:
  bool _internal_has_tuning() const;
  public:
  void clear_tuning();
  const ::sentiric::tts::v1::TuningParams& tuning() const;
  PROTOBUF_NODISCARD ::sentiric::tts::v1::TuningParams* release_tuning();
  ::sentiric::tts::v1::TuningParams* mutable_tuning();
  void set_allocated_tuning(::sentiric::tts::v1::TuningParams* tuning);
  private:
  const ::sentiric::tts::v1::TuningParams& _internal_tuning() const;
  ::sentiric::tts::v1::TuningParams* _internal_mutable_tuning();
  public:
  void unsafe_arena_set_allocated_tuning(
      ::sentiric::tts::v1::TuningParams* tuning);
  ::sentiric::tts::v1::TuningParams* unsafe_arena_release_tuning();

  // .sentiric.tts.v1.TextType text_type = 2;
  void clear_text_type();
  ::sentiric::tts::v1::TextType text_type() const;
  void set_text_type(::sentiric::tts::v1::TextType value);
  private:
  ::sentiric::tts::v1::TextType _internal_text_type() const;
  void _internal_set_text_type(::sentiric::tts::v1::TextType value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.SynthesizeStreamRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voice_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preferred_provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloning_audio_data_;
    ::sentiric::tts::v1::AudioConfig* audio_config_;
    ::sentiric::tts::v1::TuningParams* tuning_;
    int text_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class SynthesizeStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.SynthesizeStreamResponse) */ {
 public:
  inline SynthesizeStreamResponse() : SynthesizeStreamResponse(nullptr) {}
  ~SynthesizeStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR SynthesizeStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesizeStreamResponse(const SynthesizeStreamResponse& from);
  SynthesizeStreamResponse(SynthesizeStreamResponse&& from) noexcept
    : SynthesizeStreamResponse() {
    *this = ::std::move(from);
  }

  inline SynthesizeStreamResponse& operator=(const SynthesizeStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeStreamResponse& operator=(SynthesizeStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeStreamResponse* internal_default_instance() {
    return reinterpret_cast<const SynthesizeStreamResponse*>(
               &_SynthesizeStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SynthesizeStreamResponse& a, SynthesizeStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesizeStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesizeStreamResponse& from) {
    SynthesizeStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.SynthesizeStreamResponse";
  }
  protected:
  explicit SynthesizeStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioContentFieldNumber = 1,
    kContentTypeFieldNumber = 2,
    kProviderUsedFieldNumber = 3,
  };
  // bytes audio_content = 1;
  void clear_audio_content();
  const std::string& audio_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_content();
  PROTOBUF_NODISCARD std::string* release_audio_content();
  void set_allocated_audio_content(std::string* audio_content);
  private:
  const std::string& _internal_audio_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_content(const std::string& value);
  std::string* _internal_mutable_audio_content();
  public:

  // string content_type = 2;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // string provider_used = 3;
  void clear_provider_used();
  const std::string& provider_used() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider_used(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider_used();
  PROTOBUF_NODISCARD std::string* release_provider_used();
  void set_allocated_provider_used(std::string* provider_used);
  private:
  const std::string& _internal_provider_used() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider_used(const std::string& value);
  std::string* _internal_mutable_provider_used();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.SynthesizeStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_used_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class ListVoicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.ListVoicesRequest) */ {
 public:
  inline ListVoicesRequest() : ListVoicesRequest(nullptr) {}
  ~ListVoicesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListVoicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListVoicesRequest(const ListVoicesRequest& from);
  ListVoicesRequest(ListVoicesRequest&& from) noexcept
    : ListVoicesRequest() {
    *this = ::std::move(from);
  }

  inline ListVoicesRequest& operator=(const ListVoicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVoicesRequest& operator=(ListVoicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVoicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVoicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListVoicesRequest*>(
               &_ListVoicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListVoicesRequest& a, ListVoicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVoicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVoicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVoicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVoicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListVoicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListVoicesRequest& from) {
    ListVoicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVoicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.ListVoicesRequest";
  }
  protected:
  explicit ListVoicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageCodeFieldNumber = 1,
  };
  // string language_code = 1;
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.ListVoicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class ListVoicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.ListVoicesResponse) */ {
 public:
  inline ListVoicesResponse() : ListVoicesResponse(nullptr) {}
  ~ListVoicesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListVoicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListVoicesResponse(const ListVoicesResponse& from);
  ListVoicesResponse(ListVoicesResponse&& from) noexcept
    : ListVoicesResponse() {
    *this = ::std::move(from);
  }

  inline ListVoicesResponse& operator=(const ListVoicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVoicesResponse& operator=(ListVoicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVoicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVoicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListVoicesResponse*>(
               &_ListVoicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListVoicesResponse& a, ListVoicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVoicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVoicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVoicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVoicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListVoicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListVoicesResponse& from) {
    ListVoicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVoicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.ListVoicesResponse";
  }
  protected:
  explicit ListVoicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoicesFieldNumber = 1,
  };
  // repeated .sentiric.tts.v1.VoiceInfo voices = 1;
  int voices_size() const;
  private:
  int _internal_voices_size() const;
  public:
  void clear_voices();
  ::sentiric::tts::v1::VoiceInfo* mutable_voices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::tts::v1::VoiceInfo >*
      mutable_voices();
  private:
  const ::sentiric::tts::v1::VoiceInfo& _internal_voices(int index) const;
  ::sentiric::tts::v1::VoiceInfo* _internal_add_voices();
  public:
  const ::sentiric::tts::v1::VoiceInfo& voices(int index) const;
  ::sentiric::tts::v1::VoiceInfo* add_voices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::tts::v1::VoiceInfo >&
      voices() const;

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.ListVoicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::tts::v1::VoiceInfo > voices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class TuningParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.TuningParams) */ {
 public:
  inline TuningParams() : TuningParams(nullptr) {}
  ~TuningParams() override;
  explicit PROTOBUF_CONSTEXPR TuningParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TuningParams(const TuningParams& from);
  TuningParams(TuningParams&& from) noexcept
    : TuningParams() {
    *this = ::std::move(from);
  }

  inline TuningParams& operator=(const TuningParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline TuningParams& operator=(TuningParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TuningParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const TuningParams* internal_default_instance() {
    return reinterpret_cast<const TuningParams*>(
               &_TuningParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TuningParams& a, TuningParams& b) {
    a.Swap(&b);
  }
  inline void Swap(TuningParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TuningParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TuningParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TuningParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TuningParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TuningParams& from) {
    TuningParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TuningParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.TuningParams";
  }
  protected:
  explicit TuningParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemperatureFieldNumber = 1,
    kTopPFieldNumber = 2,
    kTopKFieldNumber = 3,
    kRepetitionPenaltyFieldNumber = 4,
    kSpeedFieldNumber = 5,
  };
  // float temperature = 1;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // float top_p = 2;
  void clear_top_p();
  float top_p() const;
  void set_top_p(float value);
  private:
  float _internal_top_p() const;
  void _internal_set_top_p(float value);
  public:

  // int32 top_k = 3;
  void clear_top_k();
  int32_t top_k() const;
  void set_top_k(int32_t value);
  private:
  int32_t _internal_top_k() const;
  void _internal_set_top_k(int32_t value);
  public:

  // float repetition_penalty = 4;
  void clear_repetition_penalty();
  float repetition_penalty() const;
  void set_repetition_penalty(float value);
  private:
  float _internal_repetition_penalty() const;
  void _internal_set_repetition_penalty(float value);
  public:

  // float speed = 5;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.TuningParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float temperature_;
    float top_p_;
    int32_t top_k_;
    float repetition_penalty_;
    float speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class AudioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  ~AudioConfig() override;
  explicit PROTOBUF_CONSTEXPR AudioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioConfig(const AudioConfig& from);
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioConfig& from) {
    AudioConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.AudioConfig";
  }
  protected:
  explicit AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFormatFieldNumber = 1,
    kSampleRateHertzFieldNumber = 2,
    kVolumeGainDbFieldNumber = 3,
  };
  // .sentiric.tts.v1.AudioFormat audio_format = 1;
  void clear_audio_format();
  ::sentiric::tts::v1::AudioFormat audio_format() const;
  void set_audio_format(::sentiric::tts::v1::AudioFormat value);
  private:
  ::sentiric::tts::v1::AudioFormat _internal_audio_format() const;
  void _internal_set_audio_format(::sentiric::tts::v1::AudioFormat value);
  public:

  // int32 sample_rate_hertz = 2;
  void clear_sample_rate_hertz();
  int32_t sample_rate_hertz() const;
  void set_sample_rate_hertz(int32_t value);
  private:
  int32_t _internal_sample_rate_hertz() const;
  void _internal_set_sample_rate_hertz(int32_t value);
  public:

  // double volume_gain_db = 3;
  void clear_volume_gain_db();
  double volume_gain_db() const;
  void set_volume_gain_db(double value);
  private:
  double _internal_volume_gain_db() const;
  void _internal_set_volume_gain_db(double value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int audio_format_;
    int32_t sample_rate_hertz_;
    double volume_gain_db_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class ProsodyConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.ProsodyConfig) */ {
 public:
  inline ProsodyConfig() : ProsodyConfig(nullptr) {}
  ~ProsodyConfig() override;
  explicit PROTOBUF_CONSTEXPR ProsodyConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProsodyConfig(const ProsodyConfig& from);
  ProsodyConfig(ProsodyConfig&& from) noexcept
    : ProsodyConfig() {
    *this = ::std::move(from);
  }

  inline ProsodyConfig& operator=(const ProsodyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProsodyConfig& operator=(ProsodyConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProsodyConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProsodyConfig* internal_default_instance() {
    return reinterpret_cast<const ProsodyConfig*>(
               &_ProsodyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProsodyConfig& a, ProsodyConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProsodyConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProsodyConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProsodyConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProsodyConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProsodyConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProsodyConfig& from) {
    ProsodyConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProsodyConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.ProsodyConfig";
  }
  protected:
  explicit ProsodyConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmotionFieldNumber = 3,
    kRateFieldNumber = 1,
    kPitchFieldNumber = 2,
  };
  // string emotion = 3;
  void clear_emotion();
  const std::string& emotion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emotion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emotion();
  PROTOBUF_NODISCARD std::string* release_emotion();
  void set_allocated_emotion(std::string* emotion);
  private:
  const std::string& _internal_emotion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emotion(const std::string& value);
  std::string* _internal_mutable_emotion();
  public:

  // double rate = 1;
  void clear_rate();
  double rate() const;
  void set_rate(double value);
  private:
  double _internal_rate() const;
  void _internal_set_rate(double value);
  public:

  // double pitch = 2;
  void clear_pitch();
  double pitch() const;
  void set_pitch(double value);
  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.ProsodyConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emotion_;
    double rate_;
    double pitch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// -------------------------------------------------------------------

class VoiceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.tts.v1.VoiceInfo) */ {
 public:
  inline VoiceInfo() : VoiceInfo(nullptr) {}
  ~VoiceInfo() override;
  explicit PROTOBUF_CONSTEXPR VoiceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoiceInfo(const VoiceInfo& from);
  VoiceInfo(VoiceInfo&& from) noexcept
    : VoiceInfo() {
    *this = ::std::move(from);
  }

  inline VoiceInfo& operator=(const VoiceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceInfo& operator=(VoiceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoiceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoiceInfo* internal_default_instance() {
    return reinterpret_cast<const VoiceInfo*>(
               &_VoiceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VoiceInfo& a, VoiceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VoiceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoiceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoiceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoiceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoiceInfo& from) {
    VoiceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.tts.v1.VoiceInfo";
  }
  protected:
  explicit VoiceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStylesFieldNumber = 5,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLanguageFieldNumber = 3,
    kGenderFieldNumber = 4,
  };
  // repeated string styles = 5;
  int styles_size() const;
  private:
  int _internal_styles_size() const;
  public:
  void clear_styles();
  const std::string& styles(int index) const;
  std::string* mutable_styles(int index);
  void set_styles(int index, const std::string& value);
  void set_styles(int index, std::string&& value);
  void set_styles(int index, const char* value);
  void set_styles(int index, const char* value, size_t size);
  std::string* add_styles();
  void add_styles(const std::string& value);
  void add_styles(std::string&& value);
  void add_styles(const char* value);
  void add_styles(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& styles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_styles();
  private:
  const std::string& _internal_styles(int index) const;
  std::string* _internal_add_styles();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string language = 3;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string gender = 4;
  void clear_gender();
  const std::string& gender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gender();
  PROTOBUF_NODISCARD std::string* release_gender();
  void set_allocated_gender(std::string* gender);
  private:
  const std::string& _internal_gender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gender(const std::string& value);
  std::string* _internal_mutable_gender();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.tts.v1.VoiceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> styles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2ftts_2fv1_2fgateway_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SynthesizeRequest

// string text = 1;
inline void SynthesizeRequest::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& SynthesizeRequest::text() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeRequest.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeRequest::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeRequest.text)
}
inline std::string* SynthesizeRequest::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeRequest.text)
  return _s;
}
inline const std::string& SynthesizeRequest::_internal_text() const {
  return _impl_.text_.Get();
}
inline void SynthesizeRequest::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeRequest::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeRequest::release_text() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeRequest.text)
  return _impl_.text_.Release();
}
inline void SynthesizeRequest::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeRequest.text)
}

// .sentiric.tts.v1.TextType text_type = 2;
inline void SynthesizeRequest::clear_text_type() {
  _impl_.text_type_ = 0;
}
inline ::sentiric::tts::v1::TextType SynthesizeRequest::_internal_text_type() const {
  return static_cast< ::sentiric::tts::v1::TextType >(_impl_.text_type_);
}
inline ::sentiric::tts::v1::TextType SynthesizeRequest::text_type() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeRequest.text_type)
  return _internal_text_type();
}
inline void SynthesizeRequest::_internal_set_text_type(::sentiric::tts::v1::TextType value) {
  
  _impl_.text_type_ = value;
}
inline void SynthesizeRequest::set_text_type(::sentiric::tts::v1::TextType value) {
  _internal_set_text_type(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeRequest.text_type)
}

// string voice_id = 3;
inline void SynthesizeRequest::clear_voice_id() {
  _impl_.voice_id_.ClearToEmpty();
}
inline const std::string& SynthesizeRequest::voice_id() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeRequest.voice_id)
  return _internal_voice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeRequest::set_voice_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.voice_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeRequest.voice_id)
}
inline std::string* SynthesizeRequest::mutable_voice_id() {
  std::string* _s = _internal_mutable_voice_id();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeRequest.voice_id)
  return _s;
}
inline const std::string& SynthesizeRequest::_internal_voice_id() const {
  return _impl_.voice_id_.Get();
}
inline void SynthesizeRequest::_internal_set_voice_id(const std::string& value) {
  
  _impl_.voice_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeRequest::_internal_mutable_voice_id() {
  
  return _impl_.voice_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeRequest::release_voice_id() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeRequest.voice_id)
  return _impl_.voice_id_.Release();
}
inline void SynthesizeRequest::set_allocated_voice_id(std::string* voice_id) {
  if (voice_id != nullptr) {
    
  } else {
    
  }
  _impl_.voice_id_.SetAllocated(voice_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voice_id_.IsDefault()) {
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeRequest.voice_id)
}

// .sentiric.tts.v1.AudioConfig audio_config = 4;
inline bool SynthesizeRequest::_internal_has_audio_config() const {
  return this != internal_default_instance() && _impl_.audio_config_ != nullptr;
}
inline bool SynthesizeRequest::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void SynthesizeRequest::clear_audio_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_config_ != nullptr) {
    delete _impl_.audio_config_;
  }
  _impl_.audio_config_ = nullptr;
}
inline const ::sentiric::tts::v1::AudioConfig& SynthesizeRequest::_internal_audio_config() const {
  const ::sentiric::tts::v1::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::tts::v1::AudioConfig&>(
      ::sentiric::tts::v1::_AudioConfig_default_instance_);
}
inline const ::sentiric::tts::v1::AudioConfig& SynthesizeRequest::audio_config() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeRequest.audio_config)
  return _internal_audio_config();
}
inline void SynthesizeRequest::unsafe_arena_set_allocated_audio_config(
    ::sentiric::tts::v1::AudioConfig* audio_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.tts.v1.SynthesizeRequest.audio_config)
}
inline ::sentiric::tts::v1::AudioConfig* SynthesizeRequest::release_audio_config() {
  
  ::sentiric::tts::v1::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::tts::v1::AudioConfig* SynthesizeRequest::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeRequest.audio_config)
  
  ::sentiric::tts::v1::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::sentiric::tts::v1::AudioConfig* SynthesizeRequest::_internal_mutable_audio_config() {
  
  if (_impl_.audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::tts::v1::AudioConfig>(GetArenaForAllocation());
    _impl_.audio_config_ = p;
  }
  return _impl_.audio_config_;
}
inline ::sentiric::tts::v1::AudioConfig* SynthesizeRequest::mutable_audio_config() {
  ::sentiric::tts::v1::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeRequest.audio_config)
  return _msg;
}
inline void SynthesizeRequest::set_allocated_audio_config(::sentiric::tts::v1::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeRequest.audio_config)
}

// string preferred_provider = 5;
inline void SynthesizeRequest::clear_preferred_provider() {
  _impl_.preferred_provider_.ClearToEmpty();
}
inline const std::string& SynthesizeRequest::preferred_provider() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeRequest.preferred_provider)
  return _internal_preferred_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeRequest::set_preferred_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preferred_provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeRequest.preferred_provider)
}
inline std::string* SynthesizeRequest::mutable_preferred_provider() {
  std::string* _s = _internal_mutable_preferred_provider();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeRequest.preferred_provider)
  return _s;
}
inline const std::string& SynthesizeRequest::_internal_preferred_provider() const {
  return _impl_.preferred_provider_.Get();
}
inline void SynthesizeRequest::_internal_set_preferred_provider(const std::string& value) {
  
  _impl_.preferred_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeRequest::_internal_mutable_preferred_provider() {
  
  return _impl_.preferred_provider_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeRequest::release_preferred_provider() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeRequest.preferred_provider)
  return _impl_.preferred_provider_.Release();
}
inline void SynthesizeRequest::set_allocated_preferred_provider(std::string* preferred_provider) {
  if (preferred_provider != nullptr) {
    
  } else {
    
  }
  _impl_.preferred_provider_.SetAllocated(preferred_provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preferred_provider_.IsDefault()) {
    _impl_.preferred_provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeRequest.preferred_provider)
}

// optional .sentiric.tts.v1.TuningParams tuning = 6;
inline bool SynthesizeRequest::_internal_has_tuning() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tuning_ != nullptr);
  return value;
}
inline bool SynthesizeRequest::has_tuning() const {
  return _internal_has_tuning();
}
inline void SynthesizeRequest::clear_tuning() {
  if (_impl_.tuning_ != nullptr) _impl_.tuning_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sentiric::tts::v1::TuningParams& SynthesizeRequest::_internal_tuning() const {
  const ::sentiric::tts::v1::TuningParams* p = _impl_.tuning_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::tts::v1::TuningParams&>(
      ::sentiric::tts::v1::_TuningParams_default_instance_);
}
inline const ::sentiric::tts::v1::TuningParams& SynthesizeRequest::tuning() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeRequest.tuning)
  return _internal_tuning();
}
inline void SynthesizeRequest::unsafe_arena_set_allocated_tuning(
    ::sentiric::tts::v1::TuningParams* tuning) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuning_);
  }
  _impl_.tuning_ = tuning;
  if (tuning) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.tts.v1.SynthesizeRequest.tuning)
}
inline ::sentiric::tts::v1::TuningParams* SynthesizeRequest::release_tuning() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sentiric::tts::v1::TuningParams* temp = _impl_.tuning_;
  _impl_.tuning_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::tts::v1::TuningParams* SynthesizeRequest::unsafe_arena_release_tuning() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeRequest.tuning)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sentiric::tts::v1::TuningParams* temp = _impl_.tuning_;
  _impl_.tuning_ = nullptr;
  return temp;
}
inline ::sentiric::tts::v1::TuningParams* SynthesizeRequest::_internal_mutable_tuning() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tuning_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::tts::v1::TuningParams>(GetArenaForAllocation());
    _impl_.tuning_ = p;
  }
  return _impl_.tuning_;
}
inline ::sentiric::tts::v1::TuningParams* SynthesizeRequest::mutable_tuning() {
  ::sentiric::tts::v1::TuningParams* _msg = _internal_mutable_tuning();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeRequest.tuning)
  return _msg;
}
inline void SynthesizeRequest::set_allocated_tuning(::sentiric::tts::v1::TuningParams* tuning) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuning_;
  }
  if (tuning) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuning);
    if (message_arena != submessage_arena) {
      tuning = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuning, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tuning_ = tuning;
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeRequest.tuning)
}

// optional bytes cloning_audio_data = 7;
inline bool SynthesizeRequest::_internal_has_cloning_audio_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SynthesizeRequest::has_cloning_audio_data() const {
  return _internal_has_cloning_audio_data();
}
inline void SynthesizeRequest::clear_cloning_audio_data() {
  _impl_.cloning_audio_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SynthesizeRequest::cloning_audio_data() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeRequest.cloning_audio_data)
  return _internal_cloning_audio_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeRequest::set_cloning_audio_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cloning_audio_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeRequest.cloning_audio_data)
}
inline std::string* SynthesizeRequest::mutable_cloning_audio_data() {
  std::string* _s = _internal_mutable_cloning_audio_data();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeRequest.cloning_audio_data)
  return _s;
}
inline const std::string& SynthesizeRequest::_internal_cloning_audio_data() const {
  return _impl_.cloning_audio_data_.Get();
}
inline void SynthesizeRequest::_internal_set_cloning_audio_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cloning_audio_data_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeRequest::_internal_mutable_cloning_audio_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cloning_audio_data_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeRequest::release_cloning_audio_data() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeRequest.cloning_audio_data)
  if (!_internal_has_cloning_audio_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cloning_audio_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloning_audio_data_.IsDefault()) {
    _impl_.cloning_audio_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SynthesizeRequest::set_allocated_cloning_audio_data(std::string* cloning_audio_data) {
  if (cloning_audio_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cloning_audio_data_.SetAllocated(cloning_audio_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloning_audio_data_.IsDefault()) {
    _impl_.cloning_audio_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeRequest.cloning_audio_data)
}

// -------------------------------------------------------------------

// SynthesizeResponse

// bytes audio_content = 1;
inline void SynthesizeResponse::clear_audio_content() {
  _impl_.audio_content_.ClearToEmpty();
}
inline const std::string& SynthesizeResponse::audio_content() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeResponse.audio_content)
  return _internal_audio_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeResponse::set_audio_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeResponse.audio_content)
}
inline std::string* SynthesizeResponse::mutable_audio_content() {
  std::string* _s = _internal_mutable_audio_content();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeResponse.audio_content)
  return _s;
}
inline const std::string& SynthesizeResponse::_internal_audio_content() const {
  return _impl_.audio_content_.Get();
}
inline void SynthesizeResponse::_internal_set_audio_content(const std::string& value) {
  
  _impl_.audio_content_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeResponse::_internal_mutable_audio_content() {
  
  return _impl_.audio_content_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeResponse::release_audio_content() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeResponse.audio_content)
  return _impl_.audio_content_.Release();
}
inline void SynthesizeResponse::set_allocated_audio_content(std::string* audio_content) {
  if (audio_content != nullptr) {
    
  } else {
    
  }
  _impl_.audio_content_.SetAllocated(audio_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_content_.IsDefault()) {
    _impl_.audio_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeResponse.audio_content)
}

// string content_type = 2;
inline void SynthesizeResponse::clear_content_type() {
  _impl_.content_type_.ClearToEmpty();
}
inline const std::string& SynthesizeResponse::content_type() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeResponse.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeResponse::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeResponse.content_type)
}
inline std::string* SynthesizeResponse::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeResponse.content_type)
  return _s;
}
inline const std::string& SynthesizeResponse::_internal_content_type() const {
  return _impl_.content_type_.Get();
}
inline void SynthesizeResponse::_internal_set_content_type(const std::string& value) {
  
  _impl_.content_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeResponse::_internal_mutable_content_type() {
  
  return _impl_.content_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeResponse::release_content_type() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeResponse.content_type)
  return _impl_.content_type_.Release();
}
inline void SynthesizeResponse::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  _impl_.content_type_.SetAllocated(content_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_type_.IsDefault()) {
    _impl_.content_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeResponse.content_type)
}

// string provider_used = 3;
inline void SynthesizeResponse::clear_provider_used() {
  _impl_.provider_used_.ClearToEmpty();
}
inline const std::string& SynthesizeResponse::provider_used() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeResponse.provider_used)
  return _internal_provider_used();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeResponse::set_provider_used(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_used_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeResponse.provider_used)
}
inline std::string* SynthesizeResponse::mutable_provider_used() {
  std::string* _s = _internal_mutable_provider_used();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeResponse.provider_used)
  return _s;
}
inline const std::string& SynthesizeResponse::_internal_provider_used() const {
  return _impl_.provider_used_.Get();
}
inline void SynthesizeResponse::_internal_set_provider_used(const std::string& value) {
  
  _impl_.provider_used_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeResponse::_internal_mutable_provider_used() {
  
  return _impl_.provider_used_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeResponse::release_provider_used() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeResponse.provider_used)
  return _impl_.provider_used_.Release();
}
inline void SynthesizeResponse::set_allocated_provider_used(std::string* provider_used) {
  if (provider_used != nullptr) {
    
  } else {
    
  }
  _impl_.provider_used_.SetAllocated(provider_used, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_used_.IsDefault()) {
    _impl_.provider_used_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeResponse.provider_used)
}

// -------------------------------------------------------------------

// SynthesizeStreamRequest

// string text = 1;
inline void SynthesizeStreamRequest::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& SynthesizeStreamRequest::text() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamRequest.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeStreamRequest::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeStreamRequest.text)
}
inline std::string* SynthesizeStreamRequest::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamRequest.text)
  return _s;
}
inline const std::string& SynthesizeStreamRequest::_internal_text() const {
  return _impl_.text_.Get();
}
inline void SynthesizeStreamRequest::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeStreamRequest::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeStreamRequest::release_text() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamRequest.text)
  return _impl_.text_.Release();
}
inline void SynthesizeStreamRequest::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamRequest.text)
}

// .sentiric.tts.v1.TextType text_type = 2;
inline void SynthesizeStreamRequest::clear_text_type() {
  _impl_.text_type_ = 0;
}
inline ::sentiric::tts::v1::TextType SynthesizeStreamRequest::_internal_text_type() const {
  return static_cast< ::sentiric::tts::v1::TextType >(_impl_.text_type_);
}
inline ::sentiric::tts::v1::TextType SynthesizeStreamRequest::text_type() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamRequest.text_type)
  return _internal_text_type();
}
inline void SynthesizeStreamRequest::_internal_set_text_type(::sentiric::tts::v1::TextType value) {
  
  _impl_.text_type_ = value;
}
inline void SynthesizeStreamRequest::set_text_type(::sentiric::tts::v1::TextType value) {
  _internal_set_text_type(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeStreamRequest.text_type)
}

// string voice_id = 3;
inline void SynthesizeStreamRequest::clear_voice_id() {
  _impl_.voice_id_.ClearToEmpty();
}
inline const std::string& SynthesizeStreamRequest::voice_id() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamRequest.voice_id)
  return _internal_voice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeStreamRequest::set_voice_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.voice_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeStreamRequest.voice_id)
}
inline std::string* SynthesizeStreamRequest::mutable_voice_id() {
  std::string* _s = _internal_mutable_voice_id();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamRequest.voice_id)
  return _s;
}
inline const std::string& SynthesizeStreamRequest::_internal_voice_id() const {
  return _impl_.voice_id_.Get();
}
inline void SynthesizeStreamRequest::_internal_set_voice_id(const std::string& value) {
  
  _impl_.voice_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeStreamRequest::_internal_mutable_voice_id() {
  
  return _impl_.voice_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeStreamRequest::release_voice_id() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamRequest.voice_id)
  return _impl_.voice_id_.Release();
}
inline void SynthesizeStreamRequest::set_allocated_voice_id(std::string* voice_id) {
  if (voice_id != nullptr) {
    
  } else {
    
  }
  _impl_.voice_id_.SetAllocated(voice_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voice_id_.IsDefault()) {
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamRequest.voice_id)
}

// .sentiric.tts.v1.AudioConfig audio_config = 4;
inline bool SynthesizeStreamRequest::_internal_has_audio_config() const {
  return this != internal_default_instance() && _impl_.audio_config_ != nullptr;
}
inline bool SynthesizeStreamRequest::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void SynthesizeStreamRequest::clear_audio_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_config_ != nullptr) {
    delete _impl_.audio_config_;
  }
  _impl_.audio_config_ = nullptr;
}
inline const ::sentiric::tts::v1::AudioConfig& SynthesizeStreamRequest::_internal_audio_config() const {
  const ::sentiric::tts::v1::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::tts::v1::AudioConfig&>(
      ::sentiric::tts::v1::_AudioConfig_default_instance_);
}
inline const ::sentiric::tts::v1::AudioConfig& SynthesizeStreamRequest::audio_config() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamRequest.audio_config)
  return _internal_audio_config();
}
inline void SynthesizeStreamRequest::unsafe_arena_set_allocated_audio_config(
    ::sentiric::tts::v1::AudioConfig* audio_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.tts.v1.SynthesizeStreamRequest.audio_config)
}
inline ::sentiric::tts::v1::AudioConfig* SynthesizeStreamRequest::release_audio_config() {
  
  ::sentiric::tts::v1::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::tts::v1::AudioConfig* SynthesizeStreamRequest::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamRequest.audio_config)
  
  ::sentiric::tts::v1::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::sentiric::tts::v1::AudioConfig* SynthesizeStreamRequest::_internal_mutable_audio_config() {
  
  if (_impl_.audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::tts::v1::AudioConfig>(GetArenaForAllocation());
    _impl_.audio_config_ = p;
  }
  return _impl_.audio_config_;
}
inline ::sentiric::tts::v1::AudioConfig* SynthesizeStreamRequest::mutable_audio_config() {
  ::sentiric::tts::v1::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamRequest.audio_config)
  return _msg;
}
inline void SynthesizeStreamRequest::set_allocated_audio_config(::sentiric::tts::v1::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamRequest.audio_config)
}

// string preferred_provider = 5;
inline void SynthesizeStreamRequest::clear_preferred_provider() {
  _impl_.preferred_provider_.ClearToEmpty();
}
inline const std::string& SynthesizeStreamRequest::preferred_provider() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamRequest.preferred_provider)
  return _internal_preferred_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeStreamRequest::set_preferred_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preferred_provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeStreamRequest.preferred_provider)
}
inline std::string* SynthesizeStreamRequest::mutable_preferred_provider() {
  std::string* _s = _internal_mutable_preferred_provider();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamRequest.preferred_provider)
  return _s;
}
inline const std::string& SynthesizeStreamRequest::_internal_preferred_provider() const {
  return _impl_.preferred_provider_.Get();
}
inline void SynthesizeStreamRequest::_internal_set_preferred_provider(const std::string& value) {
  
  _impl_.preferred_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeStreamRequest::_internal_mutable_preferred_provider() {
  
  return _impl_.preferred_provider_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeStreamRequest::release_preferred_provider() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamRequest.preferred_provider)
  return _impl_.preferred_provider_.Release();
}
inline void SynthesizeStreamRequest::set_allocated_preferred_provider(std::string* preferred_provider) {
  if (preferred_provider != nullptr) {
    
  } else {
    
  }
  _impl_.preferred_provider_.SetAllocated(preferred_provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preferred_provider_.IsDefault()) {
    _impl_.preferred_provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamRequest.preferred_provider)
}

// optional .sentiric.tts.v1.TuningParams tuning = 6;
inline bool SynthesizeStreamRequest::_internal_has_tuning() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tuning_ != nullptr);
  return value;
}
inline bool SynthesizeStreamRequest::has_tuning() const {
  return _internal_has_tuning();
}
inline void SynthesizeStreamRequest::clear_tuning() {
  if (_impl_.tuning_ != nullptr) _impl_.tuning_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sentiric::tts::v1::TuningParams& SynthesizeStreamRequest::_internal_tuning() const {
  const ::sentiric::tts::v1::TuningParams* p = _impl_.tuning_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::tts::v1::TuningParams&>(
      ::sentiric::tts::v1::_TuningParams_default_instance_);
}
inline const ::sentiric::tts::v1::TuningParams& SynthesizeStreamRequest::tuning() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamRequest.tuning)
  return _internal_tuning();
}
inline void SynthesizeStreamRequest::unsafe_arena_set_allocated_tuning(
    ::sentiric::tts::v1::TuningParams* tuning) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuning_);
  }
  _impl_.tuning_ = tuning;
  if (tuning) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.tts.v1.SynthesizeStreamRequest.tuning)
}
inline ::sentiric::tts::v1::TuningParams* SynthesizeStreamRequest::release_tuning() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sentiric::tts::v1::TuningParams* temp = _impl_.tuning_;
  _impl_.tuning_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::tts::v1::TuningParams* SynthesizeStreamRequest::unsafe_arena_release_tuning() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamRequest.tuning)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sentiric::tts::v1::TuningParams* temp = _impl_.tuning_;
  _impl_.tuning_ = nullptr;
  return temp;
}
inline ::sentiric::tts::v1::TuningParams* SynthesizeStreamRequest::_internal_mutable_tuning() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tuning_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::tts::v1::TuningParams>(GetArenaForAllocation());
    _impl_.tuning_ = p;
  }
  return _impl_.tuning_;
}
inline ::sentiric::tts::v1::TuningParams* SynthesizeStreamRequest::mutable_tuning() {
  ::sentiric::tts::v1::TuningParams* _msg = _internal_mutable_tuning();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamRequest.tuning)
  return _msg;
}
inline void SynthesizeStreamRequest::set_allocated_tuning(::sentiric::tts::v1::TuningParams* tuning) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuning_;
  }
  if (tuning) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuning);
    if (message_arena != submessage_arena) {
      tuning = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuning, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tuning_ = tuning;
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamRequest.tuning)
}

// optional bytes cloning_audio_data = 7;
inline bool SynthesizeStreamRequest::_internal_has_cloning_audio_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SynthesizeStreamRequest::has_cloning_audio_data() const {
  return _internal_has_cloning_audio_data();
}
inline void SynthesizeStreamRequest::clear_cloning_audio_data() {
  _impl_.cloning_audio_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SynthesizeStreamRequest::cloning_audio_data() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamRequest.cloning_audio_data)
  return _internal_cloning_audio_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeStreamRequest::set_cloning_audio_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cloning_audio_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeStreamRequest.cloning_audio_data)
}
inline std::string* SynthesizeStreamRequest::mutable_cloning_audio_data() {
  std::string* _s = _internal_mutable_cloning_audio_data();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamRequest.cloning_audio_data)
  return _s;
}
inline const std::string& SynthesizeStreamRequest::_internal_cloning_audio_data() const {
  return _impl_.cloning_audio_data_.Get();
}
inline void SynthesizeStreamRequest::_internal_set_cloning_audio_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cloning_audio_data_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeStreamRequest::_internal_mutable_cloning_audio_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cloning_audio_data_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeStreamRequest::release_cloning_audio_data() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamRequest.cloning_audio_data)
  if (!_internal_has_cloning_audio_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cloning_audio_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloning_audio_data_.IsDefault()) {
    _impl_.cloning_audio_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SynthesizeStreamRequest::set_allocated_cloning_audio_data(std::string* cloning_audio_data) {
  if (cloning_audio_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cloning_audio_data_.SetAllocated(cloning_audio_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloning_audio_data_.IsDefault()) {
    _impl_.cloning_audio_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamRequest.cloning_audio_data)
}

// -------------------------------------------------------------------

// SynthesizeStreamResponse

// bytes audio_content = 1;
inline void SynthesizeStreamResponse::clear_audio_content() {
  _impl_.audio_content_.ClearToEmpty();
}
inline const std::string& SynthesizeStreamResponse::audio_content() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamResponse.audio_content)
  return _internal_audio_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeStreamResponse::set_audio_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeStreamResponse.audio_content)
}
inline std::string* SynthesizeStreamResponse::mutable_audio_content() {
  std::string* _s = _internal_mutable_audio_content();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamResponse.audio_content)
  return _s;
}
inline const std::string& SynthesizeStreamResponse::_internal_audio_content() const {
  return _impl_.audio_content_.Get();
}
inline void SynthesizeStreamResponse::_internal_set_audio_content(const std::string& value) {
  
  _impl_.audio_content_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeStreamResponse::_internal_mutable_audio_content() {
  
  return _impl_.audio_content_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeStreamResponse::release_audio_content() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamResponse.audio_content)
  return _impl_.audio_content_.Release();
}
inline void SynthesizeStreamResponse::set_allocated_audio_content(std::string* audio_content) {
  if (audio_content != nullptr) {
    
  } else {
    
  }
  _impl_.audio_content_.SetAllocated(audio_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_content_.IsDefault()) {
    _impl_.audio_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamResponse.audio_content)
}

// string content_type = 2;
inline void SynthesizeStreamResponse::clear_content_type() {
  _impl_.content_type_.ClearToEmpty();
}
inline const std::string& SynthesizeStreamResponse::content_type() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamResponse.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeStreamResponse::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeStreamResponse.content_type)
}
inline std::string* SynthesizeStreamResponse::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamResponse.content_type)
  return _s;
}
inline const std::string& SynthesizeStreamResponse::_internal_content_type() const {
  return _impl_.content_type_.Get();
}
inline void SynthesizeStreamResponse::_internal_set_content_type(const std::string& value) {
  
  _impl_.content_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeStreamResponse::_internal_mutable_content_type() {
  
  return _impl_.content_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeStreamResponse::release_content_type() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamResponse.content_type)
  return _impl_.content_type_.Release();
}
inline void SynthesizeStreamResponse::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  _impl_.content_type_.SetAllocated(content_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_type_.IsDefault()) {
    _impl_.content_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamResponse.content_type)
}

// string provider_used = 3;
inline void SynthesizeStreamResponse::clear_provider_used() {
  _impl_.provider_used_.ClearToEmpty();
}
inline const std::string& SynthesizeStreamResponse::provider_used() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.SynthesizeStreamResponse.provider_used)
  return _internal_provider_used();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeStreamResponse::set_provider_used(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_used_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.SynthesizeStreamResponse.provider_used)
}
inline std::string* SynthesizeStreamResponse::mutable_provider_used() {
  std::string* _s = _internal_mutable_provider_used();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.SynthesizeStreamResponse.provider_used)
  return _s;
}
inline const std::string& SynthesizeStreamResponse::_internal_provider_used() const {
  return _impl_.provider_used_.Get();
}
inline void SynthesizeStreamResponse::_internal_set_provider_used(const std::string& value) {
  
  _impl_.provider_used_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeStreamResponse::_internal_mutable_provider_used() {
  
  return _impl_.provider_used_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeStreamResponse::release_provider_used() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.SynthesizeStreamResponse.provider_used)
  return _impl_.provider_used_.Release();
}
inline void SynthesizeStreamResponse::set_allocated_provider_used(std::string* provider_used) {
  if (provider_used != nullptr) {
    
  } else {
    
  }
  _impl_.provider_used_.SetAllocated(provider_used, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_used_.IsDefault()) {
    _impl_.provider_used_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.SynthesizeStreamResponse.provider_used)
}

// -------------------------------------------------------------------

// ListVoicesRequest

// string language_code = 1;
inline void ListVoicesRequest::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& ListVoicesRequest::language_code() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.ListVoicesRequest.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListVoicesRequest::set_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.ListVoicesRequest.language_code)
}
inline std::string* ListVoicesRequest::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.ListVoicesRequest.language_code)
  return _s;
}
inline const std::string& ListVoicesRequest::_internal_language_code() const {
  return _impl_.language_code_.Get();
}
inline void ListVoicesRequest::_internal_set_language_code(const std::string& value) {
  
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* ListVoicesRequest::_internal_mutable_language_code() {
  
  return _impl_.language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* ListVoicesRequest::release_language_code() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.ListVoicesRequest.language_code)
  return _impl_.language_code_.Release();
}
inline void ListVoicesRequest::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  _impl_.language_code_.SetAllocated(language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_code_.IsDefault()) {
    _impl_.language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.ListVoicesRequest.language_code)
}

// -------------------------------------------------------------------

// ListVoicesResponse

// repeated .sentiric.tts.v1.VoiceInfo voices = 1;
inline int ListVoicesResponse::_internal_voices_size() const {
  return _impl_.voices_.size();
}
inline int ListVoicesResponse::voices_size() const {
  return _internal_voices_size();
}
inline void ListVoicesResponse::clear_voices() {
  _impl_.voices_.Clear();
}
inline ::sentiric::tts::v1::VoiceInfo* ListVoicesResponse::mutable_voices(int index) {
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.ListVoicesResponse.voices)
  return _impl_.voices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::tts::v1::VoiceInfo >*
ListVoicesResponse::mutable_voices() {
  // @@protoc_insertion_point(field_mutable_list:sentiric.tts.v1.ListVoicesResponse.voices)
  return &_impl_.voices_;
}
inline const ::sentiric::tts::v1::VoiceInfo& ListVoicesResponse::_internal_voices(int index) const {
  return _impl_.voices_.Get(index);
}
inline const ::sentiric::tts::v1::VoiceInfo& ListVoicesResponse::voices(int index) const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.ListVoicesResponse.voices)
  return _internal_voices(index);
}
inline ::sentiric::tts::v1::VoiceInfo* ListVoicesResponse::_internal_add_voices() {
  return _impl_.voices_.Add();
}
inline ::sentiric::tts::v1::VoiceInfo* ListVoicesResponse::add_voices() {
  ::sentiric::tts::v1::VoiceInfo* _add = _internal_add_voices();
  // @@protoc_insertion_point(field_add:sentiric.tts.v1.ListVoicesResponse.voices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::tts::v1::VoiceInfo >&
ListVoicesResponse::voices() const {
  // @@protoc_insertion_point(field_list:sentiric.tts.v1.ListVoicesResponse.voices)
  return _impl_.voices_;
}

// -------------------------------------------------------------------

// TuningParams

// float temperature = 1;
inline void TuningParams::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline float TuningParams::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float TuningParams::temperature() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.TuningParams.temperature)
  return _internal_temperature();
}
inline void TuningParams::_internal_set_temperature(float value) {
  
  _impl_.temperature_ = value;
}
inline void TuningParams::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.TuningParams.temperature)
}

// float top_p = 2;
inline void TuningParams::clear_top_p() {
  _impl_.top_p_ = 0;
}
inline float TuningParams::_internal_top_p() const {
  return _impl_.top_p_;
}
inline float TuningParams::top_p() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.TuningParams.top_p)
  return _internal_top_p();
}
inline void TuningParams::_internal_set_top_p(float value) {
  
  _impl_.top_p_ = value;
}
inline void TuningParams::set_top_p(float value) {
  _internal_set_top_p(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.TuningParams.top_p)
}

// int32 top_k = 3;
inline void TuningParams::clear_top_k() {
  _impl_.top_k_ = 0;
}
inline int32_t TuningParams::_internal_top_k() const {
  return _impl_.top_k_;
}
inline int32_t TuningParams::top_k() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.TuningParams.top_k)
  return _internal_top_k();
}
inline void TuningParams::_internal_set_top_k(int32_t value) {
  
  _impl_.top_k_ = value;
}
inline void TuningParams::set_top_k(int32_t value) {
  _internal_set_top_k(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.TuningParams.top_k)
}

// float repetition_penalty = 4;
inline void TuningParams::clear_repetition_penalty() {
  _impl_.repetition_penalty_ = 0;
}
inline float TuningParams::_internal_repetition_penalty() const {
  return _impl_.repetition_penalty_;
}
inline float TuningParams::repetition_penalty() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.TuningParams.repetition_penalty)
  return _internal_repetition_penalty();
}
inline void TuningParams::_internal_set_repetition_penalty(float value) {
  
  _impl_.repetition_penalty_ = value;
}
inline void TuningParams::set_repetition_penalty(float value) {
  _internal_set_repetition_penalty(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.TuningParams.repetition_penalty)
}

// float speed = 5;
inline void TuningParams::clear_speed() {
  _impl_.speed_ = 0;
}
inline float TuningParams::_internal_speed() const {
  return _impl_.speed_;
}
inline float TuningParams::speed() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.TuningParams.speed)
  return _internal_speed();
}
inline void TuningParams::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void TuningParams::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.TuningParams.speed)
}

// -------------------------------------------------------------------

// AudioConfig

// .sentiric.tts.v1.AudioFormat audio_format = 1;
inline void AudioConfig::clear_audio_format() {
  _impl_.audio_format_ = 0;
}
inline ::sentiric::tts::v1::AudioFormat AudioConfig::_internal_audio_format() const {
  return static_cast< ::sentiric::tts::v1::AudioFormat >(_impl_.audio_format_);
}
inline ::sentiric::tts::v1::AudioFormat AudioConfig::audio_format() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.AudioConfig.audio_format)
  return _internal_audio_format();
}
inline void AudioConfig::_internal_set_audio_format(::sentiric::tts::v1::AudioFormat value) {
  
  _impl_.audio_format_ = value;
}
inline void AudioConfig::set_audio_format(::sentiric::tts::v1::AudioFormat value) {
  _internal_set_audio_format(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.AudioConfig.audio_format)
}

// int32 sample_rate_hertz = 2;
inline void AudioConfig::clear_sample_rate_hertz() {
  _impl_.sample_rate_hertz_ = 0;
}
inline int32_t AudioConfig::_internal_sample_rate_hertz() const {
  return _impl_.sample_rate_hertz_;
}
inline int32_t AudioConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.AudioConfig.sample_rate_hertz)
  return _internal_sample_rate_hertz();
}
inline void AudioConfig::_internal_set_sample_rate_hertz(int32_t value) {
  
  _impl_.sample_rate_hertz_ = value;
}
inline void AudioConfig::set_sample_rate_hertz(int32_t value) {
  _internal_set_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.AudioConfig.sample_rate_hertz)
}

// double volume_gain_db = 3;
inline void AudioConfig::clear_volume_gain_db() {
  _impl_.volume_gain_db_ = 0;
}
inline double AudioConfig::_internal_volume_gain_db() const {
  return _impl_.volume_gain_db_;
}
inline double AudioConfig::volume_gain_db() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.AudioConfig.volume_gain_db)
  return _internal_volume_gain_db();
}
inline void AudioConfig::_internal_set_volume_gain_db(double value) {
  
  _impl_.volume_gain_db_ = value;
}
inline void AudioConfig::set_volume_gain_db(double value) {
  _internal_set_volume_gain_db(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.AudioConfig.volume_gain_db)
}

// -------------------------------------------------------------------

// ProsodyConfig

// double rate = 1;
inline void ProsodyConfig::clear_rate() {
  _impl_.rate_ = 0;
}
inline double ProsodyConfig::_internal_rate() const {
  return _impl_.rate_;
}
inline double ProsodyConfig::rate() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.ProsodyConfig.rate)
  return _internal_rate();
}
inline void ProsodyConfig::_internal_set_rate(double value) {
  
  _impl_.rate_ = value;
}
inline void ProsodyConfig::set_rate(double value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.ProsodyConfig.rate)
}

// double pitch = 2;
inline void ProsodyConfig::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline double ProsodyConfig::_internal_pitch() const {
  return _impl_.pitch_;
}
inline double ProsodyConfig::pitch() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.ProsodyConfig.pitch)
  return _internal_pitch();
}
inline void ProsodyConfig::_internal_set_pitch(double value) {
  
  _impl_.pitch_ = value;
}
inline void ProsodyConfig::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.ProsodyConfig.pitch)
}

// string emotion = 3;
inline void ProsodyConfig::clear_emotion() {
  _impl_.emotion_.ClearToEmpty();
}
inline const std::string& ProsodyConfig::emotion() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.ProsodyConfig.emotion)
  return _internal_emotion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProsodyConfig::set_emotion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.emotion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.ProsodyConfig.emotion)
}
inline std::string* ProsodyConfig::mutable_emotion() {
  std::string* _s = _internal_mutable_emotion();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.ProsodyConfig.emotion)
  return _s;
}
inline const std::string& ProsodyConfig::_internal_emotion() const {
  return _impl_.emotion_.Get();
}
inline void ProsodyConfig::_internal_set_emotion(const std::string& value) {
  
  _impl_.emotion_.Set(value, GetArenaForAllocation());
}
inline std::string* ProsodyConfig::_internal_mutable_emotion() {
  
  return _impl_.emotion_.Mutable(GetArenaForAllocation());
}
inline std::string* ProsodyConfig::release_emotion() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.ProsodyConfig.emotion)
  return _impl_.emotion_.Release();
}
inline void ProsodyConfig::set_allocated_emotion(std::string* emotion) {
  if (emotion != nullptr) {
    
  } else {
    
  }
  _impl_.emotion_.SetAllocated(emotion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.emotion_.IsDefault()) {
    _impl_.emotion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.ProsodyConfig.emotion)
}

// -------------------------------------------------------------------

// VoiceInfo

// string id = 1;
inline void VoiceInfo::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& VoiceInfo::id() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.VoiceInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.VoiceInfo.id)
}
inline std::string* VoiceInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.VoiceInfo.id)
  return _s;
}
inline const std::string& VoiceInfo::_internal_id() const {
  return _impl_.id_.Get();
}
inline void VoiceInfo::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VoiceInfo::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* VoiceInfo::release_id() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.VoiceInfo.id)
  return _impl_.id_.Release();
}
inline void VoiceInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.VoiceInfo.id)
}

// string name = 2;
inline void VoiceInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& VoiceInfo::name() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.VoiceInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.VoiceInfo.name)
}
inline std::string* VoiceInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.VoiceInfo.name)
  return _s;
}
inline const std::string& VoiceInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void VoiceInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VoiceInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* VoiceInfo::release_name() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.VoiceInfo.name)
  return _impl_.name_.Release();
}
inline void VoiceInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.VoiceInfo.name)
}

// string language = 3;
inline void VoiceInfo::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& VoiceInfo::language() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.VoiceInfo.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceInfo::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.VoiceInfo.language)
}
inline std::string* VoiceInfo::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.VoiceInfo.language)
  return _s;
}
inline const std::string& VoiceInfo::_internal_language() const {
  return _impl_.language_.Get();
}
inline void VoiceInfo::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* VoiceInfo::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* VoiceInfo::release_language() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.VoiceInfo.language)
  return _impl_.language_.Release();
}
inline void VoiceInfo::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.VoiceInfo.language)
}

// string gender = 4;
inline void VoiceInfo::clear_gender() {
  _impl_.gender_.ClearToEmpty();
}
inline const std::string& VoiceInfo::gender() const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.VoiceInfo.gender)
  return _internal_gender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceInfo::set_gender(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gender_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.VoiceInfo.gender)
}
inline std::string* VoiceInfo::mutable_gender() {
  std::string* _s = _internal_mutable_gender();
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.VoiceInfo.gender)
  return _s;
}
inline const std::string& VoiceInfo::_internal_gender() const {
  return _impl_.gender_.Get();
}
inline void VoiceInfo::_internal_set_gender(const std::string& value) {
  
  _impl_.gender_.Set(value, GetArenaForAllocation());
}
inline std::string* VoiceInfo::_internal_mutable_gender() {
  
  return _impl_.gender_.Mutable(GetArenaForAllocation());
}
inline std::string* VoiceInfo::release_gender() {
  // @@protoc_insertion_point(field_release:sentiric.tts.v1.VoiceInfo.gender)
  return _impl_.gender_.Release();
}
inline void VoiceInfo::set_allocated_gender(std::string* gender) {
  if (gender != nullptr) {
    
  } else {
    
  }
  _impl_.gender_.SetAllocated(gender, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gender_.IsDefault()) {
    _impl_.gender_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.tts.v1.VoiceInfo.gender)
}

// repeated string styles = 5;
inline int VoiceInfo::_internal_styles_size() const {
  return _impl_.styles_.size();
}
inline int VoiceInfo::styles_size() const {
  return _internal_styles_size();
}
inline void VoiceInfo::clear_styles() {
  _impl_.styles_.Clear();
}
inline std::string* VoiceInfo::add_styles() {
  std::string* _s = _internal_add_styles();
  // @@protoc_insertion_point(field_add_mutable:sentiric.tts.v1.VoiceInfo.styles)
  return _s;
}
inline const std::string& VoiceInfo::_internal_styles(int index) const {
  return _impl_.styles_.Get(index);
}
inline const std::string& VoiceInfo::styles(int index) const {
  // @@protoc_insertion_point(field_get:sentiric.tts.v1.VoiceInfo.styles)
  return _internal_styles(index);
}
inline std::string* VoiceInfo::mutable_styles(int index) {
  // @@protoc_insertion_point(field_mutable:sentiric.tts.v1.VoiceInfo.styles)
  return _impl_.styles_.Mutable(index);
}
inline void VoiceInfo::set_styles(int index, const std::string& value) {
  _impl_.styles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.VoiceInfo.styles)
}
inline void VoiceInfo::set_styles(int index, std::string&& value) {
  _impl_.styles_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sentiric.tts.v1.VoiceInfo.styles)
}
inline void VoiceInfo::set_styles(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.styles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sentiric.tts.v1.VoiceInfo.styles)
}
inline void VoiceInfo::set_styles(int index, const char* value, size_t size) {
  _impl_.styles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sentiric.tts.v1.VoiceInfo.styles)
}
inline std::string* VoiceInfo::_internal_add_styles() {
  return _impl_.styles_.Add();
}
inline void VoiceInfo::add_styles(const std::string& value) {
  _impl_.styles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sentiric.tts.v1.VoiceInfo.styles)
}
inline void VoiceInfo::add_styles(std::string&& value) {
  _impl_.styles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sentiric.tts.v1.VoiceInfo.styles)
}
inline void VoiceInfo::add_styles(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.styles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sentiric.tts.v1.VoiceInfo.styles)
}
inline void VoiceInfo::add_styles(const char* value, size_t size) {
  _impl_.styles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sentiric.tts.v1.VoiceInfo.styles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VoiceInfo::styles() const {
  // @@protoc_insertion_point(field_list:sentiric.tts.v1.VoiceInfo.styles)
  return _impl_.styles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VoiceInfo::mutable_styles() {
  // @@protoc_insertion_point(field_mutable_list:sentiric.tts.v1.VoiceInfo.styles)
  return &_impl_.styles_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace tts
}  // namespace sentiric

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sentiric::tts::v1::TextType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentiric::tts::v1::TextType>() {
  return ::sentiric::tts::v1::TextType_descriptor();
}
template <> struct is_proto_enum< ::sentiric::tts::v1::AudioFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sentiric::tts::v1::AudioFormat>() {
  return ::sentiric::tts::v1::AudioFormat_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sentiric_2ftts_2fv1_2fgateway_2eproto
