// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sentiric/user/v1/user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sentiric_2fuser_2fv1_2fuser_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sentiric_2fuser_2fv1_2fuser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/field_mask.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sentiric_2fuser_2fv1_2fuser_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sentiric_2fuser_2fv1_2fuser_2eproto;
namespace sentiric {
namespace user {
namespace v1 {
class AddContactRequest;
struct AddContactRequestDefaultTypeInternal;
extern AddContactRequestDefaultTypeInternal _AddContactRequest_default_instance_;
class AddContactResponse;
struct AddContactResponseDefaultTypeInternal;
extern AddContactResponseDefaultTypeInternal _AddContactResponse_default_instance_;
class Contact;
struct ContactDefaultTypeInternal;
extern ContactDefaultTypeInternal _Contact_default_instance_;
class CreateSipCredentialRequest;
struct CreateSipCredentialRequestDefaultTypeInternal;
extern CreateSipCredentialRequestDefaultTypeInternal _CreateSipCredentialRequest_default_instance_;
class CreateSipCredentialResponse;
struct CreateSipCredentialResponseDefaultTypeInternal;
extern CreateSipCredentialResponseDefaultTypeInternal _CreateSipCredentialResponse_default_instance_;
class CreateUserRequest;
struct CreateUserRequestDefaultTypeInternal;
extern CreateUserRequestDefaultTypeInternal _CreateUserRequest_default_instance_;
class CreateUserRequest_InitialContact;
struct CreateUserRequest_InitialContactDefaultTypeInternal;
extern CreateUserRequest_InitialContactDefaultTypeInternal _CreateUserRequest_InitialContact_default_instance_;
class CreateUserResponse;
struct CreateUserResponseDefaultTypeInternal;
extern CreateUserResponseDefaultTypeInternal _CreateUserResponse_default_instance_;
class DeleteContactRequest;
struct DeleteContactRequestDefaultTypeInternal;
extern DeleteContactRequestDefaultTypeInternal _DeleteContactRequest_default_instance_;
class DeleteContactResponse;
struct DeleteContactResponseDefaultTypeInternal;
extern DeleteContactResponseDefaultTypeInternal _DeleteContactResponse_default_instance_;
class DeleteSipCredentialRequest;
struct DeleteSipCredentialRequestDefaultTypeInternal;
extern DeleteSipCredentialRequestDefaultTypeInternal _DeleteSipCredentialRequest_default_instance_;
class DeleteSipCredentialResponse;
struct DeleteSipCredentialResponseDefaultTypeInternal;
extern DeleteSipCredentialResponseDefaultTypeInternal _DeleteSipCredentialResponse_default_instance_;
class DeleteUserRequest;
struct DeleteUserRequestDefaultTypeInternal;
extern DeleteUserRequestDefaultTypeInternal _DeleteUserRequest_default_instance_;
class DeleteUserResponse;
struct DeleteUserResponseDefaultTypeInternal;
extern DeleteUserResponseDefaultTypeInternal _DeleteUserResponse_default_instance_;
class FindUserByContactRequest;
struct FindUserByContactRequestDefaultTypeInternal;
extern FindUserByContactRequestDefaultTypeInternal _FindUserByContactRequest_default_instance_;
class FindUserByContactResponse;
struct FindUserByContactResponseDefaultTypeInternal;
extern FindUserByContactResponseDefaultTypeInternal _FindUserByContactResponse_default_instance_;
class GetSipCredentialsRequest;
struct GetSipCredentialsRequestDefaultTypeInternal;
extern GetSipCredentialsRequestDefaultTypeInternal _GetSipCredentialsRequest_default_instance_;
class GetSipCredentialsResponse;
struct GetSipCredentialsResponseDefaultTypeInternal;
extern GetSipCredentialsResponseDefaultTypeInternal _GetSipCredentialsResponse_default_instance_;
class GetUserRequest;
struct GetUserRequestDefaultTypeInternal;
extern GetUserRequestDefaultTypeInternal _GetUserRequest_default_instance_;
class GetUserResponse;
struct GetUserResponseDefaultTypeInternal;
extern GetUserResponseDefaultTypeInternal _GetUserResponse_default_instance_;
class Tenant;
struct TenantDefaultTypeInternal;
extern TenantDefaultTypeInternal _Tenant_default_instance_;
class UpdateContactRequest;
struct UpdateContactRequestDefaultTypeInternal;
extern UpdateContactRequestDefaultTypeInternal _UpdateContactRequest_default_instance_;
class UpdateContactResponse;
struct UpdateContactResponseDefaultTypeInternal;
extern UpdateContactResponseDefaultTypeInternal _UpdateContactResponse_default_instance_;
class UpdateUserRequest;
struct UpdateUserRequestDefaultTypeInternal;
extern UpdateUserRequestDefaultTypeInternal _UpdateUserRequest_default_instance_;
class UpdateUserResponse;
struct UpdateUserResponseDefaultTypeInternal;
extern UpdateUserResponseDefaultTypeInternal _UpdateUserResponse_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace v1
}  // namespace user
}  // namespace sentiric
PROTOBUF_NAMESPACE_OPEN
template<> ::sentiric::user::v1::AddContactRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::AddContactRequest>(Arena*);
template<> ::sentiric::user::v1::AddContactResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::AddContactResponse>(Arena*);
template<> ::sentiric::user::v1::Contact* Arena::CreateMaybeMessage<::sentiric::user::v1::Contact>(Arena*);
template<> ::sentiric::user::v1::CreateSipCredentialRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::CreateSipCredentialRequest>(Arena*);
template<> ::sentiric::user::v1::CreateSipCredentialResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::CreateSipCredentialResponse>(Arena*);
template<> ::sentiric::user::v1::CreateUserRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::CreateUserRequest>(Arena*);
template<> ::sentiric::user::v1::CreateUserRequest_InitialContact* Arena::CreateMaybeMessage<::sentiric::user::v1::CreateUserRequest_InitialContact>(Arena*);
template<> ::sentiric::user::v1::CreateUserResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::CreateUserResponse>(Arena*);
template<> ::sentiric::user::v1::DeleteContactRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::DeleteContactRequest>(Arena*);
template<> ::sentiric::user::v1::DeleteContactResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::DeleteContactResponse>(Arena*);
template<> ::sentiric::user::v1::DeleteSipCredentialRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::DeleteSipCredentialRequest>(Arena*);
template<> ::sentiric::user::v1::DeleteSipCredentialResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::DeleteSipCredentialResponse>(Arena*);
template<> ::sentiric::user::v1::DeleteUserRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::DeleteUserRequest>(Arena*);
template<> ::sentiric::user::v1::DeleteUserResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::DeleteUserResponse>(Arena*);
template<> ::sentiric::user::v1::FindUserByContactRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::FindUserByContactRequest>(Arena*);
template<> ::sentiric::user::v1::FindUserByContactResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::FindUserByContactResponse>(Arena*);
template<> ::sentiric::user::v1::GetSipCredentialsRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::GetSipCredentialsRequest>(Arena*);
template<> ::sentiric::user::v1::GetSipCredentialsResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::GetSipCredentialsResponse>(Arena*);
template<> ::sentiric::user::v1::GetUserRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::GetUserRequest>(Arena*);
template<> ::sentiric::user::v1::GetUserResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::GetUserResponse>(Arena*);
template<> ::sentiric::user::v1::Tenant* Arena::CreateMaybeMessage<::sentiric::user::v1::Tenant>(Arena*);
template<> ::sentiric::user::v1::UpdateContactRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::UpdateContactRequest>(Arena*);
template<> ::sentiric::user::v1::UpdateContactResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::UpdateContactResponse>(Arena*);
template<> ::sentiric::user::v1::UpdateUserRequest* Arena::CreateMaybeMessage<::sentiric::user::v1::UpdateUserRequest>(Arena*);
template<> ::sentiric::user::v1::UpdateUserResponse* Arena::CreateMaybeMessage<::sentiric::user::v1::UpdateUserResponse>(Arena*);
template<> ::sentiric::user::v1::User* Arena::CreateMaybeMessage<::sentiric::user::v1::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sentiric {
namespace user {
namespace v1 {

// ===================================================================

class Contact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.Contact) */ {
 public:
  inline Contact() : Contact(nullptr) {}
  ~Contact() override;
  explicit PROTOBUF_CONSTEXPR Contact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contact(const Contact& from);
  Contact(Contact&& from) noexcept
    : Contact() {
    *this = ::std::move(from);
  }

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contact& operator=(Contact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contact* internal_default_instance() {
    return reinterpret_cast<const Contact*>(
               &_Contact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Contact& a, Contact& b) {
    a.Swap(&b);
  }
  inline void Swap(Contact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Contact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Contact& from) {
    Contact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.Contact";
  }
  protected:
  explicit Contact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kContactTypeFieldNumber = 3,
    kContactValueFieldNumber = 4,
    kIdFieldNumber = 1,
    kIsPrimaryFieldNumber = 5,
  };
  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string contact_type = 3;
  void clear_contact_type();
  const std::string& contact_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_type();
  PROTOBUF_NODISCARD std::string* release_contact_type();
  void set_allocated_contact_type(std::string* contact_type);
  private:
  const std::string& _internal_contact_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_type(const std::string& value);
  std::string* _internal_mutable_contact_type();
  public:

  // string contact_value = 4;
  void clear_contact_value();
  const std::string& contact_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_value();
  PROTOBUF_NODISCARD std::string* release_contact_value();
  void set_allocated_contact_value(std::string* contact_value);
  private:
  const std::string& _internal_contact_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_value(const std::string& value);
  std::string* _internal_mutable_contact_value();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // bool is_primary = 5;
  void clear_is_primary();
  bool is_primary() const;
  void set_is_primary(bool value);
  private:
  bool _internal_is_primary() const;
  void _internal_set_is_primary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.Contact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_value_;
    int32_t id_;
    bool is_primary_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactsFieldNumber = 5,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTenantIdFieldNumber = 3,
    kUserTypeFieldNumber = 4,
    kPreferredLanguageCodeFieldNumber = 6,
  };
  // repeated .sentiric.user.v1.Contact contacts = 5;
  int contacts_size() const;
  private:
  int _internal_contacts_size() const;
  public:
  void clear_contacts();
  ::sentiric::user::v1::Contact* mutable_contacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::user::v1::Contact >*
      mutable_contacts();
  private:
  const ::sentiric::user::v1::Contact& _internal_contacts(int index) const;
  ::sentiric::user::v1::Contact* _internal_add_contacts();
  public:
  const ::sentiric::user::v1::Contact& contacts(int index) const;
  ::sentiric::user::v1::Contact* add_contacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::user::v1::Contact >&
      contacts() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string tenant_id = 3;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // string user_type = 4;
  void clear_user_type();
  const std::string& user_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_type();
  PROTOBUF_NODISCARD std::string* release_user_type();
  void set_allocated_user_type(std::string* user_type);
  private:
  const std::string& _internal_user_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_type(const std::string& value);
  std::string* _internal_mutable_user_type();
  public:

  // optional string preferred_language_code = 6;
  bool has_preferred_language_code() const;
  private:
  bool _internal_has_preferred_language_code() const;
  public:
  void clear_preferred_language_code();
  const std::string& preferred_language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preferred_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preferred_language_code();
  PROTOBUF_NODISCARD std::string* release_preferred_language_code();
  void set_allocated_preferred_language_code(std::string* preferred_language_code);
  private:
  const std::string& _internal_preferred_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preferred_language_code(const std::string& value);
  std::string* _internal_mutable_preferred_language_code();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::user::v1::Contact > contacts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preferred_language_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class Tenant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.Tenant) */ {
 public:
  inline Tenant() : Tenant(nullptr) {}
  ~Tenant() override;
  explicit PROTOBUF_CONSTEXPR Tenant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tenant(const Tenant& from);
  Tenant(Tenant&& from) noexcept
    : Tenant() {
    *this = ::std::move(from);
  }

  inline Tenant& operator=(const Tenant& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tenant& operator=(Tenant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tenant& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tenant* internal_default_instance() {
    return reinterpret_cast<const Tenant*>(
               &_Tenant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Tenant& a, Tenant& b) {
    a.Swap(&b);
  }
  inline void Swap(Tenant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tenant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tenant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tenant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tenant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tenant& from) {
    Tenant::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tenant* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.Tenant";
  }
  protected:
  explicit Tenant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDomainFieldNumber = 3,
    kPrimaryLanguageCodeFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string domain = 3;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string primary_language_code = 4;
  void clear_primary_language_code();
  const std::string& primary_language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_language_code();
  PROTOBUF_NODISCARD std::string* release_primary_language_code();
  void set_allocated_primary_language_code(std::string* primary_language_code);
  private:
  const std::string& _internal_primary_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_language_code(const std::string& value);
  std::string* _internal_mutable_primary_language_code();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.Tenant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_language_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.GetUserRequest) */ {
 public:
  inline GetUserRequest() : GetUserRequest(nullptr) {}
  ~GetUserRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserRequest(const GetUserRequest& from);
  GetUserRequest(GetUserRequest&& from) noexcept
    : GetUserRequest() {
    *this = ::std::move(from);
  }

  inline GetUserRequest& operator=(const GetUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserRequest& operator=(GetUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserRequest*>(
               &_GetUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetUserRequest& a, GetUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserRequest& from) {
    GetUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.GetUserRequest";
  }
  protected:
  explicit GetUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.GetUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.GetUserResponse) */ {
 public:
  inline GetUserResponse() : GetUserResponse(nullptr) {}
  ~GetUserResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserResponse(const GetUserResponse& from);
  GetUserResponse(GetUserResponse&& from) noexcept
    : GetUserResponse() {
    *this = ::std::move(from);
  }

  inline GetUserResponse& operator=(const GetUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserResponse& operator=(GetUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserResponse*>(
               &_GetUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetUserResponse& a, GetUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserResponse& from) {
    GetUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.GetUserResponse";
  }
  protected:
  explicit GetUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .sentiric.user.v1.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.GetUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class FindUserByContactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.FindUserByContactRequest) */ {
 public:
  inline FindUserByContactRequest() : FindUserByContactRequest(nullptr) {}
  ~FindUserByContactRequest() override;
  explicit PROTOBUF_CONSTEXPR FindUserByContactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindUserByContactRequest(const FindUserByContactRequest& from);
  FindUserByContactRequest(FindUserByContactRequest&& from) noexcept
    : FindUserByContactRequest() {
    *this = ::std::move(from);
  }

  inline FindUserByContactRequest& operator=(const FindUserByContactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindUserByContactRequest& operator=(FindUserByContactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindUserByContactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindUserByContactRequest* internal_default_instance() {
    return reinterpret_cast<const FindUserByContactRequest*>(
               &_FindUserByContactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FindUserByContactRequest& a, FindUserByContactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindUserByContactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindUserByContactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindUserByContactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindUserByContactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindUserByContactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindUserByContactRequest& from) {
    FindUserByContactRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindUserByContactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.FindUserByContactRequest";
  }
  protected:
  explicit FindUserByContactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactTypeFieldNumber = 1,
    kContactValueFieldNumber = 2,
  };
  // string contact_type = 1;
  void clear_contact_type();
  const std::string& contact_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_type();
  PROTOBUF_NODISCARD std::string* release_contact_type();
  void set_allocated_contact_type(std::string* contact_type);
  private:
  const std::string& _internal_contact_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_type(const std::string& value);
  std::string* _internal_mutable_contact_type();
  public:

  // string contact_value = 2;
  void clear_contact_value();
  const std::string& contact_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_value();
  PROTOBUF_NODISCARD std::string* release_contact_value();
  void set_allocated_contact_value(std::string* contact_value);
  private:
  const std::string& _internal_contact_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_value(const std::string& value);
  std::string* _internal_mutable_contact_value();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.FindUserByContactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class FindUserByContactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.FindUserByContactResponse) */ {
 public:
  inline FindUserByContactResponse() : FindUserByContactResponse(nullptr) {}
  ~FindUserByContactResponse() override;
  explicit PROTOBUF_CONSTEXPR FindUserByContactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindUserByContactResponse(const FindUserByContactResponse& from);
  FindUserByContactResponse(FindUserByContactResponse&& from) noexcept
    : FindUserByContactResponse() {
    *this = ::std::move(from);
  }

  inline FindUserByContactResponse& operator=(const FindUserByContactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindUserByContactResponse& operator=(FindUserByContactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindUserByContactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindUserByContactResponse* internal_default_instance() {
    return reinterpret_cast<const FindUserByContactResponse*>(
               &_FindUserByContactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FindUserByContactResponse& a, FindUserByContactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FindUserByContactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindUserByContactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindUserByContactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindUserByContactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindUserByContactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindUserByContactResponse& from) {
    FindUserByContactResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindUserByContactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.FindUserByContactResponse";
  }
  protected:
  explicit FindUserByContactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .sentiric.user.v1.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.FindUserByContactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserRequest_InitialContact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.CreateUserRequest.InitialContact) */ {
 public:
  inline CreateUserRequest_InitialContact() : CreateUserRequest_InitialContact(nullptr) {}
  ~CreateUserRequest_InitialContact() override;
  explicit PROTOBUF_CONSTEXPR CreateUserRequest_InitialContact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateUserRequest_InitialContact(const CreateUserRequest_InitialContact& from);
  CreateUserRequest_InitialContact(CreateUserRequest_InitialContact&& from) noexcept
    : CreateUserRequest_InitialContact() {
    *this = ::std::move(from);
  }

  inline CreateUserRequest_InitialContact& operator=(const CreateUserRequest_InitialContact& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserRequest_InitialContact& operator=(CreateUserRequest_InitialContact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateUserRequest_InitialContact& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateUserRequest_InitialContact* internal_default_instance() {
    return reinterpret_cast<const CreateUserRequest_InitialContact*>(
               &_CreateUserRequest_InitialContact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateUserRequest_InitialContact& a, CreateUserRequest_InitialContact& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUserRequest_InitialContact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserRequest_InitialContact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateUserRequest_InitialContact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateUserRequest_InitialContact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateUserRequest_InitialContact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateUserRequest_InitialContact& from) {
    CreateUserRequest_InitialContact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUserRequest_InitialContact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.CreateUserRequest.InitialContact";
  }
  protected:
  explicit CreateUserRequest_InitialContact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactTypeFieldNumber = 1,
    kContactValueFieldNumber = 2,
  };
  // string contact_type = 1;
  void clear_contact_type();
  const std::string& contact_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_type();
  PROTOBUF_NODISCARD std::string* release_contact_type();
  void set_allocated_contact_type(std::string* contact_type);
  private:
  const std::string& _internal_contact_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_type(const std::string& value);
  std::string* _internal_mutable_contact_type();
  public:

  // string contact_value = 2;
  void clear_contact_value();
  const std::string& contact_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_value();
  PROTOBUF_NODISCARD std::string* release_contact_value();
  void set_allocated_contact_value(std::string* contact_value);
  private:
  const std::string& _internal_contact_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_value(const std::string& value);
  std::string* _internal_mutable_contact_value();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.CreateUserRequest.InitialContact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.CreateUserRequest) */ {
 public:
  inline CreateUserRequest() : CreateUserRequest(nullptr) {}
  ~CreateUserRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateUserRequest(const CreateUserRequest& from);
  CreateUserRequest(CreateUserRequest&& from) noexcept
    : CreateUserRequest() {
    *this = ::std::move(from);
  }

  inline CreateUserRequest& operator=(const CreateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserRequest& operator=(CreateUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateUserRequest* internal_default_instance() {
    return reinterpret_cast<const CreateUserRequest*>(
               &_CreateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateUserRequest& a, CreateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateUserRequest& from) {
    CreateUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.CreateUserRequest";
  }
  protected:
  explicit CreateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CreateUserRequest_InitialContact InitialContact;

  // accessors -------------------------------------------------------

  enum : int {
    kTenantIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kNameFieldNumber = 3,
    kPreferredLanguageCodeFieldNumber = 5,
    kInitialContactFieldNumber = 4,
  };
  // string tenant_id = 1;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // string user_type = 2;
  void clear_user_type();
  const std::string& user_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_type();
  PROTOBUF_NODISCARD std::string* release_user_type();
  void set_allocated_user_type(std::string* user_type);
  private:
  const std::string& _internal_user_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_type(const std::string& value);
  std::string* _internal_mutable_user_type();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string preferred_language_code = 5;
  bool has_preferred_language_code() const;
  private:
  bool _internal_has_preferred_language_code() const;
  public:
  void clear_preferred_language_code();
  const std::string& preferred_language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preferred_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preferred_language_code();
  PROTOBUF_NODISCARD std::string* release_preferred_language_code();
  void set_allocated_preferred_language_code(std::string* preferred_language_code);
  private:
  const std::string& _internal_preferred_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preferred_language_code(const std::string& value);
  std::string* _internal_mutable_preferred_language_code();
  public:

  // .sentiric.user.v1.CreateUserRequest.InitialContact initial_contact = 4;
  bool has_initial_contact() const;
  private:
  bool _internal_has_initial_contact() const;
  public:
  void clear_initial_contact();
  const ::sentiric::user::v1::CreateUserRequest_InitialContact& initial_contact() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::CreateUserRequest_InitialContact* release_initial_contact();
  ::sentiric::user::v1::CreateUserRequest_InitialContact* mutable_initial_contact();
  void set_allocated_initial_contact(::sentiric::user::v1::CreateUserRequest_InitialContact* initial_contact);
  private:
  const ::sentiric::user::v1::CreateUserRequest_InitialContact& _internal_initial_contact() const;
  ::sentiric::user::v1::CreateUserRequest_InitialContact* _internal_mutable_initial_contact();
  public:
  void unsafe_arena_set_allocated_initial_contact(
      ::sentiric::user::v1::CreateUserRequest_InitialContact* initial_contact);
  ::sentiric::user::v1::CreateUserRequest_InitialContact* unsafe_arena_release_initial_contact();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.CreateUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preferred_language_code_;
    ::sentiric::user::v1::CreateUserRequest_InitialContact* initial_contact_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.CreateUserResponse) */ {
 public:
  inline CreateUserResponse() : CreateUserResponse(nullptr) {}
  ~CreateUserResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateUserResponse(const CreateUserResponse& from);
  CreateUserResponse(CreateUserResponse&& from) noexcept
    : CreateUserResponse() {
    *this = ::std::move(from);
  }

  inline CreateUserResponse& operator=(const CreateUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateUserResponse& operator=(CreateUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateUserResponse* internal_default_instance() {
    return reinterpret_cast<const CreateUserResponse*>(
               &_CreateUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateUserResponse& a, CreateUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateUserResponse& from) {
    CreateUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.CreateUserResponse";
  }
  protected:
  explicit CreateUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .sentiric.user.v1.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.CreateUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.UpdateUserRequest) */ {
 public:
  inline UpdateUserRequest() : UpdateUserRequest(nullptr) {}
  ~UpdateUserRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserRequest(const UpdateUserRequest& from);
  UpdateUserRequest(UpdateUserRequest&& from) noexcept
    : UpdateUserRequest() {
    *this = ::std::move(from);
  }

  inline UpdateUserRequest& operator=(const UpdateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserRequest& operator=(UpdateUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserRequest*>(
               &_UpdateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateUserRequest& a, UpdateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateUserRequest& from) {
    UpdateUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.UpdateUserRequest";
  }
  protected:
  explicit UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .sentiric.user.v1.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.UpdateUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::User* user_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.UpdateUserResponse) */ {
 public:
  inline UpdateUserResponse() : UpdateUserResponse(nullptr) {}
  ~UpdateUserResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserResponse(const UpdateUserResponse& from);
  UpdateUserResponse(UpdateUserResponse&& from) noexcept
    : UpdateUserResponse() {
    *this = ::std::move(from);
  }

  inline UpdateUserResponse& operator=(const UpdateUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserResponse& operator=(UpdateUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateUserResponse*>(
               &_UpdateUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateUserResponse& a, UpdateUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateUserResponse& from) {
    UpdateUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.UpdateUserResponse";
  }
  protected:
  explicit UpdateUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .sentiric.user.v1.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.UpdateUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.DeleteUserRequest) */ {
 public:
  inline DeleteUserRequest() : DeleteUserRequest(nullptr) {}
  ~DeleteUserRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteUserRequest(const DeleteUserRequest& from);
  DeleteUserRequest(DeleteUserRequest&& from) noexcept
    : DeleteUserRequest() {
    *this = ::std::move(from);
  }

  inline DeleteUserRequest& operator=(const DeleteUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteUserRequest& operator=(DeleteUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteUserRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteUserRequest*>(
               &_DeleteUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteUserRequest& a, DeleteUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteUserRequest& from) {
    DeleteUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.DeleteUserRequest";
  }
  protected:
  explicit DeleteUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.DeleteUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.DeleteUserResponse) */ {
 public:
  inline DeleteUserResponse() : DeleteUserResponse(nullptr) {}
  ~DeleteUserResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteUserResponse(const DeleteUserResponse& from);
  DeleteUserResponse(DeleteUserResponse&& from) noexcept
    : DeleteUserResponse() {
    *this = ::std::move(from);
  }

  inline DeleteUserResponse& operator=(const DeleteUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteUserResponse& operator=(DeleteUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteUserResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteUserResponse*>(
               &_DeleteUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteUserResponse& a, DeleteUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteUserResponse& from) {
    DeleteUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.DeleteUserResponse";
  }
  protected:
  explicit DeleteUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.DeleteUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class AddContactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.AddContactRequest) */ {
 public:
  inline AddContactRequest() : AddContactRequest(nullptr) {}
  ~AddContactRequest() override;
  explicit PROTOBUF_CONSTEXPR AddContactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddContactRequest(const AddContactRequest& from);
  AddContactRequest(AddContactRequest&& from) noexcept
    : AddContactRequest() {
    *this = ::std::move(from);
  }

  inline AddContactRequest& operator=(const AddContactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddContactRequest& operator=(AddContactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddContactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddContactRequest* internal_default_instance() {
    return reinterpret_cast<const AddContactRequest*>(
               &_AddContactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AddContactRequest& a, AddContactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddContactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddContactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddContactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddContactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddContactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddContactRequest& from) {
    AddContactRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddContactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.AddContactRequest";
  }
  protected:
  explicit AddContactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kContactFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .sentiric.user.v1.Contact contact = 2;
  bool has_contact() const;
  private:
  bool _internal_has_contact() const;
  public:
  void clear_contact();
  const ::sentiric::user::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::Contact* release_contact();
  ::sentiric::user::v1::Contact* mutable_contact();
  void set_allocated_contact(::sentiric::user::v1::Contact* contact);
  private:
  const ::sentiric::user::v1::Contact& _internal_contact() const;
  ::sentiric::user::v1::Contact* _internal_mutable_contact();
  public:
  void unsafe_arena_set_allocated_contact(
      ::sentiric::user::v1::Contact* contact);
  ::sentiric::user::v1::Contact* unsafe_arena_release_contact();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.AddContactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::sentiric::user::v1::Contact* contact_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class AddContactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.AddContactResponse) */ {
 public:
  inline AddContactResponse() : AddContactResponse(nullptr) {}
  ~AddContactResponse() override;
  explicit PROTOBUF_CONSTEXPR AddContactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddContactResponse(const AddContactResponse& from);
  AddContactResponse(AddContactResponse&& from) noexcept
    : AddContactResponse() {
    *this = ::std::move(from);
  }

  inline AddContactResponse& operator=(const AddContactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddContactResponse& operator=(AddContactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddContactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddContactResponse* internal_default_instance() {
    return reinterpret_cast<const AddContactResponse*>(
               &_AddContactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AddContactResponse& a, AddContactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddContactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddContactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddContactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddContactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddContactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddContactResponse& from) {
    AddContactResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddContactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.AddContactResponse";
  }
  protected:
  explicit AddContactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .sentiric.user.v1.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.AddContactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateContactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.UpdateContactRequest) */ {
 public:
  inline UpdateContactRequest() : UpdateContactRequest(nullptr) {}
  ~UpdateContactRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateContactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateContactRequest(const UpdateContactRequest& from);
  UpdateContactRequest(UpdateContactRequest&& from) noexcept
    : UpdateContactRequest() {
    *this = ::std::move(from);
  }

  inline UpdateContactRequest& operator=(const UpdateContactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateContactRequest& operator=(UpdateContactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateContactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateContactRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateContactRequest*>(
               &_UpdateContactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateContactRequest& a, UpdateContactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateContactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateContactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateContactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateContactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateContactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateContactRequest& from) {
    UpdateContactRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateContactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.UpdateContactRequest";
  }
  protected:
  explicit UpdateContactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .sentiric.user.v1.Contact contact = 1;
  bool has_contact() const;
  private:
  bool _internal_has_contact() const;
  public:
  void clear_contact();
  const ::sentiric::user::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::Contact* release_contact();
  ::sentiric::user::v1::Contact* mutable_contact();
  void set_allocated_contact(::sentiric::user::v1::Contact* contact);
  private:
  const ::sentiric::user::v1::Contact& _internal_contact() const;
  ::sentiric::user::v1::Contact* _internal_mutable_contact();
  public:
  void unsafe_arena_set_allocated_contact(
      ::sentiric::user::v1::Contact* contact);
  ::sentiric::user::v1::Contact* unsafe_arena_release_contact();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.UpdateContactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::Contact* contact_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateContactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.UpdateContactResponse) */ {
 public:
  inline UpdateContactResponse() : UpdateContactResponse(nullptr) {}
  ~UpdateContactResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateContactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateContactResponse(const UpdateContactResponse& from);
  UpdateContactResponse(UpdateContactResponse&& from) noexcept
    : UpdateContactResponse() {
    *this = ::std::move(from);
  }

  inline UpdateContactResponse& operator=(const UpdateContactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateContactResponse& operator=(UpdateContactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateContactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateContactResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateContactResponse*>(
               &_UpdateContactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateContactResponse& a, UpdateContactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateContactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateContactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateContactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateContactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateContactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateContactResponse& from) {
    UpdateContactResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateContactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.UpdateContactResponse";
  }
  protected:
  explicit UpdateContactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .sentiric.user.v1.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.UpdateContactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteContactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.DeleteContactRequest) */ {
 public:
  inline DeleteContactRequest() : DeleteContactRequest(nullptr) {}
  ~DeleteContactRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteContactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteContactRequest(const DeleteContactRequest& from);
  DeleteContactRequest(DeleteContactRequest&& from) noexcept
    : DeleteContactRequest() {
    *this = ::std::move(from);
  }

  inline DeleteContactRequest& operator=(const DeleteContactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteContactRequest& operator=(DeleteContactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteContactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteContactRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteContactRequest*>(
               &_DeleteContactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteContactRequest& a, DeleteContactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteContactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteContactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteContactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteContactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteContactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteContactRequest& from) {
    DeleteContactRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteContactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.DeleteContactRequest";
  }
  protected:
  explicit DeleteContactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactIdFieldNumber = 1,
  };
  // int32 contact_id = 1;
  void clear_contact_id();
  int32_t contact_id() const;
  void set_contact_id(int32_t value);
  private:
  int32_t _internal_contact_id() const;
  void _internal_set_contact_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.DeleteContactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t contact_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteContactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.DeleteContactResponse) */ {
 public:
  inline DeleteContactResponse() : DeleteContactResponse(nullptr) {}
  ~DeleteContactResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteContactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteContactResponse(const DeleteContactResponse& from);
  DeleteContactResponse(DeleteContactResponse&& from) noexcept
    : DeleteContactResponse() {
    *this = ::std::move(from);
  }

  inline DeleteContactResponse& operator=(const DeleteContactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteContactResponse& operator=(DeleteContactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteContactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteContactResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteContactResponse*>(
               &_DeleteContactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DeleteContactResponse& a, DeleteContactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteContactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteContactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteContactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteContactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteContactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteContactResponse& from) {
    DeleteContactResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteContactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.DeleteContactResponse";
  }
  protected:
  explicit DeleteContactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .sentiric.user.v1.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.DeleteContactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::sentiric::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetSipCredentialsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.GetSipCredentialsRequest) */ {
 public:
  inline GetSipCredentialsRequest() : GetSipCredentialsRequest(nullptr) {}
  ~GetSipCredentialsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSipCredentialsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSipCredentialsRequest(const GetSipCredentialsRequest& from);
  GetSipCredentialsRequest(GetSipCredentialsRequest&& from) noexcept
    : GetSipCredentialsRequest() {
    *this = ::std::move(from);
  }

  inline GetSipCredentialsRequest& operator=(const GetSipCredentialsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSipCredentialsRequest& operator=(GetSipCredentialsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSipCredentialsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSipCredentialsRequest* internal_default_instance() {
    return reinterpret_cast<const GetSipCredentialsRequest*>(
               &_GetSipCredentialsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetSipCredentialsRequest& a, GetSipCredentialsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSipCredentialsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSipCredentialsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSipCredentialsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSipCredentialsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSipCredentialsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSipCredentialsRequest& from) {
    GetSipCredentialsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSipCredentialsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.GetSipCredentialsRequest";
  }
  protected:
  explicit GetSipCredentialsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSipUsernameFieldNumber = 1,
    kRealmFieldNumber = 2,
  };
  // string sip_username = 1;
  void clear_sip_username();
  const std::string& sip_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sip_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sip_username();
  PROTOBUF_NODISCARD std::string* release_sip_username();
  void set_allocated_sip_username(std::string* sip_username);
  private:
  const std::string& _internal_sip_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sip_username(const std::string& value);
  std::string* _internal_mutable_sip_username();
  public:

  // string realm = 2;
  void clear_realm();
  const std::string& realm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realm();
  PROTOBUF_NODISCARD std::string* release_realm();
  void set_allocated_realm(std::string* realm);
  private:
  const std::string& _internal_realm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realm(const std::string& value);
  std::string* _internal_mutable_realm();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.GetSipCredentialsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sip_username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetSipCredentialsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.GetSipCredentialsResponse) */ {
 public:
  inline GetSipCredentialsResponse() : GetSipCredentialsResponse(nullptr) {}
  ~GetSipCredentialsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSipCredentialsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSipCredentialsResponse(const GetSipCredentialsResponse& from);
  GetSipCredentialsResponse(GetSipCredentialsResponse&& from) noexcept
    : GetSipCredentialsResponse() {
    *this = ::std::move(from);
  }

  inline GetSipCredentialsResponse& operator=(const GetSipCredentialsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSipCredentialsResponse& operator=(GetSipCredentialsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSipCredentialsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSipCredentialsResponse* internal_default_instance() {
    return reinterpret_cast<const GetSipCredentialsResponse*>(
               &_GetSipCredentialsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetSipCredentialsResponse& a, GetSipCredentialsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSipCredentialsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSipCredentialsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSipCredentialsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSipCredentialsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSipCredentialsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSipCredentialsResponse& from) {
    GetSipCredentialsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSipCredentialsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.GetSipCredentialsResponse";
  }
  protected:
  explicit GetSipCredentialsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kTenantIdFieldNumber = 2,
    kHa1HashFieldNumber = 3,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string tenant_id = 2;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // string ha1_hash = 3;
  void clear_ha1_hash();
  const std::string& ha1_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ha1_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ha1_hash();
  PROTOBUF_NODISCARD std::string* release_ha1_hash();
  void set_allocated_ha1_hash(std::string* ha1_hash);
  private:
  const std::string& _internal_ha1_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ha1_hash(const std::string& value);
  std::string* _internal_mutable_ha1_hash();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.GetSipCredentialsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ha1_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateSipCredentialRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.CreateSipCredentialRequest) */ {
 public:
  inline CreateSipCredentialRequest() : CreateSipCredentialRequest(nullptr) {}
  ~CreateSipCredentialRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateSipCredentialRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSipCredentialRequest(const CreateSipCredentialRequest& from);
  CreateSipCredentialRequest(CreateSipCredentialRequest&& from) noexcept
    : CreateSipCredentialRequest() {
    *this = ::std::move(from);
  }

  inline CreateSipCredentialRequest& operator=(const CreateSipCredentialRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSipCredentialRequest& operator=(CreateSipCredentialRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSipCredentialRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSipCredentialRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSipCredentialRequest*>(
               &_CreateSipCredentialRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CreateSipCredentialRequest& a, CreateSipCredentialRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSipCredentialRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSipCredentialRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSipCredentialRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSipCredentialRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSipCredentialRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSipCredentialRequest& from) {
    CreateSipCredentialRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSipCredentialRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.CreateSipCredentialRequest";
  }
  protected:
  explicit CreateSipCredentialRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSipUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string sip_username = 2;
  void clear_sip_username();
  const std::string& sip_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sip_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sip_username();
  PROTOBUF_NODISCARD std::string* release_sip_username();
  void set_allocated_sip_username(std::string* sip_username);
  private:
  const std::string& _internal_sip_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sip_username(const std::string& value);
  std::string* _internal_mutable_sip_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.CreateSipCredentialRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sip_username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateSipCredentialResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.CreateSipCredentialResponse) */ {
 public:
  inline CreateSipCredentialResponse() : CreateSipCredentialResponse(nullptr) {}
  ~CreateSipCredentialResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateSipCredentialResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSipCredentialResponse(const CreateSipCredentialResponse& from);
  CreateSipCredentialResponse(CreateSipCredentialResponse&& from) noexcept
    : CreateSipCredentialResponse() {
    *this = ::std::move(from);
  }

  inline CreateSipCredentialResponse& operator=(const CreateSipCredentialResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSipCredentialResponse& operator=(CreateSipCredentialResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSipCredentialResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSipCredentialResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSipCredentialResponse*>(
               &_CreateSipCredentialResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CreateSipCredentialResponse& a, CreateSipCredentialResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSipCredentialResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSipCredentialResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSipCredentialResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSipCredentialResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSipCredentialResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSipCredentialResponse& from) {
    CreateSipCredentialResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSipCredentialResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.CreateSipCredentialResponse";
  }
  protected:
  explicit CreateSipCredentialResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.CreateSipCredentialResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteSipCredentialRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.DeleteSipCredentialRequest) */ {
 public:
  inline DeleteSipCredentialRequest() : DeleteSipCredentialRequest(nullptr) {}
  ~DeleteSipCredentialRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteSipCredentialRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSipCredentialRequest(const DeleteSipCredentialRequest& from);
  DeleteSipCredentialRequest(DeleteSipCredentialRequest&& from) noexcept
    : DeleteSipCredentialRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSipCredentialRequest& operator=(const DeleteSipCredentialRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSipCredentialRequest& operator=(DeleteSipCredentialRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSipCredentialRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSipCredentialRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSipCredentialRequest*>(
               &_DeleteSipCredentialRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DeleteSipCredentialRequest& a, DeleteSipCredentialRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSipCredentialRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSipCredentialRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSipCredentialRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSipCredentialRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSipCredentialRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSipCredentialRequest& from) {
    DeleteSipCredentialRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSipCredentialRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.DeleteSipCredentialRequest";
  }
  protected:
  explicit DeleteSipCredentialRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSipUsernameFieldNumber = 1,
  };
  // string sip_username = 1;
  void clear_sip_username();
  const std::string& sip_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sip_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sip_username();
  PROTOBUF_NODISCARD std::string* release_sip_username();
  void set_allocated_sip_username(std::string* sip_username);
  private:
  const std::string& _internal_sip_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sip_username(const std::string& value);
  std::string* _internal_mutable_sip_username();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.DeleteSipCredentialRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sip_username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteSipCredentialResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.user.v1.DeleteSipCredentialResponse) */ {
 public:
  inline DeleteSipCredentialResponse() : DeleteSipCredentialResponse(nullptr) {}
  ~DeleteSipCredentialResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteSipCredentialResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSipCredentialResponse(const DeleteSipCredentialResponse& from);
  DeleteSipCredentialResponse(DeleteSipCredentialResponse&& from) noexcept
    : DeleteSipCredentialResponse() {
    *this = ::std::move(from);
  }

  inline DeleteSipCredentialResponse& operator=(const DeleteSipCredentialResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSipCredentialResponse& operator=(DeleteSipCredentialResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSipCredentialResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSipCredentialResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteSipCredentialResponse*>(
               &_DeleteSipCredentialResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DeleteSipCredentialResponse& a, DeleteSipCredentialResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSipCredentialResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSipCredentialResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSipCredentialResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSipCredentialResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSipCredentialResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSipCredentialResponse& from) {
    DeleteSipCredentialResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSipCredentialResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.user.v1.DeleteSipCredentialResponse";
  }
  protected:
  explicit DeleteSipCredentialResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.user.v1.DeleteSipCredentialResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fuser_2fv1_2fuser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Contact

// int32 id = 1;
inline void Contact::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Contact::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Contact::id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Contact.id)
  return _internal_id();
}
inline void Contact::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Contact::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Contact.id)
}

// string user_id = 2;
inline void Contact::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Contact::user_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Contact.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contact::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Contact.user_id)
}
inline std::string* Contact::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.Contact.user_id)
  return _s;
}
inline const std::string& Contact::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Contact::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Contact::release_user_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.Contact.user_id)
  return _impl_.user_id_.Release();
}
inline void Contact::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.Contact.user_id)
}

// string contact_type = 3;
inline void Contact::clear_contact_type() {
  _impl_.contact_type_.ClearToEmpty();
}
inline const std::string& Contact::contact_type() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Contact.contact_type)
  return _internal_contact_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contact::set_contact_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contact_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Contact.contact_type)
}
inline std::string* Contact::mutable_contact_type() {
  std::string* _s = _internal_mutable_contact_type();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.Contact.contact_type)
  return _s;
}
inline const std::string& Contact::_internal_contact_type() const {
  return _impl_.contact_type_.Get();
}
inline void Contact::_internal_set_contact_type(const std::string& value) {
  
  _impl_.contact_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_contact_type() {
  
  return _impl_.contact_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Contact::release_contact_type() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.Contact.contact_type)
  return _impl_.contact_type_.Release();
}
inline void Contact::set_allocated_contact_type(std::string* contact_type) {
  if (contact_type != nullptr) {
    
  } else {
    
  }
  _impl_.contact_type_.SetAllocated(contact_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contact_type_.IsDefault()) {
    _impl_.contact_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.Contact.contact_type)
}

// string contact_value = 4;
inline void Contact::clear_contact_value() {
  _impl_.contact_value_.ClearToEmpty();
}
inline const std::string& Contact::contact_value() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Contact.contact_value)
  return _internal_contact_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contact::set_contact_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contact_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Contact.contact_value)
}
inline std::string* Contact::mutable_contact_value() {
  std::string* _s = _internal_mutable_contact_value();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.Contact.contact_value)
  return _s;
}
inline const std::string& Contact::_internal_contact_value() const {
  return _impl_.contact_value_.Get();
}
inline void Contact::_internal_set_contact_value(const std::string& value) {
  
  _impl_.contact_value_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_contact_value() {
  
  return _impl_.contact_value_.Mutable(GetArenaForAllocation());
}
inline std::string* Contact::release_contact_value() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.Contact.contact_value)
  return _impl_.contact_value_.Release();
}
inline void Contact::set_allocated_contact_value(std::string* contact_value) {
  if (contact_value != nullptr) {
    
  } else {
    
  }
  _impl_.contact_value_.SetAllocated(contact_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contact_value_.IsDefault()) {
    _impl_.contact_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.Contact.contact_value)
}

// bool is_primary = 5;
inline void Contact::clear_is_primary() {
  _impl_.is_primary_ = false;
}
inline bool Contact::_internal_is_primary() const {
  return _impl_.is_primary_;
}
inline bool Contact::is_primary() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Contact.is_primary)
  return _internal_is_primary();
}
inline void Contact::_internal_set_is_primary(bool value) {
  
  _impl_.is_primary_ = value;
}
inline void Contact::set_is_primary(bool value) {
  _internal_set_is_primary(value);
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Contact.is_primary)
}

// -------------------------------------------------------------------

// User

// string id = 1;
inline void User::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.User.id)
}
inline std::string* User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  return _impl_.id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.User.id)
  return _impl_.id_.Release();
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.User.id)
}

// optional string name = 2;
inline bool User::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool User::has_name() const {
  return _internal_has_name();
}
inline void User::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& User::name() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.User.name)
}
inline std::string* User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.User.name)
  return _s;
}
inline const std::string& User::_internal_name() const {
  return _impl_.name_.Get();
}
inline void User::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.User.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.User.name)
}

// string tenant_id = 3;
inline void User::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& User::tenant_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.User.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.User.tenant_id)
}
inline std::string* User::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.User.tenant_id)
  return _s;
}
inline const std::string& User::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void User::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_tenant_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.User.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void User::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.User.tenant_id)
}

// string user_type = 4;
inline void User::clear_user_type() {
  _impl_.user_type_.ClearToEmpty();
}
inline const std::string& User::user_type() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.User.user_type)
  return _internal_user_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_user_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.User.user_type)
}
inline std::string* User::mutable_user_type() {
  std::string* _s = _internal_mutable_user_type();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.User.user_type)
  return _s;
}
inline const std::string& User::_internal_user_type() const {
  return _impl_.user_type_.Get();
}
inline void User::_internal_set_user_type(const std::string& value) {
  
  _impl_.user_type_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_user_type() {
  
  return _impl_.user_type_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_user_type() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.User.user_type)
  return _impl_.user_type_.Release();
}
inline void User::set_allocated_user_type(std::string* user_type) {
  if (user_type != nullptr) {
    
  } else {
    
  }
  _impl_.user_type_.SetAllocated(user_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_type_.IsDefault()) {
    _impl_.user_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.User.user_type)
}

// repeated .sentiric.user.v1.Contact contacts = 5;
inline int User::_internal_contacts_size() const {
  return _impl_.contacts_.size();
}
inline int User::contacts_size() const {
  return _internal_contacts_size();
}
inline void User::clear_contacts() {
  _impl_.contacts_.Clear();
}
inline ::sentiric::user::v1::Contact* User::mutable_contacts(int index) {
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.User.contacts)
  return _impl_.contacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::user::v1::Contact >*
User::mutable_contacts() {
  // @@protoc_insertion_point(field_mutable_list:sentiric.user.v1.User.contacts)
  return &_impl_.contacts_;
}
inline const ::sentiric::user::v1::Contact& User::_internal_contacts(int index) const {
  return _impl_.contacts_.Get(index);
}
inline const ::sentiric::user::v1::Contact& User::contacts(int index) const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.User.contacts)
  return _internal_contacts(index);
}
inline ::sentiric::user::v1::Contact* User::_internal_add_contacts() {
  return _impl_.contacts_.Add();
}
inline ::sentiric::user::v1::Contact* User::add_contacts() {
  ::sentiric::user::v1::Contact* _add = _internal_add_contacts();
  // @@protoc_insertion_point(field_add:sentiric.user.v1.User.contacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::user::v1::Contact >&
User::contacts() const {
  // @@protoc_insertion_point(field_list:sentiric.user.v1.User.contacts)
  return _impl_.contacts_;
}

// optional string preferred_language_code = 6;
inline bool User::_internal_has_preferred_language_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool User::has_preferred_language_code() const {
  return _internal_has_preferred_language_code();
}
inline void User::clear_preferred_language_code() {
  _impl_.preferred_language_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& User::preferred_language_code() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.User.preferred_language_code)
  return _internal_preferred_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_preferred_language_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.preferred_language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.User.preferred_language_code)
}
inline std::string* User::mutable_preferred_language_code() {
  std::string* _s = _internal_mutable_preferred_language_code();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.User.preferred_language_code)
  return _s;
}
inline const std::string& User::_internal_preferred_language_code() const {
  return _impl_.preferred_language_code_.Get();
}
inline void User::_internal_set_preferred_language_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.preferred_language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_preferred_language_code() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.preferred_language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_preferred_language_code() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.User.preferred_language_code)
  if (!_internal_has_preferred_language_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.preferred_language_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preferred_language_code_.IsDefault()) {
    _impl_.preferred_language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_preferred_language_code(std::string* preferred_language_code) {
  if (preferred_language_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.preferred_language_code_.SetAllocated(preferred_language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preferred_language_code_.IsDefault()) {
    _impl_.preferred_language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.User.preferred_language_code)
}

// -------------------------------------------------------------------

// Tenant

// string id = 1;
inline void Tenant::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Tenant::id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Tenant.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tenant::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Tenant.id)
}
inline std::string* Tenant::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.Tenant.id)
  return _s;
}
inline const std::string& Tenant::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Tenant::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Tenant::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Tenant::release_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.Tenant.id)
  return _impl_.id_.Release();
}
inline void Tenant::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.Tenant.id)
}

// string name = 2;
inline void Tenant::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Tenant::name() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Tenant.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tenant::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Tenant.name)
}
inline std::string* Tenant::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.Tenant.name)
  return _s;
}
inline const std::string& Tenant::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Tenant::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Tenant::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Tenant::release_name() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.Tenant.name)
  return _impl_.name_.Release();
}
inline void Tenant::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.Tenant.name)
}

// string domain = 3;
inline void Tenant::clear_domain() {
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& Tenant::domain() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Tenant.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tenant::set_domain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Tenant.domain)
}
inline std::string* Tenant::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.Tenant.domain)
  return _s;
}
inline const std::string& Tenant::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void Tenant::_internal_set_domain(const std::string& value) {
  
  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* Tenant::_internal_mutable_domain() {
  
  return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* Tenant::release_domain() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.Tenant.domain)
  return _impl_.domain_.Release();
}
inline void Tenant::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.Tenant.domain)
}

// string primary_language_code = 4;
inline void Tenant::clear_primary_language_code() {
  _impl_.primary_language_code_.ClearToEmpty();
}
inline const std::string& Tenant::primary_language_code() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.Tenant.primary_language_code)
  return _internal_primary_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tenant::set_primary_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.primary_language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.Tenant.primary_language_code)
}
inline std::string* Tenant::mutable_primary_language_code() {
  std::string* _s = _internal_mutable_primary_language_code();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.Tenant.primary_language_code)
  return _s;
}
inline const std::string& Tenant::_internal_primary_language_code() const {
  return _impl_.primary_language_code_.Get();
}
inline void Tenant::_internal_set_primary_language_code(const std::string& value) {
  
  _impl_.primary_language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Tenant::_internal_mutable_primary_language_code() {
  
  return _impl_.primary_language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Tenant::release_primary_language_code() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.Tenant.primary_language_code)
  return _impl_.primary_language_code_.Release();
}
inline void Tenant::set_allocated_primary_language_code(std::string* primary_language_code) {
  if (primary_language_code != nullptr) {
    
  } else {
    
  }
  _impl_.primary_language_code_.SetAllocated(primary_language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_language_code_.IsDefault()) {
    _impl_.primary_language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.Tenant.primary_language_code)
}

// -------------------------------------------------------------------

// GetUserRequest

// string user_id = 1;
inline void GetUserRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.GetUserRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.GetUserRequest.user_id)
}
inline std::string* GetUserRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.GetUserRequest.user_id)
  return _s;
}
inline const std::string& GetUserRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetUserRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.GetUserRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void GetUserRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.GetUserRequest.user_id)
}

// -------------------------------------------------------------------

// GetUserResponse

// .sentiric.user.v1.User user = 1;
inline bool GetUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool GetUserResponse::has_user() const {
  return _internal_has_user();
}
inline void GetUserResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sentiric::user::v1::User& GetUserResponse::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& GetUserResponse::user() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.GetUserResponse.user)
  return _internal_user();
}
inline void GetUserResponse::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.GetUserResponse.user)
}
inline ::sentiric::user::v1::User* GetUserResponse::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* GetUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.GetUserResponse.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* GetUserResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* GetUserResponse::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.GetUserResponse.user)
  return _msg;
}
inline void GetUserResponse::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.GetUserResponse.user)
}

// -------------------------------------------------------------------

// FindUserByContactRequest

// string contact_type = 1;
inline void FindUserByContactRequest::clear_contact_type() {
  _impl_.contact_type_.ClearToEmpty();
}
inline const std::string& FindUserByContactRequest::contact_type() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.FindUserByContactRequest.contact_type)
  return _internal_contact_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindUserByContactRequest::set_contact_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contact_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.FindUserByContactRequest.contact_type)
}
inline std::string* FindUserByContactRequest::mutable_contact_type() {
  std::string* _s = _internal_mutable_contact_type();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.FindUserByContactRequest.contact_type)
  return _s;
}
inline const std::string& FindUserByContactRequest::_internal_contact_type() const {
  return _impl_.contact_type_.Get();
}
inline void FindUserByContactRequest::_internal_set_contact_type(const std::string& value) {
  
  _impl_.contact_type_.Set(value, GetArenaForAllocation());
}
inline std::string* FindUserByContactRequest::_internal_mutable_contact_type() {
  
  return _impl_.contact_type_.Mutable(GetArenaForAllocation());
}
inline std::string* FindUserByContactRequest::release_contact_type() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.FindUserByContactRequest.contact_type)
  return _impl_.contact_type_.Release();
}
inline void FindUserByContactRequest::set_allocated_contact_type(std::string* contact_type) {
  if (contact_type != nullptr) {
    
  } else {
    
  }
  _impl_.contact_type_.SetAllocated(contact_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contact_type_.IsDefault()) {
    _impl_.contact_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.FindUserByContactRequest.contact_type)
}

// string contact_value = 2;
inline void FindUserByContactRequest::clear_contact_value() {
  _impl_.contact_value_.ClearToEmpty();
}
inline const std::string& FindUserByContactRequest::contact_value() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.FindUserByContactRequest.contact_value)
  return _internal_contact_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindUserByContactRequest::set_contact_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contact_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.FindUserByContactRequest.contact_value)
}
inline std::string* FindUserByContactRequest::mutable_contact_value() {
  std::string* _s = _internal_mutable_contact_value();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.FindUserByContactRequest.contact_value)
  return _s;
}
inline const std::string& FindUserByContactRequest::_internal_contact_value() const {
  return _impl_.contact_value_.Get();
}
inline void FindUserByContactRequest::_internal_set_contact_value(const std::string& value) {
  
  _impl_.contact_value_.Set(value, GetArenaForAllocation());
}
inline std::string* FindUserByContactRequest::_internal_mutable_contact_value() {
  
  return _impl_.contact_value_.Mutable(GetArenaForAllocation());
}
inline std::string* FindUserByContactRequest::release_contact_value() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.FindUserByContactRequest.contact_value)
  return _impl_.contact_value_.Release();
}
inline void FindUserByContactRequest::set_allocated_contact_value(std::string* contact_value) {
  if (contact_value != nullptr) {
    
  } else {
    
  }
  _impl_.contact_value_.SetAllocated(contact_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contact_value_.IsDefault()) {
    _impl_.contact_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.FindUserByContactRequest.contact_value)
}

// -------------------------------------------------------------------

// FindUserByContactResponse

// .sentiric.user.v1.User user = 1;
inline bool FindUserByContactResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool FindUserByContactResponse::has_user() const {
  return _internal_has_user();
}
inline void FindUserByContactResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sentiric::user::v1::User& FindUserByContactResponse::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& FindUserByContactResponse::user() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.FindUserByContactResponse.user)
  return _internal_user();
}
inline void FindUserByContactResponse::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.FindUserByContactResponse.user)
}
inline ::sentiric::user::v1::User* FindUserByContactResponse::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* FindUserByContactResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.FindUserByContactResponse.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* FindUserByContactResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* FindUserByContactResponse::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.FindUserByContactResponse.user)
  return _msg;
}
inline void FindUserByContactResponse::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.FindUserByContactResponse.user)
}

// -------------------------------------------------------------------

// CreateUserRequest_InitialContact

// string contact_type = 1;
inline void CreateUserRequest_InitialContact::clear_contact_type() {
  _impl_.contact_type_.ClearToEmpty();
}
inline const std::string& CreateUserRequest_InitialContact::contact_type() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateUserRequest.InitialContact.contact_type)
  return _internal_contact_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateUserRequest_InitialContact::set_contact_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contact_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateUserRequest.InitialContact.contact_type)
}
inline std::string* CreateUserRequest_InitialContact::mutable_contact_type() {
  std::string* _s = _internal_mutable_contact_type();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateUserRequest.InitialContact.contact_type)
  return _s;
}
inline const std::string& CreateUserRequest_InitialContact::_internal_contact_type() const {
  return _impl_.contact_type_.Get();
}
inline void CreateUserRequest_InitialContact::_internal_set_contact_type(const std::string& value) {
  
  _impl_.contact_type_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateUserRequest_InitialContact::_internal_mutable_contact_type() {
  
  return _impl_.contact_type_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateUserRequest_InitialContact::release_contact_type() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateUserRequest.InitialContact.contact_type)
  return _impl_.contact_type_.Release();
}
inline void CreateUserRequest_InitialContact::set_allocated_contact_type(std::string* contact_type) {
  if (contact_type != nullptr) {
    
  } else {
    
  }
  _impl_.contact_type_.SetAllocated(contact_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contact_type_.IsDefault()) {
    _impl_.contact_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateUserRequest.InitialContact.contact_type)
}

// string contact_value = 2;
inline void CreateUserRequest_InitialContact::clear_contact_value() {
  _impl_.contact_value_.ClearToEmpty();
}
inline const std::string& CreateUserRequest_InitialContact::contact_value() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateUserRequest.InitialContact.contact_value)
  return _internal_contact_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateUserRequest_InitialContact::set_contact_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contact_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateUserRequest.InitialContact.contact_value)
}
inline std::string* CreateUserRequest_InitialContact::mutable_contact_value() {
  std::string* _s = _internal_mutable_contact_value();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateUserRequest.InitialContact.contact_value)
  return _s;
}
inline const std::string& CreateUserRequest_InitialContact::_internal_contact_value() const {
  return _impl_.contact_value_.Get();
}
inline void CreateUserRequest_InitialContact::_internal_set_contact_value(const std::string& value) {
  
  _impl_.contact_value_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateUserRequest_InitialContact::_internal_mutable_contact_value() {
  
  return _impl_.contact_value_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateUserRequest_InitialContact::release_contact_value() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateUserRequest.InitialContact.contact_value)
  return _impl_.contact_value_.Release();
}
inline void CreateUserRequest_InitialContact::set_allocated_contact_value(std::string* contact_value) {
  if (contact_value != nullptr) {
    
  } else {
    
  }
  _impl_.contact_value_.SetAllocated(contact_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contact_value_.IsDefault()) {
    _impl_.contact_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateUserRequest.InitialContact.contact_value)
}

// -------------------------------------------------------------------

// CreateUserRequest

// string tenant_id = 1;
inline void CreateUserRequest::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& CreateUserRequest::tenant_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateUserRequest.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateUserRequest::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateUserRequest.tenant_id)
}
inline std::string* CreateUserRequest::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateUserRequest.tenant_id)
  return _s;
}
inline const std::string& CreateUserRequest::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void CreateUserRequest::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateUserRequest::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateUserRequest::release_tenant_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateUserRequest.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void CreateUserRequest::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateUserRequest.tenant_id)
}

// string user_type = 2;
inline void CreateUserRequest::clear_user_type() {
  _impl_.user_type_.ClearToEmpty();
}
inline const std::string& CreateUserRequest::user_type() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateUserRequest.user_type)
  return _internal_user_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateUserRequest::set_user_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateUserRequest.user_type)
}
inline std::string* CreateUserRequest::mutable_user_type() {
  std::string* _s = _internal_mutable_user_type();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateUserRequest.user_type)
  return _s;
}
inline const std::string& CreateUserRequest::_internal_user_type() const {
  return _impl_.user_type_.Get();
}
inline void CreateUserRequest::_internal_set_user_type(const std::string& value) {
  
  _impl_.user_type_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateUserRequest::_internal_mutable_user_type() {
  
  return _impl_.user_type_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateUserRequest::release_user_type() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateUserRequest.user_type)
  return _impl_.user_type_.Release();
}
inline void CreateUserRequest::set_allocated_user_type(std::string* user_type) {
  if (user_type != nullptr) {
    
  } else {
    
  }
  _impl_.user_type_.SetAllocated(user_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_type_.IsDefault()) {
    _impl_.user_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateUserRequest.user_type)
}

// optional string name = 3;
inline bool CreateUserRequest::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateUserRequest::has_name() const {
  return _internal_has_name();
}
inline void CreateUserRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateUserRequest::name() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateUserRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateUserRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateUserRequest.name)
}
inline std::string* CreateUserRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateUserRequest.name)
  return _s;
}
inline const std::string& CreateUserRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateUserRequest::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateUserRequest::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateUserRequest::release_name() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateUserRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateUserRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateUserRequest.name)
}

// .sentiric.user.v1.CreateUserRequest.InitialContact initial_contact = 4;
inline bool CreateUserRequest::_internal_has_initial_contact() const {
  return this != internal_default_instance() && _impl_.initial_contact_ != nullptr;
}
inline bool CreateUserRequest::has_initial_contact() const {
  return _internal_has_initial_contact();
}
inline void CreateUserRequest::clear_initial_contact() {
  if (GetArenaForAllocation() == nullptr && _impl_.initial_contact_ != nullptr) {
    delete _impl_.initial_contact_;
  }
  _impl_.initial_contact_ = nullptr;
}
inline const ::sentiric::user::v1::CreateUserRequest_InitialContact& CreateUserRequest::_internal_initial_contact() const {
  const ::sentiric::user::v1::CreateUserRequest_InitialContact* p = _impl_.initial_contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::CreateUserRequest_InitialContact&>(
      ::sentiric::user::v1::_CreateUserRequest_InitialContact_default_instance_);
}
inline const ::sentiric::user::v1::CreateUserRequest_InitialContact& CreateUserRequest::initial_contact() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateUserRequest.initial_contact)
  return _internal_initial_contact();
}
inline void CreateUserRequest::unsafe_arena_set_allocated_initial_contact(
    ::sentiric::user::v1::CreateUserRequest_InitialContact* initial_contact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_contact_);
  }
  _impl_.initial_contact_ = initial_contact;
  if (initial_contact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.CreateUserRequest.initial_contact)
}
inline ::sentiric::user::v1::CreateUserRequest_InitialContact* CreateUserRequest::release_initial_contact() {
  
  ::sentiric::user::v1::CreateUserRequest_InitialContact* temp = _impl_.initial_contact_;
  _impl_.initial_contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::CreateUserRequest_InitialContact* CreateUserRequest::unsafe_arena_release_initial_contact() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateUserRequest.initial_contact)
  
  ::sentiric::user::v1::CreateUserRequest_InitialContact* temp = _impl_.initial_contact_;
  _impl_.initial_contact_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::CreateUserRequest_InitialContact* CreateUserRequest::_internal_mutable_initial_contact() {
  
  if (_impl_.initial_contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::CreateUserRequest_InitialContact>(GetArenaForAllocation());
    _impl_.initial_contact_ = p;
  }
  return _impl_.initial_contact_;
}
inline ::sentiric::user::v1::CreateUserRequest_InitialContact* CreateUserRequest::mutable_initial_contact() {
  ::sentiric::user::v1::CreateUserRequest_InitialContact* _msg = _internal_mutable_initial_contact();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateUserRequest.initial_contact)
  return _msg;
}
inline void CreateUserRequest::set_allocated_initial_contact(::sentiric::user::v1::CreateUserRequest_InitialContact* initial_contact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.initial_contact_;
  }
  if (initial_contact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initial_contact);
    if (message_arena != submessage_arena) {
      initial_contact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_contact, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.initial_contact_ = initial_contact;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateUserRequest.initial_contact)
}

// optional string preferred_language_code = 5;
inline bool CreateUserRequest::_internal_has_preferred_language_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateUserRequest::has_preferred_language_code() const {
  return _internal_has_preferred_language_code();
}
inline void CreateUserRequest::clear_preferred_language_code() {
  _impl_.preferred_language_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CreateUserRequest::preferred_language_code() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateUserRequest.preferred_language_code)
  return _internal_preferred_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateUserRequest::set_preferred_language_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.preferred_language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateUserRequest.preferred_language_code)
}
inline std::string* CreateUserRequest::mutable_preferred_language_code() {
  std::string* _s = _internal_mutable_preferred_language_code();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateUserRequest.preferred_language_code)
  return _s;
}
inline const std::string& CreateUserRequest::_internal_preferred_language_code() const {
  return _impl_.preferred_language_code_.Get();
}
inline void CreateUserRequest::_internal_set_preferred_language_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.preferred_language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateUserRequest::_internal_mutable_preferred_language_code() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.preferred_language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateUserRequest::release_preferred_language_code() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateUserRequest.preferred_language_code)
  if (!_internal_has_preferred_language_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.preferred_language_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preferred_language_code_.IsDefault()) {
    _impl_.preferred_language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateUserRequest::set_allocated_preferred_language_code(std::string* preferred_language_code) {
  if (preferred_language_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.preferred_language_code_.SetAllocated(preferred_language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preferred_language_code_.IsDefault()) {
    _impl_.preferred_language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateUserRequest.preferred_language_code)
}

// -------------------------------------------------------------------

// CreateUserResponse

// .sentiric.user.v1.User user = 1;
inline bool CreateUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool CreateUserResponse::has_user() const {
  return _internal_has_user();
}
inline void CreateUserResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sentiric::user::v1::User& CreateUserResponse::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& CreateUserResponse::user() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateUserResponse.user)
  return _internal_user();
}
inline void CreateUserResponse::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.CreateUserResponse.user)
}
inline ::sentiric::user::v1::User* CreateUserResponse::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* CreateUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateUserResponse.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* CreateUserResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* CreateUserResponse::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateUserResponse.user)
  return _msg;
}
inline void CreateUserResponse::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateUserResponse.user)
}

// -------------------------------------------------------------------

// UpdateUserRequest

// .sentiric.user.v1.User user = 1;
inline bool UpdateUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UpdateUserRequest::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sentiric::user::v1::User& UpdateUserRequest::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& UpdateUserRequest::user() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.UpdateUserRequest.user)
  return _internal_user();
}
inline void UpdateUserRequest::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.UpdateUserRequest.user)
}
inline ::sentiric::user::v1::User* UpdateUserRequest::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* UpdateUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.UpdateUserRequest.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* UpdateUserRequest::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* UpdateUserRequest::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.UpdateUserRequest.user)
  return _msg;
}
inline void UpdateUserRequest::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.UpdateUserRequest.user)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateUserRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateUserRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateUserRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateUserRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.UpdateUserRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateUserRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.UpdateUserRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateUserRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateUserRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.UpdateUserRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateUserRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateUserRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.UpdateUserRequest.update_mask)
  return _msg;
}
inline void UpdateUserRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.UpdateUserRequest.update_mask)
}

// -------------------------------------------------------------------

// UpdateUserResponse

// .sentiric.user.v1.User user = 1;
inline bool UpdateUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UpdateUserResponse::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sentiric::user::v1::User& UpdateUserResponse::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& UpdateUserResponse::user() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.UpdateUserResponse.user)
  return _internal_user();
}
inline void UpdateUserResponse::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.UpdateUserResponse.user)
}
inline ::sentiric::user::v1::User* UpdateUserResponse::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* UpdateUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.UpdateUserResponse.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* UpdateUserResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* UpdateUserResponse::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.UpdateUserResponse.user)
  return _msg;
}
inline void UpdateUserResponse::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.UpdateUserResponse.user)
}

// -------------------------------------------------------------------

// DeleteUserRequest

// string user_id = 1;
inline void DeleteUserRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& DeleteUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.DeleteUserRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteUserRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.DeleteUserRequest.user_id)
}
inline std::string* DeleteUserRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.DeleteUserRequest.user_id)
  return _s;
}
inline const std::string& DeleteUserRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void DeleteUserRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteUserRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteUserRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.DeleteUserRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void DeleteUserRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.DeleteUserRequest.user_id)
}

// -------------------------------------------------------------------

// DeleteUserResponse

// bool success = 1;
inline void DeleteUserResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool DeleteUserResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool DeleteUserResponse::success() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.DeleteUserResponse.success)
  return _internal_success();
}
inline void DeleteUserResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DeleteUserResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sentiric.user.v1.DeleteUserResponse.success)
}

// -------------------------------------------------------------------

// AddContactRequest

// string user_id = 1;
inline void AddContactRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AddContactRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.AddContactRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddContactRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.AddContactRequest.user_id)
}
inline std::string* AddContactRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.AddContactRequest.user_id)
  return _s;
}
inline const std::string& AddContactRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void AddContactRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddContactRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddContactRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.AddContactRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void AddContactRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.AddContactRequest.user_id)
}

// .sentiric.user.v1.Contact contact = 2;
inline bool AddContactRequest::_internal_has_contact() const {
  return this != internal_default_instance() && _impl_.contact_ != nullptr;
}
inline bool AddContactRequest::has_contact() const {
  return _internal_has_contact();
}
inline void AddContactRequest::clear_contact() {
  if (GetArenaForAllocation() == nullptr && _impl_.contact_ != nullptr) {
    delete _impl_.contact_;
  }
  _impl_.contact_ = nullptr;
}
inline const ::sentiric::user::v1::Contact& AddContactRequest::_internal_contact() const {
  const ::sentiric::user::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::Contact&>(
      ::sentiric::user::v1::_Contact_default_instance_);
}
inline const ::sentiric::user::v1::Contact& AddContactRequest::contact() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.AddContactRequest.contact)
  return _internal_contact();
}
inline void AddContactRequest::unsafe_arena_set_allocated_contact(
    ::sentiric::user::v1::Contact* contact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = contact;
  if (contact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.AddContactRequest.contact)
}
inline ::sentiric::user::v1::Contact* AddContactRequest::release_contact() {
  
  ::sentiric::user::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::Contact* AddContactRequest::unsafe_arena_release_contact() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.AddContactRequest.contact)
  
  ::sentiric::user::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::Contact* AddContactRequest::_internal_mutable_contact() {
  
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::Contact>(GetArenaForAllocation());
    _impl_.contact_ = p;
  }
  return _impl_.contact_;
}
inline ::sentiric::user::v1::Contact* AddContactRequest::mutable_contact() {
  ::sentiric::user::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.AddContactRequest.contact)
  return _msg;
}
inline void AddContactRequest::set_allocated_contact(::sentiric::user::v1::Contact* contact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contact_;
  }
  if (contact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contact);
    if (message_arena != submessage_arena) {
      contact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contact, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contact_ = contact;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.AddContactRequest.contact)
}

// -------------------------------------------------------------------

// AddContactResponse

// .sentiric.user.v1.User user = 1;
inline bool AddContactResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool AddContactResponse::has_user() const {
  return _internal_has_user();
}
inline void AddContactResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sentiric::user::v1::User& AddContactResponse::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& AddContactResponse::user() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.AddContactResponse.user)
  return _internal_user();
}
inline void AddContactResponse::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.AddContactResponse.user)
}
inline ::sentiric::user::v1::User* AddContactResponse::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* AddContactResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.AddContactResponse.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* AddContactResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* AddContactResponse::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.AddContactResponse.user)
  return _msg;
}
inline void AddContactResponse::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.AddContactResponse.user)
}

// -------------------------------------------------------------------

// UpdateContactRequest

// .sentiric.user.v1.Contact contact = 1;
inline bool UpdateContactRequest::_internal_has_contact() const {
  return this != internal_default_instance() && _impl_.contact_ != nullptr;
}
inline bool UpdateContactRequest::has_contact() const {
  return _internal_has_contact();
}
inline void UpdateContactRequest::clear_contact() {
  if (GetArenaForAllocation() == nullptr && _impl_.contact_ != nullptr) {
    delete _impl_.contact_;
  }
  _impl_.contact_ = nullptr;
}
inline const ::sentiric::user::v1::Contact& UpdateContactRequest::_internal_contact() const {
  const ::sentiric::user::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::Contact&>(
      ::sentiric::user::v1::_Contact_default_instance_);
}
inline const ::sentiric::user::v1::Contact& UpdateContactRequest::contact() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.UpdateContactRequest.contact)
  return _internal_contact();
}
inline void UpdateContactRequest::unsafe_arena_set_allocated_contact(
    ::sentiric::user::v1::Contact* contact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = contact;
  if (contact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.UpdateContactRequest.contact)
}
inline ::sentiric::user::v1::Contact* UpdateContactRequest::release_contact() {
  
  ::sentiric::user::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::Contact* UpdateContactRequest::unsafe_arena_release_contact() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.UpdateContactRequest.contact)
  
  ::sentiric::user::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::Contact* UpdateContactRequest::_internal_mutable_contact() {
  
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::Contact>(GetArenaForAllocation());
    _impl_.contact_ = p;
  }
  return _impl_.contact_;
}
inline ::sentiric::user::v1::Contact* UpdateContactRequest::mutable_contact() {
  ::sentiric::user::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.UpdateContactRequest.contact)
  return _msg;
}
inline void UpdateContactRequest::set_allocated_contact(::sentiric::user::v1::Contact* contact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contact_;
  }
  if (contact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contact);
    if (message_arena != submessage_arena) {
      contact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contact, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contact_ = contact;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.UpdateContactRequest.contact)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateContactRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateContactRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateContactRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateContactRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.UpdateContactRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateContactRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.UpdateContactRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateContactRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateContactRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.UpdateContactRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateContactRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateContactRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.UpdateContactRequest.update_mask)
  return _msg;
}
inline void UpdateContactRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.UpdateContactRequest.update_mask)
}

// -------------------------------------------------------------------

// UpdateContactResponse

// .sentiric.user.v1.User user = 1;
inline bool UpdateContactResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UpdateContactResponse::has_user() const {
  return _internal_has_user();
}
inline void UpdateContactResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sentiric::user::v1::User& UpdateContactResponse::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& UpdateContactResponse::user() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.UpdateContactResponse.user)
  return _internal_user();
}
inline void UpdateContactResponse::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.UpdateContactResponse.user)
}
inline ::sentiric::user::v1::User* UpdateContactResponse::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* UpdateContactResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.UpdateContactResponse.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* UpdateContactResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* UpdateContactResponse::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.UpdateContactResponse.user)
  return _msg;
}
inline void UpdateContactResponse::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.UpdateContactResponse.user)
}

// -------------------------------------------------------------------

// DeleteContactRequest

// int32 contact_id = 1;
inline void DeleteContactRequest::clear_contact_id() {
  _impl_.contact_id_ = 0;
}
inline int32_t DeleteContactRequest::_internal_contact_id() const {
  return _impl_.contact_id_;
}
inline int32_t DeleteContactRequest::contact_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.DeleteContactRequest.contact_id)
  return _internal_contact_id();
}
inline void DeleteContactRequest::_internal_set_contact_id(int32_t value) {
  
  _impl_.contact_id_ = value;
}
inline void DeleteContactRequest::set_contact_id(int32_t value) {
  _internal_set_contact_id(value);
  // @@protoc_insertion_point(field_set:sentiric.user.v1.DeleteContactRequest.contact_id)
}

// -------------------------------------------------------------------

// DeleteContactResponse

// .sentiric.user.v1.User user = 1;
inline bool DeleteContactResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool DeleteContactResponse::has_user() const {
  return _internal_has_user();
}
inline void DeleteContactResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::sentiric::user::v1::User& DeleteContactResponse::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& DeleteContactResponse::user() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.DeleteContactResponse.user)
  return _internal_user();
}
inline void DeleteContactResponse::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.user.v1.DeleteContactResponse.user)
}
inline ::sentiric::user::v1::User* DeleteContactResponse::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* DeleteContactResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.DeleteContactResponse.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* DeleteContactResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* DeleteContactResponse::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.DeleteContactResponse.user)
  return _msg;
}
inline void DeleteContactResponse::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.DeleteContactResponse.user)
}

// -------------------------------------------------------------------

// GetSipCredentialsRequest

// string sip_username = 1;
inline void GetSipCredentialsRequest::clear_sip_username() {
  _impl_.sip_username_.ClearToEmpty();
}
inline const std::string& GetSipCredentialsRequest::sip_username() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.GetSipCredentialsRequest.sip_username)
  return _internal_sip_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSipCredentialsRequest::set_sip_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sip_username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.GetSipCredentialsRequest.sip_username)
}
inline std::string* GetSipCredentialsRequest::mutable_sip_username() {
  std::string* _s = _internal_mutable_sip_username();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.GetSipCredentialsRequest.sip_username)
  return _s;
}
inline const std::string& GetSipCredentialsRequest::_internal_sip_username() const {
  return _impl_.sip_username_.Get();
}
inline void GetSipCredentialsRequest::_internal_set_sip_username(const std::string& value) {
  
  _impl_.sip_username_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSipCredentialsRequest::_internal_mutable_sip_username() {
  
  return _impl_.sip_username_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSipCredentialsRequest::release_sip_username() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.GetSipCredentialsRequest.sip_username)
  return _impl_.sip_username_.Release();
}
inline void GetSipCredentialsRequest::set_allocated_sip_username(std::string* sip_username) {
  if (sip_username != nullptr) {
    
  } else {
    
  }
  _impl_.sip_username_.SetAllocated(sip_username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sip_username_.IsDefault()) {
    _impl_.sip_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.GetSipCredentialsRequest.sip_username)
}

// string realm = 2;
inline void GetSipCredentialsRequest::clear_realm() {
  _impl_.realm_.ClearToEmpty();
}
inline const std::string& GetSipCredentialsRequest::realm() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.GetSipCredentialsRequest.realm)
  return _internal_realm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSipCredentialsRequest::set_realm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.realm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.GetSipCredentialsRequest.realm)
}
inline std::string* GetSipCredentialsRequest::mutable_realm() {
  std::string* _s = _internal_mutable_realm();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.GetSipCredentialsRequest.realm)
  return _s;
}
inline const std::string& GetSipCredentialsRequest::_internal_realm() const {
  return _impl_.realm_.Get();
}
inline void GetSipCredentialsRequest::_internal_set_realm(const std::string& value) {
  
  _impl_.realm_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSipCredentialsRequest::_internal_mutable_realm() {
  
  return _impl_.realm_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSipCredentialsRequest::release_realm() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.GetSipCredentialsRequest.realm)
  return _impl_.realm_.Release();
}
inline void GetSipCredentialsRequest::set_allocated_realm(std::string* realm) {
  if (realm != nullptr) {
    
  } else {
    
  }
  _impl_.realm_.SetAllocated(realm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realm_.IsDefault()) {
    _impl_.realm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.GetSipCredentialsRequest.realm)
}

// -------------------------------------------------------------------

// GetSipCredentialsResponse

// string user_id = 1;
inline void GetSipCredentialsResponse::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GetSipCredentialsResponse::user_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.GetSipCredentialsResponse.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSipCredentialsResponse::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.GetSipCredentialsResponse.user_id)
}
inline std::string* GetSipCredentialsResponse::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.GetSipCredentialsResponse.user_id)
  return _s;
}
inline const std::string& GetSipCredentialsResponse::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void GetSipCredentialsResponse::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSipCredentialsResponse::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSipCredentialsResponse::release_user_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.GetSipCredentialsResponse.user_id)
  return _impl_.user_id_.Release();
}
inline void GetSipCredentialsResponse::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.GetSipCredentialsResponse.user_id)
}

// string tenant_id = 2;
inline void GetSipCredentialsResponse::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& GetSipCredentialsResponse::tenant_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.GetSipCredentialsResponse.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSipCredentialsResponse::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.GetSipCredentialsResponse.tenant_id)
}
inline std::string* GetSipCredentialsResponse::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.GetSipCredentialsResponse.tenant_id)
  return _s;
}
inline const std::string& GetSipCredentialsResponse::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void GetSipCredentialsResponse::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSipCredentialsResponse::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSipCredentialsResponse::release_tenant_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.GetSipCredentialsResponse.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void GetSipCredentialsResponse::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.GetSipCredentialsResponse.tenant_id)
}

// string ha1_hash = 3;
inline void GetSipCredentialsResponse::clear_ha1_hash() {
  _impl_.ha1_hash_.ClearToEmpty();
}
inline const std::string& GetSipCredentialsResponse::ha1_hash() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.GetSipCredentialsResponse.ha1_hash)
  return _internal_ha1_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSipCredentialsResponse::set_ha1_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ha1_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.GetSipCredentialsResponse.ha1_hash)
}
inline std::string* GetSipCredentialsResponse::mutable_ha1_hash() {
  std::string* _s = _internal_mutable_ha1_hash();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.GetSipCredentialsResponse.ha1_hash)
  return _s;
}
inline const std::string& GetSipCredentialsResponse::_internal_ha1_hash() const {
  return _impl_.ha1_hash_.Get();
}
inline void GetSipCredentialsResponse::_internal_set_ha1_hash(const std::string& value) {
  
  _impl_.ha1_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSipCredentialsResponse::_internal_mutable_ha1_hash() {
  
  return _impl_.ha1_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSipCredentialsResponse::release_ha1_hash() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.GetSipCredentialsResponse.ha1_hash)
  return _impl_.ha1_hash_.Release();
}
inline void GetSipCredentialsResponse::set_allocated_ha1_hash(std::string* ha1_hash) {
  if (ha1_hash != nullptr) {
    
  } else {
    
  }
  _impl_.ha1_hash_.SetAllocated(ha1_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ha1_hash_.IsDefault()) {
    _impl_.ha1_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.GetSipCredentialsResponse.ha1_hash)
}

// -------------------------------------------------------------------

// CreateSipCredentialRequest

// string user_id = 1;
inline void CreateSipCredentialRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& CreateSipCredentialRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateSipCredentialRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSipCredentialRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateSipCredentialRequest.user_id)
}
inline std::string* CreateSipCredentialRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateSipCredentialRequest.user_id)
  return _s;
}
inline const std::string& CreateSipCredentialRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void CreateSipCredentialRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSipCredentialRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSipCredentialRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateSipCredentialRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void CreateSipCredentialRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateSipCredentialRequest.user_id)
}

// string sip_username = 2;
inline void CreateSipCredentialRequest::clear_sip_username() {
  _impl_.sip_username_.ClearToEmpty();
}
inline const std::string& CreateSipCredentialRequest::sip_username() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateSipCredentialRequest.sip_username)
  return _internal_sip_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSipCredentialRequest::set_sip_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sip_username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateSipCredentialRequest.sip_username)
}
inline std::string* CreateSipCredentialRequest::mutable_sip_username() {
  std::string* _s = _internal_mutable_sip_username();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateSipCredentialRequest.sip_username)
  return _s;
}
inline const std::string& CreateSipCredentialRequest::_internal_sip_username() const {
  return _impl_.sip_username_.Get();
}
inline void CreateSipCredentialRequest::_internal_set_sip_username(const std::string& value) {
  
  _impl_.sip_username_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSipCredentialRequest::_internal_mutable_sip_username() {
  
  return _impl_.sip_username_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSipCredentialRequest::release_sip_username() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateSipCredentialRequest.sip_username)
  return _impl_.sip_username_.Release();
}
inline void CreateSipCredentialRequest::set_allocated_sip_username(std::string* sip_username) {
  if (sip_username != nullptr) {
    
  } else {
    
  }
  _impl_.sip_username_.SetAllocated(sip_username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sip_username_.IsDefault()) {
    _impl_.sip_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateSipCredentialRequest.sip_username)
}

// string password = 3;
inline void CreateSipCredentialRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CreateSipCredentialRequest::password() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateSipCredentialRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSipCredentialRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateSipCredentialRequest.password)
}
inline std::string* CreateSipCredentialRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.CreateSipCredentialRequest.password)
  return _s;
}
inline const std::string& CreateSipCredentialRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CreateSipCredentialRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSipCredentialRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSipCredentialRequest::release_password() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.CreateSipCredentialRequest.password)
  return _impl_.password_.Release();
}
inline void CreateSipCredentialRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.CreateSipCredentialRequest.password)
}

// -------------------------------------------------------------------

// CreateSipCredentialResponse

// bool success = 1;
inline void CreateSipCredentialResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CreateSipCredentialResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CreateSipCredentialResponse::success() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.CreateSipCredentialResponse.success)
  return _internal_success();
}
inline void CreateSipCredentialResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CreateSipCredentialResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sentiric.user.v1.CreateSipCredentialResponse.success)
}

// -------------------------------------------------------------------

// DeleteSipCredentialRequest

// string sip_username = 1;
inline void DeleteSipCredentialRequest::clear_sip_username() {
  _impl_.sip_username_.ClearToEmpty();
}
inline const std::string& DeleteSipCredentialRequest::sip_username() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.DeleteSipCredentialRequest.sip_username)
  return _internal_sip_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSipCredentialRequest::set_sip_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sip_username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.user.v1.DeleteSipCredentialRequest.sip_username)
}
inline std::string* DeleteSipCredentialRequest::mutable_sip_username() {
  std::string* _s = _internal_mutable_sip_username();
  // @@protoc_insertion_point(field_mutable:sentiric.user.v1.DeleteSipCredentialRequest.sip_username)
  return _s;
}
inline const std::string& DeleteSipCredentialRequest::_internal_sip_username() const {
  return _impl_.sip_username_.Get();
}
inline void DeleteSipCredentialRequest::_internal_set_sip_username(const std::string& value) {
  
  _impl_.sip_username_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteSipCredentialRequest::_internal_mutable_sip_username() {
  
  return _impl_.sip_username_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteSipCredentialRequest::release_sip_username() {
  // @@protoc_insertion_point(field_release:sentiric.user.v1.DeleteSipCredentialRequest.sip_username)
  return _impl_.sip_username_.Release();
}
inline void DeleteSipCredentialRequest::set_allocated_sip_username(std::string* sip_username) {
  if (sip_username != nullptr) {
    
  } else {
    
  }
  _impl_.sip_username_.SetAllocated(sip_username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sip_username_.IsDefault()) {
    _impl_.sip_username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.user.v1.DeleteSipCredentialRequest.sip_username)
}

// -------------------------------------------------------------------

// DeleteSipCredentialResponse

// bool success = 1;
inline void DeleteSipCredentialResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool DeleteSipCredentialResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool DeleteSipCredentialResponse::success() const {
  // @@protoc_insertion_point(field_get:sentiric.user.v1.DeleteSipCredentialResponse.success)
  return _internal_success();
}
inline void DeleteSipCredentialResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DeleteSipCredentialResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sentiric.user.v1.DeleteSipCredentialResponse.success)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace user
}  // namespace sentiric

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sentiric_2fuser_2fv1_2fuser_2eproto
