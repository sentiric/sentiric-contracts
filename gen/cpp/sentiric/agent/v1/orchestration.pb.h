// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sentiric/agent/v1/orchestration.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sentiric_2fagent_2fv1_2forchestration_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sentiric_2fagent_2fv1_2forchestration_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sentiric/data/v1/context.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sentiric_2fagent_2fv1_2forchestration_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sentiric_2fagent_2fv1_2forchestration_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sentiric_2fagent_2fv1_2forchestration_2eproto;
namespace sentiric {
namespace agent {
namespace v1 {
class ProcessCallStartRequest;
struct ProcessCallStartRequestDefaultTypeInternal;
extern ProcessCallStartRequestDefaultTypeInternal _ProcessCallStartRequest_default_instance_;
class ProcessCallStartResponse;
struct ProcessCallStartResponseDefaultTypeInternal;
extern ProcessCallStartResponseDefaultTypeInternal _ProcessCallStartResponse_default_instance_;
class ProcessManualDialRequest;
struct ProcessManualDialRequestDefaultTypeInternal;
extern ProcessManualDialRequestDefaultTypeInternal _ProcessManualDialRequest_default_instance_;
class ProcessManualDialResponse;
struct ProcessManualDialResponseDefaultTypeInternal;
extern ProcessManualDialResponseDefaultTypeInternal _ProcessManualDialResponse_default_instance_;
class ProcessSagaStepRequest;
struct ProcessSagaStepRequestDefaultTypeInternal;
extern ProcessSagaStepRequestDefaultTypeInternal _ProcessSagaStepRequest_default_instance_;
class ProcessSagaStepResponse;
struct ProcessSagaStepResponseDefaultTypeInternal;
extern ProcessSagaStepResponseDefaultTypeInternal _ProcessSagaStepResponse_default_instance_;
}  // namespace v1
}  // namespace agent
}  // namespace sentiric
PROTOBUF_NAMESPACE_OPEN
template<> ::sentiric::agent::v1::ProcessCallStartRequest* Arena::CreateMaybeMessage<::sentiric::agent::v1::ProcessCallStartRequest>(Arena*);
template<> ::sentiric::agent::v1::ProcessCallStartResponse* Arena::CreateMaybeMessage<::sentiric::agent::v1::ProcessCallStartResponse>(Arena*);
template<> ::sentiric::agent::v1::ProcessManualDialRequest* Arena::CreateMaybeMessage<::sentiric::agent::v1::ProcessManualDialRequest>(Arena*);
template<> ::sentiric::agent::v1::ProcessManualDialResponse* Arena::CreateMaybeMessage<::sentiric::agent::v1::ProcessManualDialResponse>(Arena*);
template<> ::sentiric::agent::v1::ProcessSagaStepRequest* Arena::CreateMaybeMessage<::sentiric::agent::v1::ProcessSagaStepRequest>(Arena*);
template<> ::sentiric::agent::v1::ProcessSagaStepResponse* Arena::CreateMaybeMessage<::sentiric::agent::v1::ProcessSagaStepResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sentiric {
namespace agent {
namespace v1 {

// ===================================================================

class ProcessManualDialRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.agent.v1.ProcessManualDialRequest) */ {
 public:
  inline ProcessManualDialRequest() : ProcessManualDialRequest(nullptr) {}
  ~ProcessManualDialRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessManualDialRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessManualDialRequest(const ProcessManualDialRequest& from);
  ProcessManualDialRequest(ProcessManualDialRequest&& from) noexcept
    : ProcessManualDialRequest() {
    *this = ::std::move(from);
  }

  inline ProcessManualDialRequest& operator=(const ProcessManualDialRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessManualDialRequest& operator=(ProcessManualDialRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessManualDialRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessManualDialRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessManualDialRequest*>(
               &_ProcessManualDialRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ProcessManualDialRequest& a, ProcessManualDialRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessManualDialRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessManualDialRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessManualDialRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessManualDialRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessManualDialRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessManualDialRequest& from) {
    ProcessManualDialRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessManualDialRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.agent.v1.ProcessManualDialRequest";
  }
  protected:
  explicit ProcessManualDialRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationNumberFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kTenantIdFieldNumber = 3,
  };
  // string destination_number = 1;
  void clear_destination_number();
  const std::string& destination_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination_number();
  PROTOBUF_NODISCARD std::string* release_destination_number();
  void set_allocated_destination_number(std::string* destination_number);
  private:
  const std::string& _internal_destination_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_number(const std::string& value);
  std::string* _internal_mutable_destination_number();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string tenant_id = 3;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.agent.v1.ProcessManualDialRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fagent_2fv1_2forchestration_2eproto;
};
// -------------------------------------------------------------------

class ProcessManualDialResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.agent.v1.ProcessManualDialResponse) */ {
 public:
  inline ProcessManualDialResponse() : ProcessManualDialResponse(nullptr) {}
  ~ProcessManualDialResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessManualDialResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessManualDialResponse(const ProcessManualDialResponse& from);
  ProcessManualDialResponse(ProcessManualDialResponse&& from) noexcept
    : ProcessManualDialResponse() {
    *this = ::std::move(from);
  }

  inline ProcessManualDialResponse& operator=(const ProcessManualDialResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessManualDialResponse& operator=(ProcessManualDialResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessManualDialResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessManualDialResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessManualDialResponse*>(
               &_ProcessManualDialResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProcessManualDialResponse& a, ProcessManualDialResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessManualDialResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessManualDialResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessManualDialResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessManualDialResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessManualDialResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessManualDialResponse& from) {
    ProcessManualDialResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessManualDialResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.agent.v1.ProcessManualDialResponse";
  }
  protected:
  explicit ProcessManualDialResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallIdFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kAcceptedFieldNumber = 1,
  };
  // string call_id = 2;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool accepted = 1;
  void clear_accepted();
  bool accepted() const;
  void set_accepted(bool value);
  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.agent.v1.ProcessManualDialResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool accepted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fagent_2fv1_2forchestration_2eproto;
};
// -------------------------------------------------------------------

class ProcessCallStartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.agent.v1.ProcessCallStartRequest) */ {
 public:
  inline ProcessCallStartRequest() : ProcessCallStartRequest(nullptr) {}
  ~ProcessCallStartRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessCallStartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessCallStartRequest(const ProcessCallStartRequest& from);
  ProcessCallStartRequest(ProcessCallStartRequest&& from) noexcept
    : ProcessCallStartRequest() {
    *this = ::std::move(from);
  }

  inline ProcessCallStartRequest& operator=(const ProcessCallStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessCallStartRequest& operator=(ProcessCallStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessCallStartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessCallStartRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessCallStartRequest*>(
               &_ProcessCallStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProcessCallStartRequest& a, ProcessCallStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessCallStartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessCallStartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessCallStartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessCallStartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessCallStartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessCallStartRequest& from) {
    ProcessCallStartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessCallStartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.agent.v1.ProcessCallStartRequest";
  }
  protected:
  explicit ProcessCallStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallIdFieldNumber = 1,
    kDialplanIdFieldNumber = 2,
    kCallerNumberFieldNumber = 3,
  };
  // string call_id = 1;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // string dialplan_id = 2;
  void clear_dialplan_id();
  const std::string& dialplan_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dialplan_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dialplan_id();
  PROTOBUF_NODISCARD std::string* release_dialplan_id();
  void set_allocated_dialplan_id(std::string* dialplan_id);
  private:
  const std::string& _internal_dialplan_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialplan_id(const std::string& value);
  std::string* _internal_mutable_dialplan_id();
  public:

  // string caller_number = 3;
  void clear_caller_number();
  const std::string& caller_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller_number();
  PROTOBUF_NODISCARD std::string* release_caller_number();
  void set_allocated_caller_number(std::string* caller_number);
  private:
  const std::string& _internal_caller_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller_number(const std::string& value);
  std::string* _internal_mutable_caller_number();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.agent.v1.ProcessCallStartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dialplan_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fagent_2fv1_2forchestration_2eproto;
};
// -------------------------------------------------------------------

class ProcessCallStartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.agent.v1.ProcessCallStartResponse) */ {
 public:
  inline ProcessCallStartResponse() : ProcessCallStartResponse(nullptr) {}
  ~ProcessCallStartResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessCallStartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessCallStartResponse(const ProcessCallStartResponse& from);
  ProcessCallStartResponse(ProcessCallStartResponse&& from) noexcept
    : ProcessCallStartResponse() {
    *this = ::std::move(from);
  }

  inline ProcessCallStartResponse& operator=(const ProcessCallStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessCallStartResponse& operator=(ProcessCallStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessCallStartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessCallStartResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessCallStartResponse*>(
               &_ProcessCallStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProcessCallStartResponse& a, ProcessCallStartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessCallStartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessCallStartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessCallStartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessCallStartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessCallStartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessCallStartResponse& from) {
    ProcessCallStartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessCallStartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.agent.v1.ProcessCallStartResponse";
  }
  protected:
  explicit ProcessCallStartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitiatedFieldNumber = 1,
  };
  // bool initiated = 1;
  void clear_initiated();
  bool initiated() const;
  void set_initiated(bool value);
  private:
  bool _internal_initiated() const;
  void _internal_set_initiated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.agent.v1.ProcessCallStartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool initiated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fagent_2fv1_2forchestration_2eproto;
};
// -------------------------------------------------------------------

class ProcessSagaStepRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.agent.v1.ProcessSagaStepRequest) */ {
 public:
  inline ProcessSagaStepRequest() : ProcessSagaStepRequest(nullptr) {}
  ~ProcessSagaStepRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessSagaStepRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessSagaStepRequest(const ProcessSagaStepRequest& from);
  ProcessSagaStepRequest(ProcessSagaStepRequest&& from) noexcept
    : ProcessSagaStepRequest() {
    *this = ::std::move(from);
  }

  inline ProcessSagaStepRequest& operator=(const ProcessSagaStepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessSagaStepRequest& operator=(ProcessSagaStepRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessSagaStepRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessSagaStepRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessSagaStepRequest*>(
               &_ProcessSagaStepRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ProcessSagaStepRequest& a, ProcessSagaStepRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessSagaStepRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessSagaStepRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessSagaStepRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessSagaStepRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessSagaStepRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessSagaStepRequest& from) {
    ProcessSagaStepRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessSagaStepRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.agent.v1.ProcessSagaStepRequest";
  }
  protected:
  explicit ProcessSagaStepRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSagaIdFieldNumber = 1,
    kStepNameFieldNumber = 2,
    kContextFieldNumber = 3,
  };
  // string saga_id = 1;
  void clear_saga_id();
  const std::string& saga_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_saga_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_saga_id();
  PROTOBUF_NODISCARD std::string* release_saga_id();
  void set_allocated_saga_id(std::string* saga_id);
  private:
  const std::string& _internal_saga_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_saga_id(const std::string& value);
  std::string* _internal_mutable_saga_id();
  public:

  // string step_name = 2;
  void clear_step_name();
  const std::string& step_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_name();
  PROTOBUF_NODISCARD std::string* release_step_name();
  void set_allocated_step_name(std::string* step_name);
  private:
  const std::string& _internal_step_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_name(const std::string& value);
  std::string* _internal_mutable_step_name();
  public:

  // .sentiric.data.v1.CallContext context = 3;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::sentiric::data::v1::CallContext& context() const;
  PROTOBUF_NODISCARD ::sentiric::data::v1::CallContext* release_context();
  ::sentiric::data::v1::CallContext* mutable_context();
  void set_allocated_context(::sentiric::data::v1::CallContext* context);
  private:
  const ::sentiric::data::v1::CallContext& _internal_context() const;
  ::sentiric::data::v1::CallContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::sentiric::data::v1::CallContext* context);
  ::sentiric::data::v1::CallContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:sentiric.agent.v1.ProcessSagaStepRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr saga_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_name_;
    ::sentiric::data::v1::CallContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fagent_2fv1_2forchestration_2eproto;
};
// -------------------------------------------------------------------

class ProcessSagaStepResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.agent.v1.ProcessSagaStepResponse) */ {
 public:
  inline ProcessSagaStepResponse() : ProcessSagaStepResponse(nullptr) {}
  ~ProcessSagaStepResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessSagaStepResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessSagaStepResponse(const ProcessSagaStepResponse& from);
  ProcessSagaStepResponse(ProcessSagaStepResponse&& from) noexcept
    : ProcessSagaStepResponse() {
    *this = ::std::move(from);
  }

  inline ProcessSagaStepResponse& operator=(const ProcessSagaStepResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessSagaStepResponse& operator=(ProcessSagaStepResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessSagaStepResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessSagaStepResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessSagaStepResponse*>(
               &_ProcessSagaStepResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProcessSagaStepResponse& a, ProcessSagaStepResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessSagaStepResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessSagaStepResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessSagaStepResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessSagaStepResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessSagaStepResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessSagaStepResponse& from) {
    ProcessSagaStepResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessSagaStepResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.agent.v1.ProcessSagaStepResponse";
  }
  protected:
  explicit ProcessSagaStepResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompletedFieldNumber = 1,
  };
  // bool completed = 1;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.agent.v1.ProcessSagaStepResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool completed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fagent_2fv1_2forchestration_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProcessManualDialRequest

// string destination_number = 1;
inline void ProcessManualDialRequest::clear_destination_number() {
  _impl_.destination_number_.ClearToEmpty();
}
inline const std::string& ProcessManualDialRequest::destination_number() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessManualDialRequest.destination_number)
  return _internal_destination_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessManualDialRequest::set_destination_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessManualDialRequest.destination_number)
}
inline std::string* ProcessManualDialRequest::mutable_destination_number() {
  std::string* _s = _internal_mutable_destination_number();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessManualDialRequest.destination_number)
  return _s;
}
inline const std::string& ProcessManualDialRequest::_internal_destination_number() const {
  return _impl_.destination_number_.Get();
}
inline void ProcessManualDialRequest::_internal_set_destination_number(const std::string& value) {
  
  _impl_.destination_number_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessManualDialRequest::_internal_mutable_destination_number() {
  
  return _impl_.destination_number_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessManualDialRequest::release_destination_number() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessManualDialRequest.destination_number)
  return _impl_.destination_number_.Release();
}
inline void ProcessManualDialRequest::set_allocated_destination_number(std::string* destination_number) {
  if (destination_number != nullptr) {
    
  } else {
    
  }
  _impl_.destination_number_.SetAllocated(destination_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_number_.IsDefault()) {
    _impl_.destination_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessManualDialRequest.destination_number)
}

// string user_id = 2;
inline void ProcessManualDialRequest::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ProcessManualDialRequest::user_id() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessManualDialRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessManualDialRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessManualDialRequest.user_id)
}
inline std::string* ProcessManualDialRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessManualDialRequest.user_id)
  return _s;
}
inline const std::string& ProcessManualDialRequest::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ProcessManualDialRequest::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessManualDialRequest::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessManualDialRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessManualDialRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void ProcessManualDialRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessManualDialRequest.user_id)
}

// string tenant_id = 3;
inline void ProcessManualDialRequest::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& ProcessManualDialRequest::tenant_id() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessManualDialRequest.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessManualDialRequest::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessManualDialRequest.tenant_id)
}
inline std::string* ProcessManualDialRequest::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessManualDialRequest.tenant_id)
  return _s;
}
inline const std::string& ProcessManualDialRequest::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void ProcessManualDialRequest::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessManualDialRequest::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessManualDialRequest::release_tenant_id() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessManualDialRequest.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void ProcessManualDialRequest::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessManualDialRequest.tenant_id)
}

// -------------------------------------------------------------------

// ProcessManualDialResponse

// bool accepted = 1;
inline void ProcessManualDialResponse::clear_accepted() {
  _impl_.accepted_ = false;
}
inline bool ProcessManualDialResponse::_internal_accepted() const {
  return _impl_.accepted_;
}
inline bool ProcessManualDialResponse::accepted() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessManualDialResponse.accepted)
  return _internal_accepted();
}
inline void ProcessManualDialResponse::_internal_set_accepted(bool value) {
  
  _impl_.accepted_ = value;
}
inline void ProcessManualDialResponse::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessManualDialResponse.accepted)
}

// string call_id = 2;
inline void ProcessManualDialResponse::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& ProcessManualDialResponse::call_id() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessManualDialResponse.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessManualDialResponse::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessManualDialResponse.call_id)
}
inline std::string* ProcessManualDialResponse::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessManualDialResponse.call_id)
  return _s;
}
inline const std::string& ProcessManualDialResponse::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void ProcessManualDialResponse::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessManualDialResponse::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessManualDialResponse::release_call_id() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessManualDialResponse.call_id)
  return _impl_.call_id_.Release();
}
inline void ProcessManualDialResponse::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessManualDialResponse.call_id)
}

// string error_message = 3;
inline void ProcessManualDialResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ProcessManualDialResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessManualDialResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessManualDialResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessManualDialResponse.error_message)
}
inline std::string* ProcessManualDialResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessManualDialResponse.error_message)
  return _s;
}
inline const std::string& ProcessManualDialResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ProcessManualDialResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessManualDialResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessManualDialResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessManualDialResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ProcessManualDialResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessManualDialResponse.error_message)
}

// -------------------------------------------------------------------

// ProcessCallStartRequest

// string call_id = 1;
inline void ProcessCallStartRequest::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& ProcessCallStartRequest::call_id() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessCallStartRequest.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessCallStartRequest::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessCallStartRequest.call_id)
}
inline std::string* ProcessCallStartRequest::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessCallStartRequest.call_id)
  return _s;
}
inline const std::string& ProcessCallStartRequest::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void ProcessCallStartRequest::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessCallStartRequest::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessCallStartRequest::release_call_id() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessCallStartRequest.call_id)
  return _impl_.call_id_.Release();
}
inline void ProcessCallStartRequest::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessCallStartRequest.call_id)
}

// string dialplan_id = 2;
inline void ProcessCallStartRequest::clear_dialplan_id() {
  _impl_.dialplan_id_.ClearToEmpty();
}
inline const std::string& ProcessCallStartRequest::dialplan_id() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessCallStartRequest.dialplan_id)
  return _internal_dialplan_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessCallStartRequest::set_dialplan_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dialplan_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessCallStartRequest.dialplan_id)
}
inline std::string* ProcessCallStartRequest::mutable_dialplan_id() {
  std::string* _s = _internal_mutable_dialplan_id();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessCallStartRequest.dialplan_id)
  return _s;
}
inline const std::string& ProcessCallStartRequest::_internal_dialplan_id() const {
  return _impl_.dialplan_id_.Get();
}
inline void ProcessCallStartRequest::_internal_set_dialplan_id(const std::string& value) {
  
  _impl_.dialplan_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessCallStartRequest::_internal_mutable_dialplan_id() {
  
  return _impl_.dialplan_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessCallStartRequest::release_dialplan_id() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessCallStartRequest.dialplan_id)
  return _impl_.dialplan_id_.Release();
}
inline void ProcessCallStartRequest::set_allocated_dialplan_id(std::string* dialplan_id) {
  if (dialplan_id != nullptr) {
    
  } else {
    
  }
  _impl_.dialplan_id_.SetAllocated(dialplan_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dialplan_id_.IsDefault()) {
    _impl_.dialplan_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessCallStartRequest.dialplan_id)
}

// string caller_number = 3;
inline void ProcessCallStartRequest::clear_caller_number() {
  _impl_.caller_number_.ClearToEmpty();
}
inline const std::string& ProcessCallStartRequest::caller_number() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessCallStartRequest.caller_number)
  return _internal_caller_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessCallStartRequest::set_caller_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.caller_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessCallStartRequest.caller_number)
}
inline std::string* ProcessCallStartRequest::mutable_caller_number() {
  std::string* _s = _internal_mutable_caller_number();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessCallStartRequest.caller_number)
  return _s;
}
inline const std::string& ProcessCallStartRequest::_internal_caller_number() const {
  return _impl_.caller_number_.Get();
}
inline void ProcessCallStartRequest::_internal_set_caller_number(const std::string& value) {
  
  _impl_.caller_number_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessCallStartRequest::_internal_mutable_caller_number() {
  
  return _impl_.caller_number_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessCallStartRequest::release_caller_number() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessCallStartRequest.caller_number)
  return _impl_.caller_number_.Release();
}
inline void ProcessCallStartRequest::set_allocated_caller_number(std::string* caller_number) {
  if (caller_number != nullptr) {
    
  } else {
    
  }
  _impl_.caller_number_.SetAllocated(caller_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caller_number_.IsDefault()) {
    _impl_.caller_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessCallStartRequest.caller_number)
}

// -------------------------------------------------------------------

// ProcessCallStartResponse

// bool initiated = 1;
inline void ProcessCallStartResponse::clear_initiated() {
  _impl_.initiated_ = false;
}
inline bool ProcessCallStartResponse::_internal_initiated() const {
  return _impl_.initiated_;
}
inline bool ProcessCallStartResponse::initiated() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessCallStartResponse.initiated)
  return _internal_initiated();
}
inline void ProcessCallStartResponse::_internal_set_initiated(bool value) {
  
  _impl_.initiated_ = value;
}
inline void ProcessCallStartResponse::set_initiated(bool value) {
  _internal_set_initiated(value);
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessCallStartResponse.initiated)
}

// -------------------------------------------------------------------

// ProcessSagaStepRequest

// string saga_id = 1;
inline void ProcessSagaStepRequest::clear_saga_id() {
  _impl_.saga_id_.ClearToEmpty();
}
inline const std::string& ProcessSagaStepRequest::saga_id() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessSagaStepRequest.saga_id)
  return _internal_saga_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessSagaStepRequest::set_saga_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.saga_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessSagaStepRequest.saga_id)
}
inline std::string* ProcessSagaStepRequest::mutable_saga_id() {
  std::string* _s = _internal_mutable_saga_id();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessSagaStepRequest.saga_id)
  return _s;
}
inline const std::string& ProcessSagaStepRequest::_internal_saga_id() const {
  return _impl_.saga_id_.Get();
}
inline void ProcessSagaStepRequest::_internal_set_saga_id(const std::string& value) {
  
  _impl_.saga_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessSagaStepRequest::_internal_mutable_saga_id() {
  
  return _impl_.saga_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessSagaStepRequest::release_saga_id() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessSagaStepRequest.saga_id)
  return _impl_.saga_id_.Release();
}
inline void ProcessSagaStepRequest::set_allocated_saga_id(std::string* saga_id) {
  if (saga_id != nullptr) {
    
  } else {
    
  }
  _impl_.saga_id_.SetAllocated(saga_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.saga_id_.IsDefault()) {
    _impl_.saga_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessSagaStepRequest.saga_id)
}

// string step_name = 2;
inline void ProcessSagaStepRequest::clear_step_name() {
  _impl_.step_name_.ClearToEmpty();
}
inline const std::string& ProcessSagaStepRequest::step_name() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessSagaStepRequest.step_name)
  return _internal_step_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessSagaStepRequest::set_step_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessSagaStepRequest.step_name)
}
inline std::string* ProcessSagaStepRequest::mutable_step_name() {
  std::string* _s = _internal_mutable_step_name();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessSagaStepRequest.step_name)
  return _s;
}
inline const std::string& ProcessSagaStepRequest::_internal_step_name() const {
  return _impl_.step_name_.Get();
}
inline void ProcessSagaStepRequest::_internal_set_step_name(const std::string& value) {
  
  _impl_.step_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessSagaStepRequest::_internal_mutable_step_name() {
  
  return _impl_.step_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessSagaStepRequest::release_step_name() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessSagaStepRequest.step_name)
  return _impl_.step_name_.Release();
}
inline void ProcessSagaStepRequest::set_allocated_step_name(std::string* step_name) {
  if (step_name != nullptr) {
    
  } else {
    
  }
  _impl_.step_name_.SetAllocated(step_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_name_.IsDefault()) {
    _impl_.step_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessSagaStepRequest.step_name)
}

// .sentiric.data.v1.CallContext context = 3;
inline bool ProcessSagaStepRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool ProcessSagaStepRequest::has_context() const {
  return _internal_has_context();
}
inline const ::sentiric::data::v1::CallContext& ProcessSagaStepRequest::_internal_context() const {
  const ::sentiric::data::v1::CallContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::data::v1::CallContext&>(
      ::sentiric::data::v1::_CallContext_default_instance_);
}
inline const ::sentiric::data::v1::CallContext& ProcessSagaStepRequest::context() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessSagaStepRequest.context)
  return _internal_context();
}
inline void ProcessSagaStepRequest::unsafe_arena_set_allocated_context(
    ::sentiric::data::v1::CallContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.agent.v1.ProcessSagaStepRequest.context)
}
inline ::sentiric::data::v1::CallContext* ProcessSagaStepRequest::release_context() {
  
  ::sentiric::data::v1::CallContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::data::v1::CallContext* ProcessSagaStepRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:sentiric.agent.v1.ProcessSagaStepRequest.context)
  
  ::sentiric::data::v1::CallContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::sentiric::data::v1::CallContext* ProcessSagaStepRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::data::v1::CallContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::sentiric::data::v1::CallContext* ProcessSagaStepRequest::mutable_context() {
  ::sentiric::data::v1::CallContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:sentiric.agent.v1.ProcessSagaStepRequest.context)
  return _msg;
}
inline void ProcessSagaStepRequest::set_allocated_context(::sentiric::data::v1::CallContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:sentiric.agent.v1.ProcessSagaStepRequest.context)
}

// -------------------------------------------------------------------

// ProcessSagaStepResponse

// bool completed = 1;
inline void ProcessSagaStepResponse::clear_completed() {
  _impl_.completed_ = false;
}
inline bool ProcessSagaStepResponse::_internal_completed() const {
  return _impl_.completed_;
}
inline bool ProcessSagaStepResponse::completed() const {
  // @@protoc_insertion_point(field_get:sentiric.agent.v1.ProcessSagaStepResponse.completed)
  return _internal_completed();
}
inline void ProcessSagaStepResponse::_internal_set_completed(bool value) {
  
  _impl_.completed_ = value;
}
inline void ProcessSagaStepResponse::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:sentiric.agent.v1.ProcessSagaStepResponse.completed)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace agent
}  // namespace sentiric

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sentiric_2fagent_2fv1_2forchestration_2eproto
