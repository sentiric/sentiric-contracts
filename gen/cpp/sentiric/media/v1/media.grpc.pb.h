// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sentiric/media/v1/media.proto
#ifndef GRPC_sentiric_2fmedia_2fv1_2fmedia_2eproto__INCLUDED
#define GRPC_sentiric_2fmedia_2fv1_2fmedia_2eproto__INCLUDED

#include "sentiric/media/v1/media.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace sentiric {
namespace media {
namespace v1 {

// MediaService, platformun ses giriş/çıkış kapısıdır.
// Hem eski (Unary) hem de yeni nesil (Streaming) ses iletimini destekler.
class MediaService final {
 public:
  static constexpr char const* service_full_name() {
    return "sentiric.media.v1.MediaService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Yeni bir RTP oturumu için dinamik UDP portu tahsis eder.
    virtual ::grpc::Status AllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::sentiric::media::v1::AllocatePortResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::AllocatePortResponse>> AsyncAllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::AllocatePortResponse>>(AsyncAllocatePortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::AllocatePortResponse>> PrepareAsyncAllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::AllocatePortResponse>>(PrepareAsyncAllocatePortRaw(context, request, cq));
    }
    // İş bitince portu serbest bırakır ve karantinaya alır.
    virtual ::grpc::Status ReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::sentiric::media::v1::ReleasePortResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::ReleasePortResponse>> AsyncReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::ReleasePortResponse>>(AsyncReleasePortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::ReleasePortResponse>> PrepareAsyncReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::ReleasePortResponse>>(PrepareAsyncReleasePortRaw(context, request, cq));
    }
    // =================================================================
    // 2. LEGACY (UNARY) OPERASYONLAR 
    // (Agent-Service uyumluluğu için korunmaktadır - DEPRECATED)
    // =================================================================
    //
    // Bir ses dosyasını (URI) veya Base64 veriyi tek seferde çalar.
    // UYARI: Yüksek gecikmeye (latency) neden olabilir.
    virtual ::grpc::Status PlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::sentiric::media::v1::PlayAudioResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::PlayAudioResponse>> AsyncPlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::PlayAudioResponse>>(AsyncPlayAudioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::PlayAudioResponse>> PrepareAsyncPlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::PlayAudioResponse>>(PrepareAsyncPlayAudioRaw(context, request, cq));
    }
    // Canlı sesi dinlemek için stream açar (Tek yönlü: Media -> Client).
    std::unique_ptr< ::grpc::ClientReaderInterface< ::sentiric::media::v1::RecordAudioResponse>> RecordAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::sentiric::media::v1::RecordAudioResponse>>(RecordAudioRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentiric::media::v1::RecordAudioResponse>> AsyncRecordAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentiric::media::v1::RecordAudioResponse>>(AsyncRecordAudioRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentiric::media::v1::RecordAudioResponse>> PrepareAsyncRecordAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::sentiric::media::v1::RecordAudioResponse>>(PrepareAsyncRecordAudioRaw(context, request, cq));
    }
    // Sesi S3/MinIO'ya kaydetmeye başlar.
    virtual ::grpc::Status StartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::sentiric::media::v1::StartRecordingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StartRecordingResponse>> AsyncStartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StartRecordingResponse>>(AsyncStartRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StartRecordingResponse>> PrepareAsyncStartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StartRecordingResponse>>(PrepareAsyncStartRecordingRaw(context, request, cq));
    }
    // Kaydı durdurur ve dosyayı kapatır.
    virtual ::grpc::Status StopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::sentiric::media::v1::StopRecordingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StopRecordingResponse>> AsyncStopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StopRecordingResponse>>(AsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StopRecordingResponse>> PrepareAsyncStopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StopRecordingResponse>>(PrepareAsyncStopRecordingRaw(context, request, cq));
    }
    // =================================================================
    // 3. NEXT-GEN (STREAMING) OPERASYONLAR
    // (Gerçek Zamanlı AI Konuşmaları İçin - ÖNERİLEN)
    // =================================================================
    //
    // [KRİTİK OPTİMİZASYON]
    // TTS'ten gelen ham ses parçalarını (chunks) anlık olarak RTP'ye basar.
    // Dosya biriktirme veya Base64 dönüşümü yapmaz. 
    // TelephonyActionService tarafından kullanılır.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>> StreamAudioToCall(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>>(StreamAudioToCallRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>> AsyncStreamAudioToCall(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>>(AsyncStreamAudioToCallRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>> PrepareAsyncStreamAudioToCall(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>>(PrepareAsyncStreamAudioToCallRaw(context, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Yeni bir RTP oturumu için dinamik UDP portu tahsis eder.
      virtual void AllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest* request, ::sentiric::media::v1::AllocatePortResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest* request, ::sentiric::media::v1::AllocatePortResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // İş bitince portu serbest bırakır ve karantinaya alır.
      virtual void ReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest* request, ::sentiric::media::v1::ReleasePortResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest* request, ::sentiric::media::v1::ReleasePortResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // =================================================================
      // 2. LEGACY (UNARY) OPERASYONLAR 
      // (Agent-Service uyumluluğu için korunmaktadır - DEPRECATED)
      // =================================================================
      //
      // Bir ses dosyasını (URI) veya Base64 veriyi tek seferde çalar.
      // UYARI: Yüksek gecikmeye (latency) neden olabilir.
      virtual void PlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest* request, ::sentiric::media::v1::PlayAudioResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest* request, ::sentiric::media::v1::PlayAudioResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Canlı sesi dinlemek için stream açar (Tek yönlü: Media -> Client).
      virtual void RecordAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest* request, ::grpc::ClientReadReactor< ::sentiric::media::v1::RecordAudioResponse>* reactor) = 0;
      // Sesi S3/MinIO'ya kaydetmeye başlar.
      virtual void StartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest* request, ::sentiric::media::v1::StartRecordingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest* request, ::sentiric::media::v1::StartRecordingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Kaydı durdurur ve dosyayı kapatır.
      virtual void StopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest* request, ::sentiric::media::v1::StopRecordingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest* request, ::sentiric::media::v1::StopRecordingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // =================================================================
      // 3. NEXT-GEN (STREAMING) OPERASYONLAR
      // (Gerçek Zamanlı AI Konuşmaları İçin - ÖNERİLEN)
      // =================================================================
      //
      // [KRİTİK OPTİMİZASYON]
      // TTS'ten gelen ham ses parçalarını (chunks) anlık olarak RTP'ye basar.
      // Dosya biriktirme veya Base64 dönüşümü yapmaz. 
      // TelephonyActionService tarafından kullanılır.
      virtual void StreamAudioToCall(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::sentiric::media::v1::StreamAudioToCallRequest,::sentiric::media::v1::StreamAudioToCallResponse>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::AllocatePortResponse>* AsyncAllocatePortRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::AllocatePortResponse>* PrepareAsyncAllocatePortRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::ReleasePortResponse>* AsyncReleasePortRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::ReleasePortResponse>* PrepareAsyncReleasePortRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::PlayAudioResponse>* AsyncPlayAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::PlayAudioResponse>* PrepareAsyncPlayAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::sentiric::media::v1::RecordAudioResponse>* RecordAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentiric::media::v1::RecordAudioResponse>* AsyncRecordAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::sentiric::media::v1::RecordAudioResponse>* PrepareAsyncRecordAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StartRecordingResponse>* AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StartRecordingResponse>* PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StopRecordingResponse>* AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sentiric::media::v1::StopRecordingResponse>* PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>* StreamAudioToCallRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>* AsyncStreamAudioToCallRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>* PrepareAsyncStreamAudioToCallRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status AllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::sentiric::media::v1::AllocatePortResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::AllocatePortResponse>> AsyncAllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::AllocatePortResponse>>(AsyncAllocatePortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::AllocatePortResponse>> PrepareAsyncAllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::AllocatePortResponse>>(PrepareAsyncAllocatePortRaw(context, request, cq));
    }
    ::grpc::Status ReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::sentiric::media::v1::ReleasePortResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::ReleasePortResponse>> AsyncReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::ReleasePortResponse>>(AsyncReleasePortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::ReleasePortResponse>> PrepareAsyncReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::ReleasePortResponse>>(PrepareAsyncReleasePortRaw(context, request, cq));
    }
    ::grpc::Status PlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::sentiric::media::v1::PlayAudioResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::PlayAudioResponse>> AsyncPlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::PlayAudioResponse>>(AsyncPlayAudioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::PlayAudioResponse>> PrepareAsyncPlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::PlayAudioResponse>>(PrepareAsyncPlayAudioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::sentiric::media::v1::RecordAudioResponse>> RecordAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::sentiric::media::v1::RecordAudioResponse>>(RecordAudioRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentiric::media::v1::RecordAudioResponse>> AsyncRecordAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentiric::media::v1::RecordAudioResponse>>(AsyncRecordAudioRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::sentiric::media::v1::RecordAudioResponse>> PrepareAsyncRecordAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::sentiric::media::v1::RecordAudioResponse>>(PrepareAsyncRecordAudioRaw(context, request, cq));
    }
    ::grpc::Status StartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::sentiric::media::v1::StartRecordingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StartRecordingResponse>> AsyncStartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StartRecordingResponse>>(AsyncStartRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StartRecordingResponse>> PrepareAsyncStartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StartRecordingResponse>>(PrepareAsyncStartRecordingRaw(context, request, cq));
    }
    ::grpc::Status StopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::sentiric::media::v1::StopRecordingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StopRecordingResponse>> AsyncStopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StopRecordingResponse>>(AsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StopRecordingResponse>> PrepareAsyncStopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StopRecordingResponse>>(PrepareAsyncStopRecordingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>> StreamAudioToCall(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>>(StreamAudioToCallRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>> AsyncStreamAudioToCall(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>>(AsyncStreamAudioToCallRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>> PrepareAsyncStreamAudioToCall(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>>(PrepareAsyncStreamAudioToCallRaw(context, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void AllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest* request, ::sentiric::media::v1::AllocatePortResponse* response, std::function<void(::grpc::Status)>) override;
      void AllocatePort(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest* request, ::sentiric::media::v1::AllocatePortResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest* request, ::sentiric::media::v1::ReleasePortResponse* response, std::function<void(::grpc::Status)>) override;
      void ReleasePort(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest* request, ::sentiric::media::v1::ReleasePortResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest* request, ::sentiric::media::v1::PlayAudioResponse* response, std::function<void(::grpc::Status)>) override;
      void PlayAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest* request, ::sentiric::media::v1::PlayAudioResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RecordAudio(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest* request, ::grpc::ClientReadReactor< ::sentiric::media::v1::RecordAudioResponse>* reactor) override;
      void StartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest* request, ::sentiric::media::v1::StartRecordingResponse* response, std::function<void(::grpc::Status)>) override;
      void StartRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest* request, ::sentiric::media::v1::StartRecordingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest* request, ::sentiric::media::v1::StopRecordingResponse* response, std::function<void(::grpc::Status)>) override;
      void StopRecording(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest* request, ::sentiric::media::v1::StopRecordingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamAudioToCall(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::sentiric::media::v1::StreamAudioToCallRequest,::sentiric::media::v1::StreamAudioToCallResponse>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::AllocatePortResponse>* AsyncAllocatePortRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::AllocatePortResponse>* PrepareAsyncAllocatePortRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::AllocatePortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::ReleasePortResponse>* AsyncReleasePortRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::ReleasePortResponse>* PrepareAsyncReleasePortRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::ReleasePortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::PlayAudioResponse>* AsyncPlayAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::PlayAudioResponse>* PrepareAsyncPlayAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::PlayAudioRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::sentiric::media::v1::RecordAudioResponse>* RecordAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request) override;
    ::grpc::ClientAsyncReader< ::sentiric::media::v1::RecordAudioResponse>* AsyncRecordAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::sentiric::media::v1::RecordAudioResponse>* PrepareAsyncRecordAudioRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::RecordAudioRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StartRecordingResponse>* AsyncStartRecordingRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StartRecordingResponse>* PrepareAsyncStartRecordingRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::StartRecordingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StopRecordingResponse>* AsyncStopRecordingRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sentiric::media::v1::StopRecordingResponse>* PrepareAsyncStopRecordingRaw(::grpc::ClientContext* context, const ::sentiric::media::v1::StopRecordingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>* StreamAudioToCallRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>* AsyncStreamAudioToCallRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>* PrepareAsyncStreamAudioToCallRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_AllocatePort_;
    const ::grpc::internal::RpcMethod rpcmethod_ReleasePort_;
    const ::grpc::internal::RpcMethod rpcmethod_PlayAudio_;
    const ::grpc::internal::RpcMethod rpcmethod_RecordAudio_;
    const ::grpc::internal::RpcMethod rpcmethod_StartRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_StopRecording_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamAudioToCall_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Yeni bir RTP oturumu için dinamik UDP portu tahsis eder.
    virtual ::grpc::Status AllocatePort(::grpc::ServerContext* context, const ::sentiric::media::v1::AllocatePortRequest* request, ::sentiric::media::v1::AllocatePortResponse* response);
    // İş bitince portu serbest bırakır ve karantinaya alır.
    virtual ::grpc::Status ReleasePort(::grpc::ServerContext* context, const ::sentiric::media::v1::ReleasePortRequest* request, ::sentiric::media::v1::ReleasePortResponse* response);
    // =================================================================
    // 2. LEGACY (UNARY) OPERASYONLAR 
    // (Agent-Service uyumluluğu için korunmaktadır - DEPRECATED)
    // =================================================================
    //
    // Bir ses dosyasını (URI) veya Base64 veriyi tek seferde çalar.
    // UYARI: Yüksek gecikmeye (latency) neden olabilir.
    virtual ::grpc::Status PlayAudio(::grpc::ServerContext* context, const ::sentiric::media::v1::PlayAudioRequest* request, ::sentiric::media::v1::PlayAudioResponse* response);
    // Canlı sesi dinlemek için stream açar (Tek yönlü: Media -> Client).
    virtual ::grpc::Status RecordAudio(::grpc::ServerContext* context, const ::sentiric::media::v1::RecordAudioRequest* request, ::grpc::ServerWriter< ::sentiric::media::v1::RecordAudioResponse>* writer);
    // Sesi S3/MinIO'ya kaydetmeye başlar.
    virtual ::grpc::Status StartRecording(::grpc::ServerContext* context, const ::sentiric::media::v1::StartRecordingRequest* request, ::sentiric::media::v1::StartRecordingResponse* response);
    // Kaydı durdurur ve dosyayı kapatır.
    virtual ::grpc::Status StopRecording(::grpc::ServerContext* context, const ::sentiric::media::v1::StopRecordingRequest* request, ::sentiric::media::v1::StopRecordingResponse* response);
    // =================================================================
    // 3. NEXT-GEN (STREAMING) OPERASYONLAR
    // (Gerçek Zamanlı AI Konuşmaları İçin - ÖNERİLEN)
    // =================================================================
    //
    // [KRİTİK OPTİMİZASYON]
    // TTS'ten gelen ham ses parçalarını (chunks) anlık olarak RTP'ye basar.
    // Dosya biriktirme veya Base64 dönüşümü yapmaz. 
    // TelephonyActionService tarafından kullanılır.
    virtual ::grpc::Status StreamAudioToCall(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::sentiric::media::v1::StreamAudioToCallResponse, ::sentiric::media::v1::StreamAudioToCallRequest>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_AllocatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AllocatePort() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_AllocatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocatePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::AllocatePortRequest* /*request*/, ::sentiric::media::v1::AllocatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAllocatePort(::grpc::ServerContext* context, ::sentiric::media::v1::AllocatePortRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentiric::media::v1::AllocatePortResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReleasePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReleasePort() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ReleasePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleasePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::ReleasePortRequest* /*request*/, ::sentiric::media::v1::ReleasePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReleasePort(::grpc::ServerContext* context, ::sentiric::media::v1::ReleasePortRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentiric::media::v1::ReleasePortResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayAudio() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PlayAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::PlayAudioRequest* /*request*/, ::sentiric::media::v1::PlayAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayAudio(::grpc::ServerContext* context, ::sentiric::media::v1::PlayAudioRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentiric::media::v1::PlayAudioResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RecordAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RecordAudio() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RecordAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecordAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::RecordAudioRequest* /*request*/, ::grpc::ServerWriter< ::sentiric::media::v1::RecordAudioResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecordAudio(::grpc::ServerContext* context, ::sentiric::media::v1::RecordAudioRequest* request, ::grpc::ServerAsyncWriter< ::sentiric::media::v1::RecordAudioResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartRecording() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StartRecordingRequest* /*request*/, ::sentiric::media::v1::StartRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecording(::grpc::ServerContext* context, ::sentiric::media::v1::StartRecordingRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentiric::media::v1::StartRecordingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopRecording() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StopRecordingRequest* /*request*/, ::sentiric::media::v1::StopRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecording(::grpc::ServerContext* context, ::sentiric::media::v1::StopRecordingRequest* request, ::grpc::ServerAsyncResponseWriter< ::sentiric::media::v1::StopRecordingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamAudioToCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamAudioToCall() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_StreamAudioToCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamAudioToCall(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sentiric::media::v1::StreamAudioToCallResponse, ::sentiric::media::v1::StreamAudioToCallRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamAudioToCall(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::sentiric::media::v1::StreamAudioToCallResponse, ::sentiric::media::v1::StreamAudioToCallRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(6, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_AllocatePort<WithAsyncMethod_ReleasePort<WithAsyncMethod_PlayAudio<WithAsyncMethod_RecordAudio<WithAsyncMethod_StartRecording<WithAsyncMethod_StopRecording<WithAsyncMethod_StreamAudioToCall<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_AllocatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AllocatePort() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::AllocatePortRequest, ::sentiric::media::v1::AllocatePortResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentiric::media::v1::AllocatePortRequest* request, ::sentiric::media::v1::AllocatePortResponse* response) { return this->AllocatePort(context, request, response); }));}
    void SetMessageAllocatorFor_AllocatePort(
        ::grpc::MessageAllocator< ::sentiric::media::v1::AllocatePortRequest, ::sentiric::media::v1::AllocatePortResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::AllocatePortRequest, ::sentiric::media::v1::AllocatePortResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AllocatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocatePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::AllocatePortRequest* /*request*/, ::sentiric::media::v1::AllocatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AllocatePort(
      ::grpc::CallbackServerContext* /*context*/, const ::sentiric::media::v1::AllocatePortRequest* /*request*/, ::sentiric::media::v1::AllocatePortResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReleasePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReleasePort() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::ReleasePortRequest, ::sentiric::media::v1::ReleasePortResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentiric::media::v1::ReleasePortRequest* request, ::sentiric::media::v1::ReleasePortResponse* response) { return this->ReleasePort(context, request, response); }));}
    void SetMessageAllocatorFor_ReleasePort(
        ::grpc::MessageAllocator< ::sentiric::media::v1::ReleasePortRequest, ::sentiric::media::v1::ReleasePortResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::ReleasePortRequest, ::sentiric::media::v1::ReleasePortResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReleasePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleasePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::ReleasePortRequest* /*request*/, ::sentiric::media::v1::ReleasePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReleasePort(
      ::grpc::CallbackServerContext* /*context*/, const ::sentiric::media::v1::ReleasePortRequest* /*request*/, ::sentiric::media::v1::ReleasePortResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PlayAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayAudio() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::PlayAudioRequest, ::sentiric::media::v1::PlayAudioResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentiric::media::v1::PlayAudioRequest* request, ::sentiric::media::v1::PlayAudioResponse* response) { return this->PlayAudio(context, request, response); }));}
    void SetMessageAllocatorFor_PlayAudio(
        ::grpc::MessageAllocator< ::sentiric::media::v1::PlayAudioRequest, ::sentiric::media::v1::PlayAudioResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::PlayAudioRequest, ::sentiric::media::v1::PlayAudioResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::PlayAudioRequest* /*request*/, ::sentiric::media::v1::PlayAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayAudio(
      ::grpc::CallbackServerContext* /*context*/, const ::sentiric::media::v1::PlayAudioRequest* /*request*/, ::sentiric::media::v1::PlayAudioResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RecordAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RecordAudio() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::sentiric::media::v1::RecordAudioRequest, ::sentiric::media::v1::RecordAudioResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentiric::media::v1::RecordAudioRequest* request) { return this->RecordAudio(context, request); }));
    }
    ~WithCallbackMethod_RecordAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecordAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::RecordAudioRequest* /*request*/, ::grpc::ServerWriter< ::sentiric::media::v1::RecordAudioResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::sentiric::media::v1::RecordAudioResponse>* RecordAudio(
      ::grpc::CallbackServerContext* /*context*/, const ::sentiric::media::v1::RecordAudioRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartRecording() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::StartRecordingRequest, ::sentiric::media::v1::StartRecordingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentiric::media::v1::StartRecordingRequest* request, ::sentiric::media::v1::StartRecordingResponse* response) { return this->StartRecording(context, request, response); }));}
    void SetMessageAllocatorFor_StartRecording(
        ::grpc::MessageAllocator< ::sentiric::media::v1::StartRecordingRequest, ::sentiric::media::v1::StartRecordingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::StartRecordingRequest, ::sentiric::media::v1::StartRecordingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StartRecordingRequest* /*request*/, ::sentiric::media::v1::StartRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartRecording(
      ::grpc::CallbackServerContext* /*context*/, const ::sentiric::media::v1::StartRecordingRequest* /*request*/, ::sentiric::media::v1::StartRecordingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopRecording() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::StopRecordingRequest, ::sentiric::media::v1::StopRecordingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sentiric::media::v1::StopRecordingRequest* request, ::sentiric::media::v1::StopRecordingResponse* response) { return this->StopRecording(context, request, response); }));}
    void SetMessageAllocatorFor_StopRecording(
        ::grpc::MessageAllocator< ::sentiric::media::v1::StopRecordingRequest, ::sentiric::media::v1::StopRecordingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sentiric::media::v1::StopRecordingRequest, ::sentiric::media::v1::StopRecordingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StopRecordingRequest* /*request*/, ::sentiric::media::v1::StopRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopRecording(
      ::grpc::CallbackServerContext* /*context*/, const ::sentiric::media::v1::StopRecordingRequest* /*request*/, ::sentiric::media::v1::StopRecordingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamAudioToCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamAudioToCall() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackBidiHandler< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->StreamAudioToCall(context); }));
    }
    ~WithCallbackMethod_StreamAudioToCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamAudioToCall(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sentiric::media::v1::StreamAudioToCallResponse, ::sentiric::media::v1::StreamAudioToCallRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::sentiric::media::v1::StreamAudioToCallRequest, ::sentiric::media::v1::StreamAudioToCallResponse>* StreamAudioToCall(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  typedef WithCallbackMethod_AllocatePort<WithCallbackMethod_ReleasePort<WithCallbackMethod_PlayAudio<WithCallbackMethod_RecordAudio<WithCallbackMethod_StartRecording<WithCallbackMethod_StopRecording<WithCallbackMethod_StreamAudioToCall<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_AllocatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AllocatePort() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_AllocatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocatePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::AllocatePortRequest* /*request*/, ::sentiric::media::v1::AllocatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReleasePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReleasePort() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ReleasePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleasePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::ReleasePortRequest* /*request*/, ::sentiric::media::v1::ReleasePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PlayAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayAudio() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PlayAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::PlayAudioRequest* /*request*/, ::sentiric::media::v1::PlayAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RecordAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RecordAudio() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RecordAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecordAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::RecordAudioRequest* /*request*/, ::grpc::ServerWriter< ::sentiric::media::v1::RecordAudioResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartRecording() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StartRecordingRequest* /*request*/, ::sentiric::media::v1::StartRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopRecording() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StopRecordingRequest* /*request*/, ::sentiric::media::v1::StopRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamAudioToCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamAudioToCall() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_StreamAudioToCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamAudioToCall(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sentiric::media::v1::StreamAudioToCallResponse, ::sentiric::media::v1::StreamAudioToCallRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_AllocatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AllocatePort() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_AllocatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocatePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::AllocatePortRequest* /*request*/, ::sentiric::media::v1::AllocatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAllocatePort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReleasePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReleasePort() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ReleasePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleasePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::ReleasePortRequest* /*request*/, ::sentiric::media::v1::ReleasePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReleasePort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayAudio() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PlayAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::PlayAudioRequest* /*request*/, ::sentiric::media::v1::PlayAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayAudio(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RecordAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RecordAudio() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_RecordAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecordAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::RecordAudioRequest* /*request*/, ::grpc::ServerWriter< ::sentiric::media::v1::RecordAudioResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecordAudio(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartRecording() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StartRecordingRequest* /*request*/, ::sentiric::media::v1::StartRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopRecording() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StopRecordingRequest* /*request*/, ::sentiric::media::v1::StopRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRecording(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamAudioToCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamAudioToCall() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_StreamAudioToCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamAudioToCall(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sentiric::media::v1::StreamAudioToCallResponse, ::sentiric::media::v1::StreamAudioToCallRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamAudioToCall(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(6, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AllocatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AllocatePort() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AllocatePort(context, request, response); }));
    }
    ~WithRawCallbackMethod_AllocatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocatePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::AllocatePortRequest* /*request*/, ::sentiric::media::v1::AllocatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AllocatePort(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReleasePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReleasePort() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReleasePort(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReleasePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleasePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::ReleasePortRequest* /*request*/, ::sentiric::media::v1::ReleasePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReleasePort(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayAudio() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayAudio(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::PlayAudioRequest* /*request*/, ::sentiric::media::v1::PlayAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayAudio(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RecordAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RecordAudio() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->RecordAudio(context, request); }));
    }
    ~WithRawCallbackMethod_RecordAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecordAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::RecordAudioRequest* /*request*/, ::grpc::ServerWriter< ::sentiric::media::v1::RecordAudioResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* RecordAudio(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartRecording() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartRecording(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StartRecordingRequest* /*request*/, ::sentiric::media::v1::StartRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartRecording(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopRecording() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopRecording(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StopRecordingRequest* /*request*/, ::sentiric::media::v1::StopRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopRecording(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamAudioToCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamAudioToCall() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->StreamAudioToCall(context); }));
    }
    ~WithRawCallbackMethod_StreamAudioToCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamAudioToCall(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sentiric::media::v1::StreamAudioToCallResponse, ::sentiric::media::v1::StreamAudioToCallRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StreamAudioToCall(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AllocatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AllocatePort() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentiric::media::v1::AllocatePortRequest, ::sentiric::media::v1::AllocatePortResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentiric::media::v1::AllocatePortRequest, ::sentiric::media::v1::AllocatePortResponse>* streamer) {
                       return this->StreamedAllocatePort(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AllocatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AllocatePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::AllocatePortRequest* /*request*/, ::sentiric::media::v1::AllocatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAllocatePort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentiric::media::v1::AllocatePortRequest,::sentiric::media::v1::AllocatePortResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReleasePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReleasePort() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentiric::media::v1::ReleasePortRequest, ::sentiric::media::v1::ReleasePortResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentiric::media::v1::ReleasePortRequest, ::sentiric::media::v1::ReleasePortResponse>* streamer) {
                       return this->StreamedReleasePort(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReleasePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReleasePort(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::ReleasePortRequest* /*request*/, ::sentiric::media::v1::ReleasePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReleasePort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentiric::media::v1::ReleasePortRequest,::sentiric::media::v1::ReleasePortResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayAudio() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentiric::media::v1::PlayAudioRequest, ::sentiric::media::v1::PlayAudioResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentiric::media::v1::PlayAudioRequest, ::sentiric::media::v1::PlayAudioResponse>* streamer) {
                       return this->StreamedPlayAudio(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::PlayAudioRequest* /*request*/, ::sentiric::media::v1::PlayAudioResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayAudio(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentiric::media::v1::PlayAudioRequest,::sentiric::media::v1::PlayAudioResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartRecording() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentiric::media::v1::StartRecordingRequest, ::sentiric::media::v1::StartRecordingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentiric::media::v1::StartRecordingRequest, ::sentiric::media::v1::StartRecordingResponse>* streamer) {
                       return this->StreamedStartRecording(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StartRecordingRequest* /*request*/, ::sentiric::media::v1::StartRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentiric::media::v1::StartRecordingRequest,::sentiric::media::v1::StartRecordingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopRecording : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopRecording() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sentiric::media::v1::StopRecordingRequest, ::sentiric::media::v1::StopRecordingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sentiric::media::v1::StopRecordingRequest, ::sentiric::media::v1::StopRecordingResponse>* streamer) {
                       return this->StreamedStopRecording(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopRecording() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopRecording(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::StopRecordingRequest* /*request*/, ::sentiric::media::v1::StopRecordingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopRecording(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sentiric::media::v1::StopRecordingRequest,::sentiric::media::v1::StopRecordingResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AllocatePort<WithStreamedUnaryMethod_ReleasePort<WithStreamedUnaryMethod_PlayAudio<WithStreamedUnaryMethod_StartRecording<WithStreamedUnaryMethod_StopRecording<Service > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_RecordAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_RecordAudio() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::sentiric::media::v1::RecordAudioRequest, ::sentiric::media::v1::RecordAudioResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::sentiric::media::v1::RecordAudioRequest, ::sentiric::media::v1::RecordAudioResponse>* streamer) {
                       return this->StreamedRecordAudio(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_RecordAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RecordAudio(::grpc::ServerContext* /*context*/, const ::sentiric::media::v1::RecordAudioRequest* /*request*/, ::grpc::ServerWriter< ::sentiric::media::v1::RecordAudioResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRecordAudio(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::sentiric::media::v1::RecordAudioRequest,::sentiric::media::v1::RecordAudioResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_RecordAudio<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_AllocatePort<WithStreamedUnaryMethod_ReleasePort<WithStreamedUnaryMethod_PlayAudio<WithSplitStreamingMethod_RecordAudio<WithStreamedUnaryMethod_StartRecording<WithStreamedUnaryMethod_StopRecording<Service > > > > > > StreamedService;
};
// =================================================================
// 1. TEMEL PORT YÖNETİMİ (ALTYAPI)
// =================================================================

}  // namespace v1
}  // namespace media
}  // namespace sentiric


#endif  // GRPC_sentiric_2fmedia_2fv1_2fmedia_2eproto__INCLUDED
