// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sentiric/event/v1/event.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sentiric_2fevent_2fv1_2fevent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sentiric_2fevent_2fv1_2fevent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "sentiric/dialplan/v1/dialplan.pb.h"
#include "sentiric/user/v1/user.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sentiric_2fevent_2fv1_2fevent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sentiric_2fevent_2fv1_2fevent_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sentiric_2fevent_2fv1_2fevent_2eproto;
namespace sentiric {
namespace event {
namespace v1 {
class CallEndedEvent;
struct CallEndedEventDefaultTypeInternal;
extern CallEndedEventDefaultTypeInternal _CallEndedEvent_default_instance_;
class CallRecordingAvailableEvent;
struct CallRecordingAvailableEventDefaultTypeInternal;
extern CallRecordingAvailableEventDefaultTypeInternal _CallRecordingAvailableEvent_default_instance_;
class CallStartedEvent;
struct CallStartedEventDefaultTypeInternal;
extern CallStartedEventDefaultTypeInternal _CallStartedEvent_default_instance_;
class GenericEvent;
struct GenericEventDefaultTypeInternal;
extern GenericEventDefaultTypeInternal _GenericEvent_default_instance_;
class MediaInfo;
struct MediaInfoDefaultTypeInternal;
extern MediaInfoDefaultTypeInternal _MediaInfo_default_instance_;
class UserIdentifiedForCallEvent;
struct UserIdentifiedForCallEventDefaultTypeInternal;
extern UserIdentifiedForCallEventDefaultTypeInternal _UserIdentifiedForCallEvent_default_instance_;
}  // namespace v1
}  // namespace event
}  // namespace sentiric
PROTOBUF_NAMESPACE_OPEN
template<> ::sentiric::event::v1::CallEndedEvent* Arena::CreateMaybeMessage<::sentiric::event::v1::CallEndedEvent>(Arena*);
template<> ::sentiric::event::v1::CallRecordingAvailableEvent* Arena::CreateMaybeMessage<::sentiric::event::v1::CallRecordingAvailableEvent>(Arena*);
template<> ::sentiric::event::v1::CallStartedEvent* Arena::CreateMaybeMessage<::sentiric::event::v1::CallStartedEvent>(Arena*);
template<> ::sentiric::event::v1::GenericEvent* Arena::CreateMaybeMessage<::sentiric::event::v1::GenericEvent>(Arena*);
template<> ::sentiric::event::v1::MediaInfo* Arena::CreateMaybeMessage<::sentiric::event::v1::MediaInfo>(Arena*);
template<> ::sentiric::event::v1::UserIdentifiedForCallEvent* Arena::CreateMaybeMessage<::sentiric::event::v1::UserIdentifiedForCallEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sentiric {
namespace event {
namespace v1 {

// ===================================================================

class MediaInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.event.v1.MediaInfo) */ {
 public:
  inline MediaInfo() : MediaInfo(nullptr) {}
  ~MediaInfo() override;
  explicit PROTOBUF_CONSTEXPR MediaInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaInfo(const MediaInfo& from);
  MediaInfo(MediaInfo&& from) noexcept
    : MediaInfo() {
    *this = ::std::move(from);
  }

  inline MediaInfo& operator=(const MediaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo& operator=(MediaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo* internal_default_instance() {
    return reinterpret_cast<const MediaInfo*>(
               &_MediaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MediaInfo& a, MediaInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MediaInfo& from) {
    MediaInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.event.v1.MediaInfo";
  }
  protected:
  explicit MediaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallerRtpAddrFieldNumber = 1,
    kServerRtpPortFieldNumber = 2,
  };
  // string caller_rtp_addr = 1;
  void clear_caller_rtp_addr();
  const std::string& caller_rtp_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller_rtp_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller_rtp_addr();
  PROTOBUF_NODISCARD std::string* release_caller_rtp_addr();
  void set_allocated_caller_rtp_addr(std::string* caller_rtp_addr);
  private:
  const std::string& _internal_caller_rtp_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller_rtp_addr(const std::string& value);
  std::string* _internal_mutable_caller_rtp_addr();
  public:

  // uint32 server_rtp_port = 2;
  void clear_server_rtp_port();
  uint32_t server_rtp_port() const;
  void set_server_rtp_port(uint32_t value);
  private:
  uint32_t _internal_server_rtp_port() const;
  void _internal_set_server_rtp_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.event.v1.MediaInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_rtp_addr_;
    uint32_t server_rtp_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class CallStartedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.event.v1.CallStartedEvent) */ {
 public:
  inline CallStartedEvent() : CallStartedEvent(nullptr) {}
  ~CallStartedEvent() override;
  explicit PROTOBUF_CONSTEXPR CallStartedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallStartedEvent(const CallStartedEvent& from);
  CallStartedEvent(CallStartedEvent&& from) noexcept
    : CallStartedEvent() {
    *this = ::std::move(from);
  }

  inline CallStartedEvent& operator=(const CallStartedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallStartedEvent& operator=(CallStartedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallStartedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallStartedEvent* internal_default_instance() {
    return reinterpret_cast<const CallStartedEvent*>(
               &_CallStartedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CallStartedEvent& a, CallStartedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CallStartedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallStartedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallStartedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallStartedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallStartedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallStartedEvent& from) {
    CallStartedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallStartedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.event.v1.CallStartedEvent";
  }
  protected:
  explicit CallStartedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kTraceIdFieldNumber = 2,
    kCallIdFieldNumber = 3,
    kFromUriFieldNumber = 4,
    kToUriFieldNumber = 5,
    kTimestampFieldNumber = 6,
    kDialplanResolutionFieldNumber = 7,
    kMediaInfoFieldNumber = 8,
  };
  // string event_type = 1;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string trace_id = 2;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string call_id = 3;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // string from_uri = 4;
  void clear_from_uri();
  const std::string& from_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_uri();
  PROTOBUF_NODISCARD std::string* release_from_uri();
  void set_allocated_from_uri(std::string* from_uri);
  private:
  const std::string& _internal_from_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_uri(const std::string& value);
  std::string* _internal_mutable_from_uri();
  public:

  // string to_uri = 5;
  void clear_to_uri();
  const std::string& to_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_uri();
  PROTOBUF_NODISCARD std::string* release_to_uri();
  void set_allocated_to_uri(std::string* to_uri);
  private:
  const std::string& _internal_to_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_uri(const std::string& value);
  std::string* _internal_mutable_to_uri();
  public:

  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .sentiric.dialplan.v1.ResolveDialplanResponse dialplan_resolution = 7;
  bool has_dialplan_resolution() const;
  private:
  bool _internal_has_dialplan_resolution() const;
  public:
  void clear_dialplan_resolution();
  const ::sentiric::dialplan::v1::ResolveDialplanResponse& dialplan_resolution() const;
  PROTOBUF_NODISCARD ::sentiric::dialplan::v1::ResolveDialplanResponse* release_dialplan_resolution();
  ::sentiric::dialplan::v1::ResolveDialplanResponse* mutable_dialplan_resolution();
  void set_allocated_dialplan_resolution(::sentiric::dialplan::v1::ResolveDialplanResponse* dialplan_resolution);
  private:
  const ::sentiric::dialplan::v1::ResolveDialplanResponse& _internal_dialplan_resolution() const;
  ::sentiric::dialplan::v1::ResolveDialplanResponse* _internal_mutable_dialplan_resolution();
  public:
  void unsafe_arena_set_allocated_dialplan_resolution(
      ::sentiric::dialplan::v1::ResolveDialplanResponse* dialplan_resolution);
  ::sentiric::dialplan::v1::ResolveDialplanResponse* unsafe_arena_release_dialplan_resolution();

  // .sentiric.event.v1.MediaInfo media_info = 8;
  bool has_media_info() const;
  private:
  bool _internal_has_media_info() const;
  public:
  void clear_media_info();
  const ::sentiric::event::v1::MediaInfo& media_info() const;
  PROTOBUF_NODISCARD ::sentiric::event::v1::MediaInfo* release_media_info();
  ::sentiric::event::v1::MediaInfo* mutable_media_info();
  void set_allocated_media_info(::sentiric::event::v1::MediaInfo* media_info);
  private:
  const ::sentiric::event::v1::MediaInfo& _internal_media_info() const;
  ::sentiric::event::v1::MediaInfo* _internal_mutable_media_info();
  public:
  void unsafe_arena_set_allocated_media_info(
      ::sentiric::event::v1::MediaInfo* media_info);
  ::sentiric::event::v1::MediaInfo* unsafe_arena_release_media_info();

  // @@protoc_insertion_point(class_scope:sentiric.event.v1.CallStartedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_uri_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::sentiric::dialplan::v1::ResolveDialplanResponse* dialplan_resolution_;
    ::sentiric::event::v1::MediaInfo* media_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class UserIdentifiedForCallEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.event.v1.UserIdentifiedForCallEvent) */ {
 public:
  inline UserIdentifiedForCallEvent() : UserIdentifiedForCallEvent(nullptr) {}
  ~UserIdentifiedForCallEvent() override;
  explicit PROTOBUF_CONSTEXPR UserIdentifiedForCallEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserIdentifiedForCallEvent(const UserIdentifiedForCallEvent& from);
  UserIdentifiedForCallEvent(UserIdentifiedForCallEvent&& from) noexcept
    : UserIdentifiedForCallEvent() {
    *this = ::std::move(from);
  }

  inline UserIdentifiedForCallEvent& operator=(const UserIdentifiedForCallEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserIdentifiedForCallEvent& operator=(UserIdentifiedForCallEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserIdentifiedForCallEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserIdentifiedForCallEvent* internal_default_instance() {
    return reinterpret_cast<const UserIdentifiedForCallEvent*>(
               &_UserIdentifiedForCallEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserIdentifiedForCallEvent& a, UserIdentifiedForCallEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserIdentifiedForCallEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserIdentifiedForCallEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserIdentifiedForCallEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserIdentifiedForCallEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserIdentifiedForCallEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserIdentifiedForCallEvent& from) {
    UserIdentifiedForCallEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserIdentifiedForCallEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.event.v1.UserIdentifiedForCallEvent";
  }
  protected:
  explicit UserIdentifiedForCallEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kTraceIdFieldNumber = 2,
    kCallIdFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kUserFieldNumber = 5,
    kContactFieldNumber = 6,
  };
  // string event_type = 1;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string trace_id = 2;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string call_id = 3;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // .google.protobuf.Timestamp timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .sentiric.user.v1.User user = 5;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::sentiric::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::User* release_user();
  ::sentiric::user::v1::User* mutable_user();
  void set_allocated_user(::sentiric::user::v1::User* user);
  private:
  const ::sentiric::user::v1::User& _internal_user() const;
  ::sentiric::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::sentiric::user::v1::User* user);
  ::sentiric::user::v1::User* unsafe_arena_release_user();

  // .sentiric.user.v1.Contact contact = 6;
  bool has_contact() const;
  private:
  bool _internal_has_contact() const;
  public:
  void clear_contact();
  const ::sentiric::user::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::sentiric::user::v1::Contact* release_contact();
  ::sentiric::user::v1::Contact* mutable_contact();
  void set_allocated_contact(::sentiric::user::v1::Contact* contact);
  private:
  const ::sentiric::user::v1::Contact& _internal_contact() const;
  ::sentiric::user::v1::Contact* _internal_mutable_contact();
  public:
  void unsafe_arena_set_allocated_contact(
      ::sentiric::user::v1::Contact* contact);
  ::sentiric::user::v1::Contact* unsafe_arena_release_contact();

  // @@protoc_insertion_point(class_scope:sentiric.event.v1.UserIdentifiedForCallEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::sentiric::user::v1::User* user_;
    ::sentiric::user::v1::Contact* contact_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class CallRecordingAvailableEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.event.v1.CallRecordingAvailableEvent) */ {
 public:
  inline CallRecordingAvailableEvent() : CallRecordingAvailableEvent(nullptr) {}
  ~CallRecordingAvailableEvent() override;
  explicit PROTOBUF_CONSTEXPR CallRecordingAvailableEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallRecordingAvailableEvent(const CallRecordingAvailableEvent& from);
  CallRecordingAvailableEvent(CallRecordingAvailableEvent&& from) noexcept
    : CallRecordingAvailableEvent() {
    *this = ::std::move(from);
  }

  inline CallRecordingAvailableEvent& operator=(const CallRecordingAvailableEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallRecordingAvailableEvent& operator=(CallRecordingAvailableEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallRecordingAvailableEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallRecordingAvailableEvent* internal_default_instance() {
    return reinterpret_cast<const CallRecordingAvailableEvent*>(
               &_CallRecordingAvailableEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CallRecordingAvailableEvent& a, CallRecordingAvailableEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CallRecordingAvailableEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallRecordingAvailableEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallRecordingAvailableEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallRecordingAvailableEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallRecordingAvailableEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallRecordingAvailableEvent& from) {
    CallRecordingAvailableEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallRecordingAvailableEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.event.v1.CallRecordingAvailableEvent";
  }
  protected:
  explicit CallRecordingAvailableEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kTraceIdFieldNumber = 2,
    kCallIdFieldNumber = 3,
    kRecordingUriFieldNumber = 5,
    kPublicUrlFieldNumber = 6,
    kTimestampFieldNumber = 4,
  };
  // string event_type = 1;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string trace_id = 2;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string call_id = 3;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // string recording_uri = 5;
  void clear_recording_uri();
  const std::string& recording_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recording_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recording_uri();
  PROTOBUF_NODISCARD std::string* release_recording_uri();
  void set_allocated_recording_uri(std::string* recording_uri);
  private:
  const std::string& _internal_recording_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recording_uri(const std::string& value);
  std::string* _internal_mutable_recording_uri();
  public:

  // string public_url = 6;
  void clear_public_url();
  const std::string& public_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_url();
  PROTOBUF_NODISCARD std::string* release_public_url();
  void set_allocated_public_url(std::string* public_url);
  private:
  const std::string& _internal_public_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_url(const std::string& value);
  std::string* _internal_mutable_public_url();
  public:

  // .google.protobuf.Timestamp timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sentiric.event.v1.CallRecordingAvailableEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recording_uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_url_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class CallEndedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.event.v1.CallEndedEvent) */ {
 public:
  inline CallEndedEvent() : CallEndedEvent(nullptr) {}
  ~CallEndedEvent() override;
  explicit PROTOBUF_CONSTEXPR CallEndedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallEndedEvent(const CallEndedEvent& from);
  CallEndedEvent(CallEndedEvent&& from) noexcept
    : CallEndedEvent() {
    *this = ::std::move(from);
  }

  inline CallEndedEvent& operator=(const CallEndedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallEndedEvent& operator=(CallEndedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallEndedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallEndedEvent* internal_default_instance() {
    return reinterpret_cast<const CallEndedEvent*>(
               &_CallEndedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CallEndedEvent& a, CallEndedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CallEndedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallEndedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallEndedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallEndedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallEndedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallEndedEvent& from) {
    CallEndedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallEndedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.event.v1.CallEndedEvent";
  }
  protected:
  explicit CallEndedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kTraceIdFieldNumber = 2,
    kCallIdFieldNumber = 3,
    kReasonFieldNumber = 5,
    kTimestampFieldNumber = 4,
  };
  // string event_type = 1;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string trace_id = 2;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string call_id = 3;
  void clear_call_id();
  const std::string& call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_id();
  PROTOBUF_NODISCARD std::string* release_call_id();
  void set_allocated_call_id(std::string* call_id);
  private:
  const std::string& _internal_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_id(const std::string& value);
  std::string* _internal_mutable_call_id();
  public:

  // string reason = 5;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // .google.protobuf.Timestamp timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sentiric.event.v1.CallEndedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class GenericEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.event.v1.GenericEvent) */ {
 public:
  inline GenericEvent() : GenericEvent(nullptr) {}
  ~GenericEvent() override;
  explicit PROTOBUF_CONSTEXPR GenericEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericEvent(const GenericEvent& from);
  GenericEvent(GenericEvent&& from) noexcept
    : GenericEvent() {
    *this = ::std::move(from);
  }

  inline GenericEvent& operator=(const GenericEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericEvent& operator=(GenericEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericEvent* internal_default_instance() {
    return reinterpret_cast<const GenericEvent*>(
               &_GenericEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GenericEvent& a, GenericEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenericEvent& from) {
    GenericEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.event.v1.GenericEvent";
  }
  protected:
  explicit GenericEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 1,
    kTraceIdFieldNumber = 2,
    kTenantIdFieldNumber = 4,
    kPayloadJsonFieldNumber = 5,
    kTimestampFieldNumber = 3,
  };
  // string event_type = 1;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string trace_id = 2;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string tenant_id = 4;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // string payload_json = 5;
  void clear_payload_json();
  const std::string& payload_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload_json();
  PROTOBUF_NODISCARD std::string* release_payload_json();
  void set_allocated_payload_json(std::string* payload_json);
  private:
  const std::string& _internal_payload_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_json(const std::string& value);
  std::string* _internal_mutable_payload_json();
  public:

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:sentiric.event.v1.GenericEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_json_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fevent_2fv1_2fevent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MediaInfo

// string caller_rtp_addr = 1;
inline void MediaInfo::clear_caller_rtp_addr() {
  _impl_.caller_rtp_addr_.ClearToEmpty();
}
inline const std::string& MediaInfo::caller_rtp_addr() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.MediaInfo.caller_rtp_addr)
  return _internal_caller_rtp_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MediaInfo::set_caller_rtp_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.caller_rtp_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.MediaInfo.caller_rtp_addr)
}
inline std::string* MediaInfo::mutable_caller_rtp_addr() {
  std::string* _s = _internal_mutable_caller_rtp_addr();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.MediaInfo.caller_rtp_addr)
  return _s;
}
inline const std::string& MediaInfo::_internal_caller_rtp_addr() const {
  return _impl_.caller_rtp_addr_.Get();
}
inline void MediaInfo::_internal_set_caller_rtp_addr(const std::string& value) {
  
  _impl_.caller_rtp_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* MediaInfo::_internal_mutable_caller_rtp_addr() {
  
  return _impl_.caller_rtp_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* MediaInfo::release_caller_rtp_addr() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.MediaInfo.caller_rtp_addr)
  return _impl_.caller_rtp_addr_.Release();
}
inline void MediaInfo::set_allocated_caller_rtp_addr(std::string* caller_rtp_addr) {
  if (caller_rtp_addr != nullptr) {
    
  } else {
    
  }
  _impl_.caller_rtp_addr_.SetAllocated(caller_rtp_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caller_rtp_addr_.IsDefault()) {
    _impl_.caller_rtp_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.MediaInfo.caller_rtp_addr)
}

// uint32 server_rtp_port = 2;
inline void MediaInfo::clear_server_rtp_port() {
  _impl_.server_rtp_port_ = 0u;
}
inline uint32_t MediaInfo::_internal_server_rtp_port() const {
  return _impl_.server_rtp_port_;
}
inline uint32_t MediaInfo::server_rtp_port() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.MediaInfo.server_rtp_port)
  return _internal_server_rtp_port();
}
inline void MediaInfo::_internal_set_server_rtp_port(uint32_t value) {
  
  _impl_.server_rtp_port_ = value;
}
inline void MediaInfo::set_server_rtp_port(uint32_t value) {
  _internal_set_server_rtp_port(value);
  // @@protoc_insertion_point(field_set:sentiric.event.v1.MediaInfo.server_rtp_port)
}

// -------------------------------------------------------------------

// CallStartedEvent

// string event_type = 1;
inline void CallStartedEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& CallStartedEvent::event_type() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallStartedEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallStartedEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallStartedEvent.event_type)
}
inline std::string* CallStartedEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallStartedEvent.event_type)
  return _s;
}
inline const std::string& CallStartedEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void CallStartedEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* CallStartedEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* CallStartedEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallStartedEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void CallStartedEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallStartedEvent.event_type)
}

// string trace_id = 2;
inline void CallStartedEvent::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& CallStartedEvent::trace_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallStartedEvent.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallStartedEvent::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallStartedEvent.trace_id)
}
inline std::string* CallStartedEvent::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallStartedEvent.trace_id)
  return _s;
}
inline const std::string& CallStartedEvent::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void CallStartedEvent::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallStartedEvent::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallStartedEvent::release_trace_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallStartedEvent.trace_id)
  return _impl_.trace_id_.Release();
}
inline void CallStartedEvent::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallStartedEvent.trace_id)
}

// string call_id = 3;
inline void CallStartedEvent::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& CallStartedEvent::call_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallStartedEvent.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallStartedEvent::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallStartedEvent.call_id)
}
inline std::string* CallStartedEvent::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallStartedEvent.call_id)
  return _s;
}
inline const std::string& CallStartedEvent::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void CallStartedEvent::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallStartedEvent::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallStartedEvent::release_call_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallStartedEvent.call_id)
  return _impl_.call_id_.Release();
}
inline void CallStartedEvent::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallStartedEvent.call_id)
}

// string from_uri = 4;
inline void CallStartedEvent::clear_from_uri() {
  _impl_.from_uri_.ClearToEmpty();
}
inline const std::string& CallStartedEvent::from_uri() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallStartedEvent.from_uri)
  return _internal_from_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallStartedEvent::set_from_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallStartedEvent.from_uri)
}
inline std::string* CallStartedEvent::mutable_from_uri() {
  std::string* _s = _internal_mutable_from_uri();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallStartedEvent.from_uri)
  return _s;
}
inline const std::string& CallStartedEvent::_internal_from_uri() const {
  return _impl_.from_uri_.Get();
}
inline void CallStartedEvent::_internal_set_from_uri(const std::string& value) {
  
  _impl_.from_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* CallStartedEvent::_internal_mutable_from_uri() {
  
  return _impl_.from_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* CallStartedEvent::release_from_uri() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallStartedEvent.from_uri)
  return _impl_.from_uri_.Release();
}
inline void CallStartedEvent::set_allocated_from_uri(std::string* from_uri) {
  if (from_uri != nullptr) {
    
  } else {
    
  }
  _impl_.from_uri_.SetAllocated(from_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_uri_.IsDefault()) {
    _impl_.from_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallStartedEvent.from_uri)
}

// string to_uri = 5;
inline void CallStartedEvent::clear_to_uri() {
  _impl_.to_uri_.ClearToEmpty();
}
inline const std::string& CallStartedEvent::to_uri() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallStartedEvent.to_uri)
  return _internal_to_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallStartedEvent::set_to_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallStartedEvent.to_uri)
}
inline std::string* CallStartedEvent::mutable_to_uri() {
  std::string* _s = _internal_mutable_to_uri();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallStartedEvent.to_uri)
  return _s;
}
inline const std::string& CallStartedEvent::_internal_to_uri() const {
  return _impl_.to_uri_.Get();
}
inline void CallStartedEvent::_internal_set_to_uri(const std::string& value) {
  
  _impl_.to_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* CallStartedEvent::_internal_mutable_to_uri() {
  
  return _impl_.to_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* CallStartedEvent::release_to_uri() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallStartedEvent.to_uri)
  return _impl_.to_uri_.Release();
}
inline void CallStartedEvent::set_allocated_to_uri(std::string* to_uri) {
  if (to_uri != nullptr) {
    
  } else {
    
  }
  _impl_.to_uri_.SetAllocated(to_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_uri_.IsDefault()) {
    _impl_.to_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallStartedEvent.to_uri)
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool CallStartedEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool CallStartedEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CallStartedEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CallStartedEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallStartedEvent.timestamp)
  return _internal_timestamp();
}
inline void CallStartedEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.CallStartedEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallStartedEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallStartedEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallStartedEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallStartedEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallStartedEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallStartedEvent.timestamp)
  return _msg;
}
inline void CallStartedEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallStartedEvent.timestamp)
}

// .sentiric.dialplan.v1.ResolveDialplanResponse dialplan_resolution = 7;
inline bool CallStartedEvent::_internal_has_dialplan_resolution() const {
  return this != internal_default_instance() && _impl_.dialplan_resolution_ != nullptr;
}
inline bool CallStartedEvent::has_dialplan_resolution() const {
  return _internal_has_dialplan_resolution();
}
inline const ::sentiric::dialplan::v1::ResolveDialplanResponse& CallStartedEvent::_internal_dialplan_resolution() const {
  const ::sentiric::dialplan::v1::ResolveDialplanResponse* p = _impl_.dialplan_resolution_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::dialplan::v1::ResolveDialplanResponse&>(
      ::sentiric::dialplan::v1::_ResolveDialplanResponse_default_instance_);
}
inline const ::sentiric::dialplan::v1::ResolveDialplanResponse& CallStartedEvent::dialplan_resolution() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallStartedEvent.dialplan_resolution)
  return _internal_dialplan_resolution();
}
inline void CallStartedEvent::unsafe_arena_set_allocated_dialplan_resolution(
    ::sentiric::dialplan::v1::ResolveDialplanResponse* dialplan_resolution) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dialplan_resolution_);
  }
  _impl_.dialplan_resolution_ = dialplan_resolution;
  if (dialplan_resolution) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.CallStartedEvent.dialplan_resolution)
}
inline ::sentiric::dialplan::v1::ResolveDialplanResponse* CallStartedEvent::release_dialplan_resolution() {
  
  ::sentiric::dialplan::v1::ResolveDialplanResponse* temp = _impl_.dialplan_resolution_;
  _impl_.dialplan_resolution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::dialplan::v1::ResolveDialplanResponse* CallStartedEvent::unsafe_arena_release_dialplan_resolution() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallStartedEvent.dialplan_resolution)
  
  ::sentiric::dialplan::v1::ResolveDialplanResponse* temp = _impl_.dialplan_resolution_;
  _impl_.dialplan_resolution_ = nullptr;
  return temp;
}
inline ::sentiric::dialplan::v1::ResolveDialplanResponse* CallStartedEvent::_internal_mutable_dialplan_resolution() {
  
  if (_impl_.dialplan_resolution_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::dialplan::v1::ResolveDialplanResponse>(GetArenaForAllocation());
    _impl_.dialplan_resolution_ = p;
  }
  return _impl_.dialplan_resolution_;
}
inline ::sentiric::dialplan::v1::ResolveDialplanResponse* CallStartedEvent::mutable_dialplan_resolution() {
  ::sentiric::dialplan::v1::ResolveDialplanResponse* _msg = _internal_mutable_dialplan_resolution();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallStartedEvent.dialplan_resolution)
  return _msg;
}
inline void CallStartedEvent::set_allocated_dialplan_resolution(::sentiric::dialplan::v1::ResolveDialplanResponse* dialplan_resolution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dialplan_resolution_);
  }
  if (dialplan_resolution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dialplan_resolution));
    if (message_arena != submessage_arena) {
      dialplan_resolution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dialplan_resolution, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dialplan_resolution_ = dialplan_resolution;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallStartedEvent.dialplan_resolution)
}

// .sentiric.event.v1.MediaInfo media_info = 8;
inline bool CallStartedEvent::_internal_has_media_info() const {
  return this != internal_default_instance() && _impl_.media_info_ != nullptr;
}
inline bool CallStartedEvent::has_media_info() const {
  return _internal_has_media_info();
}
inline void CallStartedEvent::clear_media_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.media_info_ != nullptr) {
    delete _impl_.media_info_;
  }
  _impl_.media_info_ = nullptr;
}
inline const ::sentiric::event::v1::MediaInfo& CallStartedEvent::_internal_media_info() const {
  const ::sentiric::event::v1::MediaInfo* p = _impl_.media_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::event::v1::MediaInfo&>(
      ::sentiric::event::v1::_MediaInfo_default_instance_);
}
inline const ::sentiric::event::v1::MediaInfo& CallStartedEvent::media_info() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallStartedEvent.media_info)
  return _internal_media_info();
}
inline void CallStartedEvent::unsafe_arena_set_allocated_media_info(
    ::sentiric::event::v1::MediaInfo* media_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.media_info_);
  }
  _impl_.media_info_ = media_info;
  if (media_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.CallStartedEvent.media_info)
}
inline ::sentiric::event::v1::MediaInfo* CallStartedEvent::release_media_info() {
  
  ::sentiric::event::v1::MediaInfo* temp = _impl_.media_info_;
  _impl_.media_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::event::v1::MediaInfo* CallStartedEvent::unsafe_arena_release_media_info() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallStartedEvent.media_info)
  
  ::sentiric::event::v1::MediaInfo* temp = _impl_.media_info_;
  _impl_.media_info_ = nullptr;
  return temp;
}
inline ::sentiric::event::v1::MediaInfo* CallStartedEvent::_internal_mutable_media_info() {
  
  if (_impl_.media_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::event::v1::MediaInfo>(GetArenaForAllocation());
    _impl_.media_info_ = p;
  }
  return _impl_.media_info_;
}
inline ::sentiric::event::v1::MediaInfo* CallStartedEvent::mutable_media_info() {
  ::sentiric::event::v1::MediaInfo* _msg = _internal_mutable_media_info();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallStartedEvent.media_info)
  return _msg;
}
inline void CallStartedEvent::set_allocated_media_info(::sentiric::event::v1::MediaInfo* media_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.media_info_;
  }
  if (media_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(media_info);
    if (message_arena != submessage_arena) {
      media_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, media_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.media_info_ = media_info;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallStartedEvent.media_info)
}

// -------------------------------------------------------------------

// UserIdentifiedForCallEvent

// string event_type = 1;
inline void UserIdentifiedForCallEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& UserIdentifiedForCallEvent::event_type() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.UserIdentifiedForCallEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIdentifiedForCallEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.UserIdentifiedForCallEvent.event_type)
}
inline std::string* UserIdentifiedForCallEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.UserIdentifiedForCallEvent.event_type)
  return _s;
}
inline const std::string& UserIdentifiedForCallEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void UserIdentifiedForCallEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIdentifiedForCallEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIdentifiedForCallEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.UserIdentifiedForCallEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void UserIdentifiedForCallEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.event_type)
}

// string trace_id = 2;
inline void UserIdentifiedForCallEvent::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& UserIdentifiedForCallEvent::trace_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.UserIdentifiedForCallEvent.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIdentifiedForCallEvent::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.UserIdentifiedForCallEvent.trace_id)
}
inline std::string* UserIdentifiedForCallEvent::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.UserIdentifiedForCallEvent.trace_id)
  return _s;
}
inline const std::string& UserIdentifiedForCallEvent::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void UserIdentifiedForCallEvent::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIdentifiedForCallEvent::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIdentifiedForCallEvent::release_trace_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.UserIdentifiedForCallEvent.trace_id)
  return _impl_.trace_id_.Release();
}
inline void UserIdentifiedForCallEvent::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.trace_id)
}

// string call_id = 3;
inline void UserIdentifiedForCallEvent::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& UserIdentifiedForCallEvent::call_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.UserIdentifiedForCallEvent.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIdentifiedForCallEvent::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.UserIdentifiedForCallEvent.call_id)
}
inline std::string* UserIdentifiedForCallEvent::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.UserIdentifiedForCallEvent.call_id)
  return _s;
}
inline const std::string& UserIdentifiedForCallEvent::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void UserIdentifiedForCallEvent::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIdentifiedForCallEvent::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIdentifiedForCallEvent::release_call_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.UserIdentifiedForCallEvent.call_id)
  return _impl_.call_id_.Release();
}
inline void UserIdentifiedForCallEvent::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.call_id)
}

// .google.protobuf.Timestamp timestamp = 4;
inline bool UserIdentifiedForCallEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool UserIdentifiedForCallEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIdentifiedForCallEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIdentifiedForCallEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.UserIdentifiedForCallEvent.timestamp)
  return _internal_timestamp();
}
inline void UserIdentifiedForCallEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIdentifiedForCallEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIdentifiedForCallEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.UserIdentifiedForCallEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIdentifiedForCallEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIdentifiedForCallEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.UserIdentifiedForCallEvent.timestamp)
  return _msg;
}
inline void UserIdentifiedForCallEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.timestamp)
}

// .sentiric.user.v1.User user = 5;
inline bool UserIdentifiedForCallEvent::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UserIdentifiedForCallEvent::has_user() const {
  return _internal_has_user();
}
inline const ::sentiric::user::v1::User& UserIdentifiedForCallEvent::_internal_user() const {
  const ::sentiric::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::User&>(
      ::sentiric::user::v1::_User_default_instance_);
}
inline const ::sentiric::user::v1::User& UserIdentifiedForCallEvent::user() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.UserIdentifiedForCallEvent.user)
  return _internal_user();
}
inline void UserIdentifiedForCallEvent::unsafe_arena_set_allocated_user(
    ::sentiric::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.user)
}
inline ::sentiric::user::v1::User* UserIdentifiedForCallEvent::release_user() {
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::User* UserIdentifiedForCallEvent::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.UserIdentifiedForCallEvent.user)
  
  ::sentiric::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::User* UserIdentifiedForCallEvent::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::sentiric::user::v1::User* UserIdentifiedForCallEvent::mutable_user() {
  ::sentiric::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.UserIdentifiedForCallEvent.user)
  return _msg;
}
inline void UserIdentifiedForCallEvent::set_allocated_user(::sentiric::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user));
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.user)
}

// .sentiric.user.v1.Contact contact = 6;
inline bool UserIdentifiedForCallEvent::_internal_has_contact() const {
  return this != internal_default_instance() && _impl_.contact_ != nullptr;
}
inline bool UserIdentifiedForCallEvent::has_contact() const {
  return _internal_has_contact();
}
inline const ::sentiric::user::v1::Contact& UserIdentifiedForCallEvent::_internal_contact() const {
  const ::sentiric::user::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::sentiric::user::v1::Contact&>(
      ::sentiric::user::v1::_Contact_default_instance_);
}
inline const ::sentiric::user::v1::Contact& UserIdentifiedForCallEvent::contact() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.UserIdentifiedForCallEvent.contact)
  return _internal_contact();
}
inline void UserIdentifiedForCallEvent::unsafe_arena_set_allocated_contact(
    ::sentiric::user::v1::Contact* contact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = contact;
  if (contact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.contact)
}
inline ::sentiric::user::v1::Contact* UserIdentifiedForCallEvent::release_contact() {
  
  ::sentiric::user::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sentiric::user::v1::Contact* UserIdentifiedForCallEvent::unsafe_arena_release_contact() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.UserIdentifiedForCallEvent.contact)
  
  ::sentiric::user::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::sentiric::user::v1::Contact* UserIdentifiedForCallEvent::_internal_mutable_contact() {
  
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::sentiric::user::v1::Contact>(GetArenaForAllocation());
    _impl_.contact_ = p;
  }
  return _impl_.contact_;
}
inline ::sentiric::user::v1::Contact* UserIdentifiedForCallEvent::mutable_contact() {
  ::sentiric::user::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.UserIdentifiedForCallEvent.contact)
  return _msg;
}
inline void UserIdentifiedForCallEvent::set_allocated_contact(::sentiric::user::v1::Contact* contact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contact_);
  }
  if (contact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contact));
    if (message_arena != submessage_arena) {
      contact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contact, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contact_ = contact;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.UserIdentifiedForCallEvent.contact)
}

// -------------------------------------------------------------------

// CallRecordingAvailableEvent

// string event_type = 1;
inline void CallRecordingAvailableEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& CallRecordingAvailableEvent::event_type() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallRecordingAvailableEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRecordingAvailableEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallRecordingAvailableEvent.event_type)
}
inline std::string* CallRecordingAvailableEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallRecordingAvailableEvent.event_type)
  return _s;
}
inline const std::string& CallRecordingAvailableEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void CallRecordingAvailableEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallRecordingAvailableEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void CallRecordingAvailableEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallRecordingAvailableEvent.event_type)
}

// string trace_id = 2;
inline void CallRecordingAvailableEvent::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& CallRecordingAvailableEvent::trace_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallRecordingAvailableEvent.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRecordingAvailableEvent::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallRecordingAvailableEvent.trace_id)
}
inline std::string* CallRecordingAvailableEvent::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallRecordingAvailableEvent.trace_id)
  return _s;
}
inline const std::string& CallRecordingAvailableEvent::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void CallRecordingAvailableEvent::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::release_trace_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallRecordingAvailableEvent.trace_id)
  return _impl_.trace_id_.Release();
}
inline void CallRecordingAvailableEvent::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallRecordingAvailableEvent.trace_id)
}

// string call_id = 3;
inline void CallRecordingAvailableEvent::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& CallRecordingAvailableEvent::call_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallRecordingAvailableEvent.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRecordingAvailableEvent::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallRecordingAvailableEvent.call_id)
}
inline std::string* CallRecordingAvailableEvent::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallRecordingAvailableEvent.call_id)
  return _s;
}
inline const std::string& CallRecordingAvailableEvent::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void CallRecordingAvailableEvent::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::release_call_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallRecordingAvailableEvent.call_id)
  return _impl_.call_id_.Release();
}
inline void CallRecordingAvailableEvent::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallRecordingAvailableEvent.call_id)
}

// .google.protobuf.Timestamp timestamp = 4;
inline bool CallRecordingAvailableEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool CallRecordingAvailableEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CallRecordingAvailableEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CallRecordingAvailableEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallRecordingAvailableEvent.timestamp)
  return _internal_timestamp();
}
inline void CallRecordingAvailableEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.CallRecordingAvailableEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallRecordingAvailableEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallRecordingAvailableEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallRecordingAvailableEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallRecordingAvailableEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallRecordingAvailableEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallRecordingAvailableEvent.timestamp)
  return _msg;
}
inline void CallRecordingAvailableEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallRecordingAvailableEvent.timestamp)
}

// string recording_uri = 5;
inline void CallRecordingAvailableEvent::clear_recording_uri() {
  _impl_.recording_uri_.ClearToEmpty();
}
inline const std::string& CallRecordingAvailableEvent::recording_uri() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallRecordingAvailableEvent.recording_uri)
  return _internal_recording_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRecordingAvailableEvent::set_recording_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recording_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallRecordingAvailableEvent.recording_uri)
}
inline std::string* CallRecordingAvailableEvent::mutable_recording_uri() {
  std::string* _s = _internal_mutable_recording_uri();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallRecordingAvailableEvent.recording_uri)
  return _s;
}
inline const std::string& CallRecordingAvailableEvent::_internal_recording_uri() const {
  return _impl_.recording_uri_.Get();
}
inline void CallRecordingAvailableEvent::_internal_set_recording_uri(const std::string& value) {
  
  _impl_.recording_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::_internal_mutable_recording_uri() {
  
  return _impl_.recording_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::release_recording_uri() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallRecordingAvailableEvent.recording_uri)
  return _impl_.recording_uri_.Release();
}
inline void CallRecordingAvailableEvent::set_allocated_recording_uri(std::string* recording_uri) {
  if (recording_uri != nullptr) {
    
  } else {
    
  }
  _impl_.recording_uri_.SetAllocated(recording_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recording_uri_.IsDefault()) {
    _impl_.recording_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallRecordingAvailableEvent.recording_uri)
}

// string public_url = 6;
inline void CallRecordingAvailableEvent::clear_public_url() {
  _impl_.public_url_.ClearToEmpty();
}
inline const std::string& CallRecordingAvailableEvent::public_url() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallRecordingAvailableEvent.public_url)
  return _internal_public_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRecordingAvailableEvent::set_public_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallRecordingAvailableEvent.public_url)
}
inline std::string* CallRecordingAvailableEvent::mutable_public_url() {
  std::string* _s = _internal_mutable_public_url();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallRecordingAvailableEvent.public_url)
  return _s;
}
inline const std::string& CallRecordingAvailableEvent::_internal_public_url() const {
  return _impl_.public_url_.Get();
}
inline void CallRecordingAvailableEvent::_internal_set_public_url(const std::string& value) {
  
  _impl_.public_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::_internal_mutable_public_url() {
  
  return _impl_.public_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRecordingAvailableEvent::release_public_url() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallRecordingAvailableEvent.public_url)
  return _impl_.public_url_.Release();
}
inline void CallRecordingAvailableEvent::set_allocated_public_url(std::string* public_url) {
  if (public_url != nullptr) {
    
  } else {
    
  }
  _impl_.public_url_.SetAllocated(public_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_url_.IsDefault()) {
    _impl_.public_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallRecordingAvailableEvent.public_url)
}

// -------------------------------------------------------------------

// CallEndedEvent

// string event_type = 1;
inline void CallEndedEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& CallEndedEvent::event_type() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallEndedEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallEndedEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallEndedEvent.event_type)
}
inline std::string* CallEndedEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallEndedEvent.event_type)
  return _s;
}
inline const std::string& CallEndedEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void CallEndedEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEndedEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* CallEndedEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallEndedEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void CallEndedEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallEndedEvent.event_type)
}

// string trace_id = 2;
inline void CallEndedEvent::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& CallEndedEvent::trace_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallEndedEvent.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallEndedEvent::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallEndedEvent.trace_id)
}
inline std::string* CallEndedEvent::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallEndedEvent.trace_id)
  return _s;
}
inline const std::string& CallEndedEvent::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void CallEndedEvent::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEndedEvent::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallEndedEvent::release_trace_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallEndedEvent.trace_id)
  return _impl_.trace_id_.Release();
}
inline void CallEndedEvent::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallEndedEvent.trace_id)
}

// string call_id = 3;
inline void CallEndedEvent::clear_call_id() {
  _impl_.call_id_.ClearToEmpty();
}
inline const std::string& CallEndedEvent::call_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallEndedEvent.call_id)
  return _internal_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallEndedEvent::set_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallEndedEvent.call_id)
}
inline std::string* CallEndedEvent::mutable_call_id() {
  std::string* _s = _internal_mutable_call_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallEndedEvent.call_id)
  return _s;
}
inline const std::string& CallEndedEvent::_internal_call_id() const {
  return _impl_.call_id_.Get();
}
inline void CallEndedEvent::_internal_set_call_id(const std::string& value) {
  
  _impl_.call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEndedEvent::_internal_mutable_call_id() {
  
  return _impl_.call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CallEndedEvent::release_call_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallEndedEvent.call_id)
  return _impl_.call_id_.Release();
}
inline void CallEndedEvent::set_allocated_call_id(std::string* call_id) {
  if (call_id != nullptr) {
    
  } else {
    
  }
  _impl_.call_id_.SetAllocated(call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.call_id_.IsDefault()) {
    _impl_.call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallEndedEvent.call_id)
}

// .google.protobuf.Timestamp timestamp = 4;
inline bool CallEndedEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool CallEndedEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CallEndedEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CallEndedEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallEndedEvent.timestamp)
  return _internal_timestamp();
}
inline void CallEndedEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.CallEndedEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallEndedEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallEndedEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallEndedEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallEndedEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CallEndedEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallEndedEvent.timestamp)
  return _msg;
}
inline void CallEndedEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallEndedEvent.timestamp)
}

// string reason = 5;
inline void CallEndedEvent::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& CallEndedEvent::reason() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.CallEndedEvent.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallEndedEvent::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.CallEndedEvent.reason)
}
inline std::string* CallEndedEvent::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.CallEndedEvent.reason)
  return _s;
}
inline const std::string& CallEndedEvent::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void CallEndedEvent::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEndedEvent::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* CallEndedEvent::release_reason() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.CallEndedEvent.reason)
  return _impl_.reason_.Release();
}
inline void CallEndedEvent::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.CallEndedEvent.reason)
}

// -------------------------------------------------------------------

// GenericEvent

// string event_type = 1;
inline void GenericEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& GenericEvent::event_type() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.GenericEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.GenericEvent.event_type)
}
inline std::string* GenericEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.GenericEvent.event_type)
  return _s;
}
inline const std::string& GenericEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void GenericEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.GenericEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void GenericEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.GenericEvent.event_type)
}

// string trace_id = 2;
inline void GenericEvent::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& GenericEvent::trace_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.GenericEvent.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericEvent::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.GenericEvent.trace_id)
}
inline std::string* GenericEvent::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.GenericEvent.trace_id)
  return _s;
}
inline const std::string& GenericEvent::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void GenericEvent::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericEvent::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericEvent::release_trace_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.GenericEvent.trace_id)
  return _impl_.trace_id_.Release();
}
inline void GenericEvent::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.GenericEvent.trace_id)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool GenericEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool GenericEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GenericEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GenericEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.GenericEvent.timestamp)
  return _internal_timestamp();
}
inline void GenericEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sentiric.event.v1.GenericEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GenericEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GenericEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.GenericEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GenericEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GenericEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.GenericEvent.timestamp)
  return _msg;
}
inline void GenericEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.GenericEvent.timestamp)
}

// string tenant_id = 4;
inline void GenericEvent::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& GenericEvent::tenant_id() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.GenericEvent.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericEvent::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.GenericEvent.tenant_id)
}
inline std::string* GenericEvent::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.GenericEvent.tenant_id)
  return _s;
}
inline const std::string& GenericEvent::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void GenericEvent::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericEvent::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericEvent::release_tenant_id() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.GenericEvent.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void GenericEvent::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.GenericEvent.tenant_id)
}

// string payload_json = 5;
inline void GenericEvent::clear_payload_json() {
  _impl_.payload_json_.ClearToEmpty();
}
inline const std::string& GenericEvent::payload_json() const {
  // @@protoc_insertion_point(field_get:sentiric.event.v1.GenericEvent.payload_json)
  return _internal_payload_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericEvent::set_payload_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.event.v1.GenericEvent.payload_json)
}
inline std::string* GenericEvent::mutable_payload_json() {
  std::string* _s = _internal_mutable_payload_json();
  // @@protoc_insertion_point(field_mutable:sentiric.event.v1.GenericEvent.payload_json)
  return _s;
}
inline const std::string& GenericEvent::_internal_payload_json() const {
  return _impl_.payload_json_.Get();
}
inline void GenericEvent::_internal_set_payload_json(const std::string& value) {
  
  _impl_.payload_json_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericEvent::_internal_mutable_payload_json() {
  
  return _impl_.payload_json_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericEvent::release_payload_json() {
  // @@protoc_insertion_point(field_release:sentiric.event.v1.GenericEvent.payload_json)
  return _impl_.payload_json_.Release();
}
inline void GenericEvent::set_allocated_payload_json(std::string* payload_json) {
  if (payload_json != nullptr) {
    
  } else {
    
  }
  _impl_.payload_json_.SetAllocated(payload_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_json_.IsDefault()) {
    _impl_.payload_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.event.v1.GenericEvent.payload_json)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace event
}  // namespace sentiric

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sentiric_2fevent_2fv1_2fevent_2eproto
