// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sentiric/vertical/v1/hospitality.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sentiric_2fvertical_2fv1_2fhospitality_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sentiric_2fvertical_2fv1_2fhospitality_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sentiric_2fvertical_2fv1_2fhospitality_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sentiric_2fvertical_2fv1_2fhospitality_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sentiric_2fvertical_2fv1_2fhospitality_2eproto;
namespace sentiric {
namespace vertical {
namespace v1 {
class BookRoomRequest;
struct BookRoomRequestDefaultTypeInternal;
extern BookRoomRequestDefaultTypeInternal _BookRoomRequest_default_instance_;
class BookRoomResponse;
struct BookRoomResponseDefaultTypeInternal;
extern BookRoomResponseDefaultTypeInternal _BookRoomResponse_default_instance_;
class FindHotelsRequest;
struct FindHotelsRequestDefaultTypeInternal;
extern FindHotelsRequestDefaultTypeInternal _FindHotelsRequest_default_instance_;
class FindHotelsResponse;
struct FindHotelsResponseDefaultTypeInternal;
extern FindHotelsResponseDefaultTypeInternal _FindHotelsResponse_default_instance_;
class HotelResult;
struct HotelResultDefaultTypeInternal;
extern HotelResultDefaultTypeInternal _HotelResult_default_instance_;
}  // namespace v1
}  // namespace vertical
}  // namespace sentiric
PROTOBUF_NAMESPACE_OPEN
template<> ::sentiric::vertical::v1::BookRoomRequest* Arena::CreateMaybeMessage<::sentiric::vertical::v1::BookRoomRequest>(Arena*);
template<> ::sentiric::vertical::v1::BookRoomResponse* Arena::CreateMaybeMessage<::sentiric::vertical::v1::BookRoomResponse>(Arena*);
template<> ::sentiric::vertical::v1::FindHotelsRequest* Arena::CreateMaybeMessage<::sentiric::vertical::v1::FindHotelsRequest>(Arena*);
template<> ::sentiric::vertical::v1::FindHotelsResponse* Arena::CreateMaybeMessage<::sentiric::vertical::v1::FindHotelsResponse>(Arena*);
template<> ::sentiric::vertical::v1::HotelResult* Arena::CreateMaybeMessage<::sentiric::vertical::v1::HotelResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sentiric {
namespace vertical {
namespace v1 {

// ===================================================================

class FindHotelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.vertical.v1.FindHotelsRequest) */ {
 public:
  inline FindHotelsRequest() : FindHotelsRequest(nullptr) {}
  ~FindHotelsRequest() override;
  explicit PROTOBUF_CONSTEXPR FindHotelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindHotelsRequest(const FindHotelsRequest& from);
  FindHotelsRequest(FindHotelsRequest&& from) noexcept
    : FindHotelsRequest() {
    *this = ::std::move(from);
  }

  inline FindHotelsRequest& operator=(const FindHotelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindHotelsRequest& operator=(FindHotelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindHotelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindHotelsRequest* internal_default_instance() {
    return reinterpret_cast<const FindHotelsRequest*>(
               &_FindHotelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FindHotelsRequest& a, FindHotelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindHotelsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindHotelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindHotelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindHotelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindHotelsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindHotelsRequest& from) {
    FindHotelsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindHotelsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.vertical.v1.FindHotelsRequest";
  }
  protected:
  explicit FindHotelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kCheckInDateFieldNumber = 2,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string check_in_date = 2;
  void clear_check_in_date();
  const std::string& check_in_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_check_in_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_check_in_date();
  PROTOBUF_NODISCARD std::string* release_check_in_date();
  void set_allocated_check_in_date(std::string* check_in_date);
  private:
  const std::string& _internal_check_in_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_check_in_date(const std::string& value);
  std::string* _internal_mutable_check_in_date();
  public:

  // @@protoc_insertion_point(class_scope:sentiric.vertical.v1.FindHotelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr check_in_date_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fvertical_2fv1_2fhospitality_2eproto;
};
// -------------------------------------------------------------------

class FindHotelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.vertical.v1.FindHotelsResponse) */ {
 public:
  inline FindHotelsResponse() : FindHotelsResponse(nullptr) {}
  ~FindHotelsResponse() override;
  explicit PROTOBUF_CONSTEXPR FindHotelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindHotelsResponse(const FindHotelsResponse& from);
  FindHotelsResponse(FindHotelsResponse&& from) noexcept
    : FindHotelsResponse() {
    *this = ::std::move(from);
  }

  inline FindHotelsResponse& operator=(const FindHotelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindHotelsResponse& operator=(FindHotelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindHotelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindHotelsResponse* internal_default_instance() {
    return reinterpret_cast<const FindHotelsResponse*>(
               &_FindHotelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FindHotelsResponse& a, FindHotelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FindHotelsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindHotelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindHotelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindHotelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindHotelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindHotelsResponse& from) {
    FindHotelsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindHotelsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.vertical.v1.FindHotelsResponse";
  }
  protected:
  explicit FindHotelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .sentiric.vertical.v1.HotelResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::sentiric::vertical::v1::HotelResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::vertical::v1::HotelResult >*
      mutable_results();
  private:
  const ::sentiric::vertical::v1::HotelResult& _internal_results(int index) const;
  ::sentiric::vertical::v1::HotelResult* _internal_add_results();
  public:
  const ::sentiric::vertical::v1::HotelResult& results(int index) const;
  ::sentiric::vertical::v1::HotelResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::vertical::v1::HotelResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:sentiric.vertical.v1.FindHotelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::vertical::v1::HotelResult > results_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fvertical_2fv1_2fhospitality_2eproto;
};
// -------------------------------------------------------------------

class HotelResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.vertical.v1.HotelResult) */ {
 public:
  inline HotelResult() : HotelResult(nullptr) {}
  ~HotelResult() override;
  explicit PROTOBUF_CONSTEXPR HotelResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HotelResult(const HotelResult& from);
  HotelResult(HotelResult&& from) noexcept
    : HotelResult() {
    *this = ::std::move(from);
  }

  inline HotelResult& operator=(const HotelResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline HotelResult& operator=(HotelResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HotelResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const HotelResult* internal_default_instance() {
    return reinterpret_cast<const HotelResult*>(
               &_HotelResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HotelResult& a, HotelResult& b) {
    a.Swap(&b);
  }
  inline void Swap(HotelResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HotelResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HotelResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HotelResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HotelResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HotelResult& from) {
    HotelResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HotelResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.vertical.v1.HotelResult";
  }
  protected:
  explicit HotelResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRatingFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 rating = 2;
  void clear_rating();
  int32_t rating() const;
  void set_rating(int32_t value);
  private:
  int32_t _internal_rating() const;
  void _internal_set_rating(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.vertical.v1.HotelResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t rating_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fvertical_2fv1_2fhospitality_2eproto;
};
// -------------------------------------------------------------------

class BookRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.vertical.v1.BookRoomRequest) */ {
 public:
  inline BookRoomRequest() : BookRoomRequest(nullptr) {}
  ~BookRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR BookRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BookRoomRequest(const BookRoomRequest& from);
  BookRoomRequest(BookRoomRequest&& from) noexcept
    : BookRoomRequest() {
    *this = ::std::move(from);
  }

  inline BookRoomRequest& operator=(const BookRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BookRoomRequest& operator=(BookRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BookRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BookRoomRequest* internal_default_instance() {
    return reinterpret_cast<const BookRoomRequest*>(
               &_BookRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BookRoomRequest& a, BookRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BookRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BookRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BookRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BookRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BookRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BookRoomRequest& from) {
    BookRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BookRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.vertical.v1.BookRoomRequest";
  }
  protected:
  explicit BookRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHotelIdFieldNumber = 1,
    kGuestNameFieldNumber = 2,
    kNumGuestsFieldNumber = 3,
  };
  // string hotel_id = 1;
  void clear_hotel_id();
  const std::string& hotel_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hotel_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hotel_id();
  PROTOBUF_NODISCARD std::string* release_hotel_id();
  void set_allocated_hotel_id(std::string* hotel_id);
  private:
  const std::string& _internal_hotel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hotel_id(const std::string& value);
  std::string* _internal_mutable_hotel_id();
  public:

  // string guest_name = 2;
  void clear_guest_name();
  const std::string& guest_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guest_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guest_name();
  PROTOBUF_NODISCARD std::string* release_guest_name();
  void set_allocated_guest_name(std::string* guest_name);
  private:
  const std::string& _internal_guest_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guest_name(const std::string& value);
  std::string* _internal_mutable_guest_name();
  public:

  // int32 num_guests = 3;
  void clear_num_guests();
  int32_t num_guests() const;
  void set_num_guests(int32_t value);
  private:
  int32_t _internal_num_guests() const;
  void _internal_set_num_guests(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.vertical.v1.BookRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hotel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guest_name_;
    int32_t num_guests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fvertical_2fv1_2fhospitality_2eproto;
};
// -------------------------------------------------------------------

class BookRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sentiric.vertical.v1.BookRoomResponse) */ {
 public:
  inline BookRoomResponse() : BookRoomResponse(nullptr) {}
  ~BookRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR BookRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BookRoomResponse(const BookRoomResponse& from);
  BookRoomResponse(BookRoomResponse&& from) noexcept
    : BookRoomResponse() {
    *this = ::std::move(from);
  }

  inline BookRoomResponse& operator=(const BookRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BookRoomResponse& operator=(BookRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BookRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BookRoomResponse* internal_default_instance() {
    return reinterpret_cast<const BookRoomResponse*>(
               &_BookRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BookRoomResponse& a, BookRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BookRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BookRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BookRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BookRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BookRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BookRoomResponse& from) {
    BookRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BookRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sentiric.vertical.v1.BookRoomResponse";
  }
  protected:
  explicit BookRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBookingIdFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string booking_id = 1;
  void clear_booking_id();
  const std::string& booking_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_booking_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_booking_id();
  PROTOBUF_NODISCARD std::string* release_booking_id();
  void set_allocated_booking_id(std::string* booking_id);
  private:
  const std::string& _internal_booking_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_booking_id(const std::string& value);
  std::string* _internal_mutable_booking_id();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sentiric.vertical.v1.BookRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr booking_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sentiric_2fvertical_2fv1_2fhospitality_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FindHotelsRequest

// string location = 1;
inline void FindHotelsRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& FindHotelsRequest::location() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.FindHotelsRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindHotelsRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.FindHotelsRequest.location)
}
inline std::string* FindHotelsRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:sentiric.vertical.v1.FindHotelsRequest.location)
  return _s;
}
inline const std::string& FindHotelsRequest::_internal_location() const {
  return _impl_.location_.Get();
}
inline void FindHotelsRequest::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* FindHotelsRequest::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* FindHotelsRequest::release_location() {
  // @@protoc_insertion_point(field_release:sentiric.vertical.v1.FindHotelsRequest.location)
  return _impl_.location_.Release();
}
inline void FindHotelsRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.vertical.v1.FindHotelsRequest.location)
}

// string check_in_date = 2;
inline void FindHotelsRequest::clear_check_in_date() {
  _impl_.check_in_date_.ClearToEmpty();
}
inline const std::string& FindHotelsRequest::check_in_date() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.FindHotelsRequest.check_in_date)
  return _internal_check_in_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindHotelsRequest::set_check_in_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.check_in_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.FindHotelsRequest.check_in_date)
}
inline std::string* FindHotelsRequest::mutable_check_in_date() {
  std::string* _s = _internal_mutable_check_in_date();
  // @@protoc_insertion_point(field_mutable:sentiric.vertical.v1.FindHotelsRequest.check_in_date)
  return _s;
}
inline const std::string& FindHotelsRequest::_internal_check_in_date() const {
  return _impl_.check_in_date_.Get();
}
inline void FindHotelsRequest::_internal_set_check_in_date(const std::string& value) {
  
  _impl_.check_in_date_.Set(value, GetArenaForAllocation());
}
inline std::string* FindHotelsRequest::_internal_mutable_check_in_date() {
  
  return _impl_.check_in_date_.Mutable(GetArenaForAllocation());
}
inline std::string* FindHotelsRequest::release_check_in_date() {
  // @@protoc_insertion_point(field_release:sentiric.vertical.v1.FindHotelsRequest.check_in_date)
  return _impl_.check_in_date_.Release();
}
inline void FindHotelsRequest::set_allocated_check_in_date(std::string* check_in_date) {
  if (check_in_date != nullptr) {
    
  } else {
    
  }
  _impl_.check_in_date_.SetAllocated(check_in_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.check_in_date_.IsDefault()) {
    _impl_.check_in_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.vertical.v1.FindHotelsRequest.check_in_date)
}

// -------------------------------------------------------------------

// FindHotelsResponse

// repeated .sentiric.vertical.v1.HotelResult results = 1;
inline int FindHotelsResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int FindHotelsResponse::results_size() const {
  return _internal_results_size();
}
inline void FindHotelsResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::sentiric::vertical::v1::HotelResult* FindHotelsResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:sentiric.vertical.v1.FindHotelsResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::vertical::v1::HotelResult >*
FindHotelsResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:sentiric.vertical.v1.FindHotelsResponse.results)
  return &_impl_.results_;
}
inline const ::sentiric::vertical::v1::HotelResult& FindHotelsResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::sentiric::vertical::v1::HotelResult& FindHotelsResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.FindHotelsResponse.results)
  return _internal_results(index);
}
inline ::sentiric::vertical::v1::HotelResult* FindHotelsResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::sentiric::vertical::v1::HotelResult* FindHotelsResponse::add_results() {
  ::sentiric::vertical::v1::HotelResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:sentiric.vertical.v1.FindHotelsResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sentiric::vertical::v1::HotelResult >&
FindHotelsResponse::results() const {
  // @@protoc_insertion_point(field_list:sentiric.vertical.v1.FindHotelsResponse.results)
  return _impl_.results_;
}

// -------------------------------------------------------------------

// HotelResult

// string name = 1;
inline void HotelResult::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HotelResult::name() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.HotelResult.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HotelResult::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.HotelResult.name)
}
inline std::string* HotelResult::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sentiric.vertical.v1.HotelResult.name)
  return _s;
}
inline const std::string& HotelResult::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HotelResult::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HotelResult::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HotelResult::release_name() {
  // @@protoc_insertion_point(field_release:sentiric.vertical.v1.HotelResult.name)
  return _impl_.name_.Release();
}
inline void HotelResult::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.vertical.v1.HotelResult.name)
}

// int32 rating = 2;
inline void HotelResult::clear_rating() {
  _impl_.rating_ = 0;
}
inline int32_t HotelResult::_internal_rating() const {
  return _impl_.rating_;
}
inline int32_t HotelResult::rating() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.HotelResult.rating)
  return _internal_rating();
}
inline void HotelResult::_internal_set_rating(int32_t value) {
  
  _impl_.rating_ = value;
}
inline void HotelResult::set_rating(int32_t value) {
  _internal_set_rating(value);
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.HotelResult.rating)
}

// -------------------------------------------------------------------

// BookRoomRequest

// string hotel_id = 1;
inline void BookRoomRequest::clear_hotel_id() {
  _impl_.hotel_id_.ClearToEmpty();
}
inline const std::string& BookRoomRequest::hotel_id() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.BookRoomRequest.hotel_id)
  return _internal_hotel_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookRoomRequest::set_hotel_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hotel_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.BookRoomRequest.hotel_id)
}
inline std::string* BookRoomRequest::mutable_hotel_id() {
  std::string* _s = _internal_mutable_hotel_id();
  // @@protoc_insertion_point(field_mutable:sentiric.vertical.v1.BookRoomRequest.hotel_id)
  return _s;
}
inline const std::string& BookRoomRequest::_internal_hotel_id() const {
  return _impl_.hotel_id_.Get();
}
inline void BookRoomRequest::_internal_set_hotel_id(const std::string& value) {
  
  _impl_.hotel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BookRoomRequest::_internal_mutable_hotel_id() {
  
  return _impl_.hotel_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BookRoomRequest::release_hotel_id() {
  // @@protoc_insertion_point(field_release:sentiric.vertical.v1.BookRoomRequest.hotel_id)
  return _impl_.hotel_id_.Release();
}
inline void BookRoomRequest::set_allocated_hotel_id(std::string* hotel_id) {
  if (hotel_id != nullptr) {
    
  } else {
    
  }
  _impl_.hotel_id_.SetAllocated(hotel_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hotel_id_.IsDefault()) {
    _impl_.hotel_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.vertical.v1.BookRoomRequest.hotel_id)
}

// string guest_name = 2;
inline void BookRoomRequest::clear_guest_name() {
  _impl_.guest_name_.ClearToEmpty();
}
inline const std::string& BookRoomRequest::guest_name() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.BookRoomRequest.guest_name)
  return _internal_guest_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookRoomRequest::set_guest_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.guest_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.BookRoomRequest.guest_name)
}
inline std::string* BookRoomRequest::mutable_guest_name() {
  std::string* _s = _internal_mutable_guest_name();
  // @@protoc_insertion_point(field_mutable:sentiric.vertical.v1.BookRoomRequest.guest_name)
  return _s;
}
inline const std::string& BookRoomRequest::_internal_guest_name() const {
  return _impl_.guest_name_.Get();
}
inline void BookRoomRequest::_internal_set_guest_name(const std::string& value) {
  
  _impl_.guest_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BookRoomRequest::_internal_mutable_guest_name() {
  
  return _impl_.guest_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BookRoomRequest::release_guest_name() {
  // @@protoc_insertion_point(field_release:sentiric.vertical.v1.BookRoomRequest.guest_name)
  return _impl_.guest_name_.Release();
}
inline void BookRoomRequest::set_allocated_guest_name(std::string* guest_name) {
  if (guest_name != nullptr) {
    
  } else {
    
  }
  _impl_.guest_name_.SetAllocated(guest_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.guest_name_.IsDefault()) {
    _impl_.guest_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.vertical.v1.BookRoomRequest.guest_name)
}

// int32 num_guests = 3;
inline void BookRoomRequest::clear_num_guests() {
  _impl_.num_guests_ = 0;
}
inline int32_t BookRoomRequest::_internal_num_guests() const {
  return _impl_.num_guests_;
}
inline int32_t BookRoomRequest::num_guests() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.BookRoomRequest.num_guests)
  return _internal_num_guests();
}
inline void BookRoomRequest::_internal_set_num_guests(int32_t value) {
  
  _impl_.num_guests_ = value;
}
inline void BookRoomRequest::set_num_guests(int32_t value) {
  _internal_set_num_guests(value);
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.BookRoomRequest.num_guests)
}

// -------------------------------------------------------------------

// BookRoomResponse

// string booking_id = 1;
inline void BookRoomResponse::clear_booking_id() {
  _impl_.booking_id_.ClearToEmpty();
}
inline const std::string& BookRoomResponse::booking_id() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.BookRoomResponse.booking_id)
  return _internal_booking_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookRoomResponse::set_booking_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.booking_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.BookRoomResponse.booking_id)
}
inline std::string* BookRoomResponse::mutable_booking_id() {
  std::string* _s = _internal_mutable_booking_id();
  // @@protoc_insertion_point(field_mutable:sentiric.vertical.v1.BookRoomResponse.booking_id)
  return _s;
}
inline const std::string& BookRoomResponse::_internal_booking_id() const {
  return _impl_.booking_id_.Get();
}
inline void BookRoomResponse::_internal_set_booking_id(const std::string& value) {
  
  _impl_.booking_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BookRoomResponse::_internal_mutable_booking_id() {
  
  return _impl_.booking_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BookRoomResponse::release_booking_id() {
  // @@protoc_insertion_point(field_release:sentiric.vertical.v1.BookRoomResponse.booking_id)
  return _impl_.booking_id_.Release();
}
inline void BookRoomResponse::set_allocated_booking_id(std::string* booking_id) {
  if (booking_id != nullptr) {
    
  } else {
    
  }
  _impl_.booking_id_.SetAllocated(booking_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.booking_id_.IsDefault()) {
    _impl_.booking_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sentiric.vertical.v1.BookRoomResponse.booking_id)
}

// bool success = 2;
inline void BookRoomResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool BookRoomResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool BookRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:sentiric.vertical.v1.BookRoomResponse.success)
  return _internal_success();
}
inline void BookRoomResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void BookRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:sentiric.vertical.v1.BookRoomResponse.success)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace vertical
}  // namespace sentiric

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sentiric_2fvertical_2fv1_2fhospitality_2eproto
