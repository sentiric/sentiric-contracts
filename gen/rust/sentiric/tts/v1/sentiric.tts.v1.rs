// @generated
// This file is @generated by prost-build.
/// --- Unary Messages ---
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoquiSynthesizeRequest {
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub language_code: ::prost::alloc::string::String,
    /// \[MİMARİ GÜNCELLEME\]: Klonlama için referans ses.
    /// Bu, speaker_idx'i geçersiz kılar.
    #[prost(bytes="vec", optional, tag="3")]
    pub speaker_wav: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(float, tag="4")]
    pub temperature: f32,
    #[prost(float, tag="5")]
    pub speed: f32,
    #[prost(float, tag="6")]
    pub top_p: f32,
    #[prost(float, tag="7")]
    pub top_k: f32,
    #[prost(float, tag="8")]
    pub repetition_penalty: f32,
    #[prost(string, tag="9")]
    pub output_format: ::prost::alloc::string::String,
    /// \[DEEP VOICE FIX\]: İstenen örnekleme hızını belirtmek için yeni alan.
    /// Eğer 0 ise, motorun doğal hızı (24000Hz) kullanılır.
    #[prost(int32, tag="10")]
    pub sample_rate: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CoquiSynthesizeResponse {
    #[prost(bytes="vec", tag="1")]
    pub audio_content: ::prost::alloc::vec::Vec<u8>,
}
/// --- Stream Messages ---
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoquiSynthesizeStreamRequest {
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub language_code: ::prost::alloc::string::String,
    /// \[MİMARİ GÜNCELLEME\]: Klonlama için referans ses.
    #[prost(bytes="vec", optional, tag="3")]
    pub speaker_wav: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(float, tag="4")]
    pub temperature: f32,
    #[prost(float, tag="5")]
    pub speed: f32,
    #[prost(float, tag="6")]
    pub top_p: f32,
    #[prost(float, tag="7")]
    pub top_k: f32,
    #[prost(float, tag="8")]
    pub repetition_penalty: f32,
    #[prost(string, tag="9")]
    pub output_format: ::prost::alloc::string::String,
    /// \[DEEP VOICE FIX\]: İstenen örnekleme hızını belirtmek için yeni alan.
    #[prost(int32, tag="10")]
    pub sample_rate: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CoquiSynthesizeStreamResponse {
    #[prost(bytes="vec", tag="1")]
    pub audio_chunk: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag="2")]
    pub is_final: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EdgeSynthesizeRequest {
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub voice_model_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EdgeSynthesizeResponse {
    #[prost(bytes="vec", tag="1")]
    pub audio_content: ::prost::alloc::vec::Vec<u8>,
}
// =============================================================================
// RPC MESAJLARI
// =============================================================================

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynthesizeRequest {
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
    #[prost(enumeration="TextType", tag="2")]
    pub text_type: i32,
    #[prost(string, tag="3")]
    pub voice_id: ::prost::alloc::string::String,
    /// \[MİMARİ KARAR\]: AudioConfig zorunludur. Her istek format ve sample rate belirtmelidir.
    #[prost(message, optional, tag="4")]
    pub audio_config: ::core::option::Option<AudioConfig>,
    #[prost(string, tag="5")]
    pub preferred_provider: ::prost::alloc::string::String,
    /// \[MİMARİ KARAR\]: İnce ayar parametreleri opsiyonel bir alt mesaj olarak eklendi.
    #[prost(message, optional, tag="6")]
    pub tuning: ::core::option::Option<TuningParams>,
    #[prost(bytes="vec", optional, tag="7")]
    pub cloning_audio_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SynthesizeResponse {
    #[prost(bytes="vec", tag="1")]
    pub audio_content: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub provider_used: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynthesizeStreamRequest {
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
    #[prost(enumeration="TextType", tag="2")]
    pub text_type: i32,
    #[prost(string, tag="3")]
    pub voice_id: ::prost::alloc::string::String,
    /// \[MİMARİ KARAR\]: AudioConfig zorunludur.
    #[prost(message, optional, tag="4")]
    pub audio_config: ::core::option::Option<AudioConfig>,
    #[prost(string, tag="5")]
    pub preferred_provider: ::prost::alloc::string::String,
    /// \[MİMARİ KARAR\]: İnce ayar parametreleri opsiyonel bir alt mesaj olarak eklendi.
    #[prost(message, optional, tag="6")]
    pub tuning: ::core::option::Option<TuningParams>,
    #[prost(bytes="vec", optional, tag="7")]
    pub cloning_audio_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SynthesizeStreamResponse {
    #[prost(bytes="vec", tag="1")]
    pub audio_content: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub provider_used: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListVoicesRequest {
    #[prost(string, tag="1")]
    pub language_code: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVoicesResponse {
    #[prost(message, repeated, tag="1")]
    pub voices: ::prost::alloc::vec::Vec<VoiceInfo>,
}
// =============================================================================
// YARDIMCI TİPLER & ENUMLAR
// =============================================================================

/// \[YENİ MESAJ\]: Ses üretiminin ince ayarlarını kontrol eder.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TuningParams {
    /// Rastgelelik: Yüksek değerler daha yaratıcı, düşük değerler daha deterministik. (0.0-2.0)
    #[prost(float, tag="1")]
    pub temperature: f32,
    /// Nucleus sampling: Olasılık eşiği. (0.0-1.0)
    #[prost(float, tag="2")]
    pub top_p: f32,
    /// En olası K token arasından seçim yap.
    #[prost(int32, tag="3")]
    pub top_k: i32,
    /// Tekrar eden kelimeleri cezalandır. (1.0+)
    #[prost(float, tag="4")]
    pub repetition_penalty: f32,
    /// Konuşma hızı. (0.25-4.0)
    #[prost(float, tag="5")]
    pub speed: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudioConfig {
    #[prost(enumeration="AudioFormat", tag="1")]
    pub audio_format: i32,
    #[prost(int32, tag="2")]
    pub sample_rate_hertz: i32,
    #[prost(double, tag="3")]
    pub volume_gain_db: f64,
}
/// ProsodyConfig eski versiyonlarla uyumluluk için tutuluyor,
/// ancak yeni sistemler TuningParams kullanmalı.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProsodyConfig {
    #[prost(double, tag="1")]
    pub rate: f64,
    #[prost(double, tag="2")]
    pub pitch: f64,
    #[prost(string, tag="3")]
    pub emotion: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VoiceInfo {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub language: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub gender: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="5")]
    pub styles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TextType {
    Unspecified = 0,
    Text = 1,
    Ssml = 2,
}
impl TextType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TEXT_TYPE_UNSPECIFIED",
            Self::Text => "TEXT_TYPE_TEXT",
            Self::Ssml => "TEXT_TYPE_SSML",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEXT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TEXT_TYPE_TEXT" => Some(Self::Text),
            "TEXT_TYPE_SSML" => Some(Self::Ssml),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AudioFormat {
    Unspecified = 0,
    PcmS16le = 1,
    Wav = 2,
    Mp3 = 3,
    OggOpus = 4,
    Mulaw = 5,
}
impl AudioFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AUDIO_FORMAT_UNSPECIFIED",
            Self::PcmS16le => "AUDIO_FORMAT_PCM_S16LE",
            Self::Wav => "AUDIO_FORMAT_WAV",
            Self::Mp3 => "AUDIO_FORMAT_MP3",
            Self::OggOpus => "AUDIO_FORMAT_OGG_OPUS",
            Self::Mulaw => "AUDIO_FORMAT_MULAW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUDIO_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "AUDIO_FORMAT_PCM_S16LE" => Some(Self::PcmS16le),
            "AUDIO_FORMAT_WAV" => Some(Self::Wav),
            "AUDIO_FORMAT_MP3" => Some(Self::Mp3),
            "AUDIO_FORMAT_OGG_OPUS" => Some(Self::OggOpus),
            "AUDIO_FORMAT_MULAW" => Some(Self::Mulaw),
            _ => None,
        }
    }
}
// --- Unary Messages ---

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MmsSynthesizeRequest {
    /// Sentezlenecek ham metin veya SSML.
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
    /// ISO dil kodu (örn: "tur" veya "tr"). 
    /// Model bu kodu desteklenen diller listesinde doğrular.
    #[prost(string, tag="2")]
    pub language_code: ::prost::alloc::string::String,
    /// Konuşma hızı çarpanı (Varsayılan: 1.0).
    /// MMS VITS mimarisi süre manipülasyonuna izin verir.
    #[prost(float, tag="3")]
    pub speed: f32,
    /// Örnekleme hızı (Varsayılan: Modelin native hızı, genellikle 24000Hz veya 16000Hz).
    #[prost(int32, tag="4")]
    pub sample_rate: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MmsSynthesizeResponse {
    /// Üretilen ses verisi (WAV header dahil veya hariç, yapılandırmaya bağlı).
    #[prost(bytes="vec", tag="1")]
    pub audio_content: ::prost::alloc::vec::Vec<u8>,
    /// Kullanılan örnekleme hızı.
    #[prost(int32, tag="2")]
    pub sample_rate: i32,
}
// --- Stream Messages ---

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MmsSynthesizeStreamRequest {
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(float, tag="3")]
    pub speed: f32,
    #[prost(int32, tag="4")]
    pub sample_rate: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MmsSynthesizeStreamResponse {
    /// Ses verisinin bir parçası (Chunk).
    #[prost(bytes="vec", tag="1")]
    pub audio_chunk: ::prost::alloc::vec::Vec<u8>,
    /// Akışın sonlanıp sonlanmadığını belirtir.
    #[prost(bool, tag="2")]
    pub is_final: bool,
}
include!("sentiric.tts.v1.tonic.rs");
// @@protoc_insertion_point(module)